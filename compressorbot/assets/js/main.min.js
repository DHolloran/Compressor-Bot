/*
 Copyright (C) 2013 Sencha Inc.
 Copyright (C) 2012 Sencha Inc.
 Copyright (C) 2011 Sencha Inc.

 Author: Ariya Hidayat.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

/*jslint continue: true, indent: 4 */
/*global exports:true, module:true, window:true */

(function () {

    'use strict';

    function cssbeautify(style, opt) {

        var options, index = 0, length = style.length, blocks, formatted = '',
            ch, ch2, str, state, State, depth, quote, comment,
            openbracesuffix = true,
            autosemicolon = false,
            trimRight;

        options = arguments.length > 1 ? opt : {};
        if (typeof options.indent === 'undefined') {
            options.indent = '    ';
        }
        if (typeof options.openbrace === 'string') {
            openbracesuffix = (options.openbrace === 'end-of-line');
        }
        if (typeof options.autosemicolon === 'boolean') {
            autosemicolon = options.autosemicolon;
        }

        function isWhitespace(c) {
            return (c === ' ') || (c === '\n') || (c === '\t') || (c === '\r') || (c === '\f');
        }

        function isQuote(c) {
            return (c === '\'') || (c === '"');
        }

        // FIXME: handle Unicode characters
        function isName(c) {
            return (ch >= 'a' && ch <= 'z') ||
                (ch >= 'A' && ch <= 'Z') ||
                (ch >= '0' && ch <= '9') ||
                '-_*.:#'.indexOf(c) >= 0;
        }

        function appendIndent() {
            var i;
            for (i = depth; i > 0; i -= 1) {
                formatted += options.indent;
            }
        }

        function openBlock() {
            formatted = trimRight(formatted);
            if (openbracesuffix) {
                formatted += ' {';
            } else {
                formatted += '\n';
                appendIndent();
                formatted += '{';
            }
            if (ch2 !== '\n') {
                formatted += '\n';
            }
            depth += 1;
        }

        function closeBlock() {
            var ch;
            depth -= 1;
            formatted = trimRight(formatted);

            if (autosemicolon) {
                ch = formatted.charAt(formatted.length - 1);
                if (ch !== ';' && ch !== '{') {
                    formatted += ';';
                }
            }

            formatted += '\n';
            appendIndent();
            formatted += '}';
            blocks.push(formatted);
            formatted = '';
        }

        if (String.prototype.trimRight) {
            trimRight = function (s) {
                return s.trimRight();
            };
        } else {
            // old Internet Explorer
            trimRight = function (s) {
                return s.replace(/\s+$/, '');
            };
        }

        State = {
            Start: 0,
            AtRule: 1,
            Block: 2,
            Selector: 3,
            Ruleset: 4,
            Property: 5,
            Separator: 6,
            Expression: 7,
            URL: 8
        };

        depth = 0;
        state = State.Start;
        comment = false;
        blocks = [];

        // We want to deal with LF (\n) only
        style = style.replace(/\r\n/g, '\n');

        while (index < length) {
            ch = style.charAt(index);
            ch2 = style.charAt(index + 1);
            index += 1;

            // Inside a string literal?
            if (isQuote(quote)) {
                formatted += ch;
                if (ch === quote) {
                    quote = null;
                }
                if (ch === '\\' && ch2 === quote) {
                    // Don't treat escaped character as the closing quote
                    formatted += ch2;
                    index += 1;
                }
                continue;
            }

            // Starting a string literal?
            if (isQuote(ch)) {
                formatted += ch;
                quote = ch;
                continue;
            }

            // Comment
            if (comment) {
                formatted += ch;
                if (ch === '*' && ch2 === '/') {
                    comment = false;
                    formatted += ch2;
                    index += 1;
                }
                continue;
            } else {
                if (ch === '/' && ch2 === '*') {
                    comment = true;
                    formatted += ch;
                    formatted += ch2;
                    index += 1;
                    continue;
                }
            }

            if (state === State.Start) {

                if (blocks.length === 0) {
                    if (isWhitespace(ch) && formatted.length === 0) {
                        continue;
                    }
                }

                // Copy white spaces and control characters
                if (ch <= ' ' || ch.charCodeAt(0) >= 128) {
                    state = State.Start;
                    formatted += ch;
                    continue;
                }

                // Selector or at-rule
                if (isName(ch) || (ch === '[') || (ch === '@')) {

                    // Clear trailing whitespaces and linefeeds.
                    str = trimRight(formatted);

                    if (str.length === 0) {
                        // If we have empty string after removing all the trailing
                        // spaces, that means we are right after a block.
                        // Ensure a blank line as the separator.
                        if (blocks.length > 0) {
                            formatted = '\n\n';
                        }
                    } else {
                        // After finishing a ruleset or directive statement,
                        // there should be one blank line.
                        if (str.charAt(str.length - 1) === '}' ||
                                str.charAt(str.length - 1) === ';') {

                            formatted = str + '\n\n';
                        } else {
                            // After block comment, keep all the linefeeds but
                            // start from the first column (remove whitespaces prefix).
                            while (true) {
                                ch2 = formatted.charAt(formatted.length - 1);
                                if (ch2 !== ' ' && ch2.charCodeAt(0) !== 9) {
                                    break;
                                }
                                formatted = formatted.substr(0, formatted.length - 1);
                            }
                        }
                    }
                    formatted += ch;
                    state = (ch === '@') ? State.AtRule : State.Selector;
                    continue;
                }
            }

            if (state === State.AtRule) {

                // ';' terminates a statement.
                if (ch === ';') {
                    formatted += ch;
                    state = State.Start;
                    continue;
                }

                // '{' starts a block
                if (ch === '{') {
                    str = trimRight(formatted);
                    openBlock();
                    state = (str === '@font-face') ? State.Ruleset : State.Block;
                    continue;
                }

                formatted += ch;
                continue;
            }

            if (state === State.Block) {

                // Selector
                if (isName(ch)) {

                    // Clear trailing whitespaces and linefeeds.
                    str = trimRight(formatted);

                    if (str.length === 0) {
                        // If we have empty string after removing all the trailing
                        // spaces, that means we are right after a block.
                        // Ensure a blank line as the separator.
                        if (blocks.length > 0) {
                            formatted = '\n\n';
                        }
                    } else {
                        // Insert blank line if necessary.
                        if (str.charAt(str.length - 1) === '}') {
                            formatted = str + '\n\n';
                        } else {
                            // After block comment, keep all the linefeeds but
                            // start from the first column (remove whitespaces prefix).
                            while (true) {
                                ch2 = formatted.charAt(formatted.length - 1);
                                if (ch2 !== ' ' && ch2.charCodeAt(0) !== 9) {
                                    break;
                                }
                                formatted = formatted.substr(0, formatted.length - 1);
                            }
                        }
                    }

                    appendIndent();
                    formatted += ch;
                    state = State.Selector;
                    continue;
                }

                // '}' resets the state.
                if (ch === '}') {
                    closeBlock();
                    state = State.Start;
                    continue;
                }

                formatted += ch;
                continue;
            }

            if (state === State.Selector) {

                // '{' starts the ruleset.
                if (ch === '{') {
                    openBlock();
                    state = State.Ruleset;
                    continue;
                }

                // '}' resets the state.
                if (ch === '}') {
                    closeBlock();
                    state = State.Start;
                    continue;
                }

                formatted += ch;
                continue;
            }

            if (state === State.Ruleset) {

                // '}' finishes the ruleset.
                if (ch === '}') {
                    closeBlock();
                    state = State.Start;
                    if (depth > 0) {
                        state = State.Block;
                    }
                    continue;
                }

                // Make sure there is no blank line or trailing spaces inbetween
                if (ch === '\n') {
                    formatted = trimRight(formatted);
                    formatted += '\n';
                    continue;
                }

                // property name
                if (!isWhitespace(ch)) {
                    formatted = trimRight(formatted);
                    formatted += '\n';
                    appendIndent();
                    formatted += ch;
                    state = State.Property;
                    continue;
                }
                formatted += ch;
                continue;
            }

            if (state === State.Property) {

                // ':' concludes the property.
                if (ch === ':') {
                    formatted = trimRight(formatted);
                    formatted += ': ';
                    state = State.Expression;
                    if (isWhitespace(ch2)) {
                        state = State.Separator;
                    }
                    continue;
                }

                // '}' finishes the ruleset.
                if (ch === '}') {
                    closeBlock();
                    state = State.Start;
                    if (depth > 0) {
                        state = State.Block;
                    }
                    continue;
                }

                formatted += ch;
                continue;
            }

            if (state === State.Separator) {

                // Non-whitespace starts the expression.
                if (!isWhitespace(ch)) {
                    formatted += ch;
                    state = State.Expression;
                    continue;
                }

                // Anticipate string literal.
                if (isQuote(ch2)) {
                    state = State.Expression;
                }

                continue;
            }

            if (state === State.Expression) {

                // '}' finishes the ruleset.
                if (ch === '}') {
                    closeBlock();
                    state = State.Start;
                    if (depth > 0) {
                        state = State.Block;
                    }
                    continue;
                }

                // ';' completes the declaration.
                if (ch === ';') {
                    formatted = trimRight(formatted);
                    formatted += ';\n';
                    state = State.Ruleset;
                    continue;
                }

                formatted += ch;

                if (ch === '(') {
                    if (formatted.charAt(formatted.length - 2) === 'l' &&
                            formatted.charAt(formatted.length - 3) === 'r' &&
                            formatted.charAt(formatted.length - 4) === 'u') {

                        // URL starts with '(' and closes with ')'.
                        state = State.URL;
                        continue;
                    }
                }

                continue;
            }

            if (state === State.URL) {


                // ')' finishes the URL (only if it is not escaped).
                if (ch === ')' && formatted.charAt(formatted.length - 1 !== '\\')) {
                    formatted += ch;
                    state = State.Expression;
                    continue;
                }
            }

            // The default action is to copy the character (to prevent
            // infinite loop).
            formatted += ch;
        }

        formatted = blocks.join('') + formatted;

        return formatted;
    }

    if (typeof exports !== 'undefined') {
        // Node.js module.
        module.exports = exports = cssbeautify;
    } else if (typeof window === 'object') {
        // Browser loading.
        window.cssbeautify = cssbeautify;
    }

}());


/* **********************************************
     Begin jsbeautify.js
********************************************** */

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@jsbeautifier.org>
      http://jsbeautifier.org/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy   !jslint_happy
            ---------------------------------
             function ()      function()

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "expand-strict"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.

            expand-strict: put brace on own line even in such cases:

                var a =
                {
                    a: 5,
                    b: 6
                }
            This mode may break your scripts - e.g "return { a: 1 }" will be broken into two lines, so beware.

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/


(function() {
    function js_beautify(js_source_text, options) {
        "use strict";
        var beautifier = new Beautifier(js_source_text, options);
        return beautifier.beautify();
    }

    function Beautifier(js_source_text, options) {
        "use strict";
        var input, output, token_text, token_type, last_type, last_last_text, indent_string;
        var flags, previous_flags, flag_store;
        var whitespace, wordchar, punct, parser_pos, line_starters, digits;
        var prefix;
        var wanted_newline, n_newlines, output_wrapped, output_space_before_token, whitespace_before_token;
        var input_length;
        var handlers, MODE, opt;
        var preindent_string = '';

        whitespace = "\n\r\t ".split('');
        wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
        digits = '0123456789'.split('');

        punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! !! , : ? ^ ^= |= ::';
        punct += ' <%= <% %> <?= <? ?>'; // try to be a good boy and try not to break the markup language identifiers
        punct = punct.split(' ');

        // words which should always start on new line.
        line_starters = 'continue,try,throw,return,var,if,switch,case,default,for,while,break,function'.split(',');

        MODE = {
            BlockStatement: 'BlockStatement', // 'BLOCK'
            Statement: 'Statement', // 'STATEMENT'
            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
            Conditional: 'Conditional', //'(COND-EXPRESSION)',
            Expression: 'Expression' //'(EXPRESSION)'
        };

        handlers = {
            'TK_START_EXPR': handle_start_expr,
            'TK_END_EXPR': handle_end_expr,
            'TK_START_BLOCK': handle_start_block,
            'TK_END_BLOCK': handle_end_block,
            'TK_WORD': handle_word,
            'TK_SEMICOLON': handle_semicolon,
            'TK_STRING': handle_string,
            'TK_EQUALS': handle_equals,
            'TK_OPERATOR': handle_operator,
            'TK_COMMA': handle_comma,
            'TK_BLOCK_COMMENT': handle_block_comment,
            'TK_INLINE_COMMENT': handle_inline_comment,
            'TK_COMMENT': handle_comment,
            'TK_DOT': handle_dot,
            'TK_UNKNOWN': handle_unknown
        };

        function create_flags(flags_base, mode) {
            return {
                mode: mode,
                last_text: flags_base ? flags_base.last_text : '', // last token text
                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
                var_line: false,
                var_line_tainted: false,
                var_line_reindented: false,
                in_html_comment: false,
                multiline_array: false,
                if_block: false,
                do_block: false,
                do_while: false,
                in_case_statement: false, // switch(..){ INSIDE HERE }
                in_case: false, // we're on the exact line with "case 0:"
                case_body: false, // the indented case-action block
                indentation_level: (flags_base ? flags_base.indentation_level + ((flags_base.var_line && flags_base.var_line_reindented) ? 1 : 0) : 0),
                ternary_depth: 0
            };
        }

        // Some interpreters have unexpected results with foo = baz || bar;
        options = options ? options : {};
        opt = {};

        // compatibility
        if (options.space_after_anon_function !== undefined && options.jslint_happy === undefined) {
            options.jslint_happy = options.space_after_anon_function;
        }
        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
            opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
        }
        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : "collapse");

        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
        opt.indent_char = options.indent_char ? options.indent_char : ' ';
        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
        opt.space_before_conditional= (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);

        //----------------------------------
        indent_string = '';
        while (opt.indent_size > 0) {
            indent_string += opt.indent_char;
            opt.indent_size -= 1;
        }

        while (js_source_text && (js_source_text.charAt(0) === ' ' || js_source_text.charAt(0) === '\t')) {
            preindent_string += js_source_text.charAt(0);
            js_source_text = js_source_text.substring(1);
        }
        input = js_source_text;
        // cache the source's length.
        input_length = js_source_text.length;

        last_type = 'TK_START_BLOCK'; // last token type
        last_last_text = ''; // pre-last token text
        output = [];
        output_wrapped = false;
        output_space_before_token = false;
        whitespace_before_token = [];

        // Stack of parsing/formatting states, including MODE.
        // We tokenize, parse, and output in an almost purely a forward-only stream of token input
        // and formatted output.  This makes the beautifier less accurate than full parsers
        // but also far more tolerant of syntax errors.
        //
        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
        // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
        // most full parsers would die, but the beautifier gracefully falls back to
        // MODE.BlockStatement and continues on.
        flag_store = [];
        set_mode(MODE.BlockStatement);

        parser_pos = 0;

        this.beautify = function () {
            /*jshint onevar:true */
            var t, i, keep_whitespace, sweet_code;

            while (true) {
                t = get_next_token();
                token_text = t[0];
                token_type = t[1];

                if (token_type === 'TK_EOF') {
                    break;
                }

                keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);

                if (keep_whitespace) {
                    for (i = 0; i < n_newlines; i += 1) {
                        print_newline(true);
                    }
                } else {
                    wanted_newline = n_newlines > 0;
                    if (opt.max_preserve_newlines && n_newlines > opt.max_preserve_newlines) {
                        n_newlines = opt.max_preserve_newlines;
                    }

                    if (opt.preserve_newlines) {
                        if (n_newlines > 1) {
                            print_newline();
                            for (i = 1; i < n_newlines; i += 1) {
                                print_newline(true);
                            }
                        }
                    }
                }

                handlers[token_type]();

                // The cleanest handling of inline comments is to treat them as though they aren't there.
                // Just continue formatting and the behavior should be logical.
                // Also ignore unknown tokens.  Again, this should result in better behavior.
                if (token_type !== 'TK_INLINE_COMMENT' && token_type !== 'TK_COMMENT' &&
                    token_type !== 'TK_UNKNOWN') {
                    last_last_text = flags.last_text;
                    last_type = token_type;
                    flags.last_text = token_text;
                }
            }

            sweet_code = preindent_string + output.join('').replace(/[\r\n ]+$/, '');
            return sweet_code;
        };

        function trim_output(eat_newlines) {
            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;
            while (output.length && (output[output.length - 1] === ' ' || output[output.length - 1] === indent_string || output[output.length - 1] === preindent_string || (eat_newlines && (output[output.length - 1] === '\n' || output[output.length - 1] === '\r')))) {
                output.pop();
            }
        }

        function trim(s) {
            return s.replace(/^\s\s*|\s\s*$/, '');
        }

        // we could use just string.split, but
        // IE doesn't like returning empty strings

        function split_newlines(s) {
            //return s.split(/\x0d\x0a|\x0a/);

            s = s.replace(/\x0d/g, '');
            var out = [],
                idx = s.indexOf("\n");
            while (idx !== -1) {
                out.push(s.substring(0, idx));
                s = s.substring(idx + 1);
                idx = s.indexOf("\n");
            }
            if (s.length) {
                out.push(s);
            }
            return out;
        }

        function just_added_newline() {
            return output.length && output[output.length - 1] === "\n";
        }

        function _last_index_of(arr, find) {
            var i = arr.length - 1;
            if (i < 0) {
                i += arr.length;
            }
            if (i > arr.length - 1) {
                i = arr.length - 1;
            }
            for (i++; i-- > 0;) {
                if (i in arr && arr[i] === find) {
                    return i;
                }
            }
            return -1;
        }

        function allow_wrap_or_preserved_newline(force_linewrap) {
            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;
            if (opt.wrap_line_length && !force_linewrap) {
                var current_line = '';
                var proposed_line_length = 0;
                var start_line = _last_index_of(output, '\n') + 1;
                // never wrap the first token of a line.
                if (start_line < output.length) {
                    current_line = output.slice(start_line).join('');
                    proposed_line_length = current_line.length + token_text.length +
                        (output_space_before_token ? 1 : 0);
                    if (proposed_line_length >= opt.wrap_line_length) {
                        force_linewrap = true;
                    }
                }
            }
            if (((opt.preserve_newlines && wanted_newline) || force_linewrap) && !just_added_newline()) {
                print_newline(false, true);
                output_wrapped = true;
                wanted_newline = false;
            }
        }

        function print_newline(force_newline, preserve_statement_flags) {
            output_wrapped = false;
            output_space_before_token = false;

            if (!preserve_statement_flags) {
                if  (flags.last_text !== ';') {
                    while (flags.mode === MODE.Statement && !flags.if_block) {
                        restore_mode();
                    }
                }
            }

            if (flags.mode === MODE.ArrayLiteral) {
                flags.multiline_array = true;
            }


            if (!output.length) {
                return; // no newline on start of file
            }

            if (force_newline || !just_added_newline()) {
                output.push("\n");
            }
        }

        function print_token_line_indentation() {
            if (just_added_newline()) {
                if (opt.keep_array_indentation && is_array(flags.mode) && whitespace_before_token.length) {
                    output.push(whitespace_before_token.join('') + '');
                } else {
                    if (preindent_string) {
                        output.push(preindent_string);
                    }

                    print_indent_string(flags.indentation_level);
                    print_indent_string(flags.var_line && flags.var_line_reindented);
                    print_indent_string(output_wrapped);
                }
            }
        }

        function print_indent_string(level) {
            if (level === undefined) {
                level = 1;
            } else if (typeof level !== 'number') {
                level = level ? 1 : 0;
            }

            // Never indent your first output indent at the start of the file
            if (flags.last_text !== '') {
                for (var i = 0; i < level; i += 1) {
                    output.push(indent_string);
                }
            }
        }

        function print_token_space_before() {
            if (output_space_before_token && output.length) {
                var last_output = output[output.length - 1];
                if (!just_added_newline() && last_output !== ' ' && last_output !== indent_string) { // prevent occassional duplicate space
                    output.push(' ');
                }
            }
        }

        function print_token(printable_token) {
            printable_token = printable_token || token_text;
            print_token_line_indentation();
            output_wrapped = false;
            print_token_space_before();
            output_space_before_token = false;
            output.push(printable_token);
        }

        function indent() {
            flags.indentation_level += 1;
        }

        function set_mode(mode) {
            if (flags) {
                flag_store.push(flags);
                previous_flags = flags;
            } else {
                previous_flags = create_flags(null, mode);
            }

            flags = create_flags(previous_flags, mode);
        }

        function is_array(mode) {
            return mode === MODE.ArrayLiteral;
        }

        function is_expression(mode) {
            return in_array(mode, [MODE.ArrayLiteral, MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
        }

        function restore_mode() {
            if (flag_store.length > 0) {
                previous_flags = flags;
                flags = flag_store.pop();
            }
        }

        function start_of_statement() {
            if (
             (flags.last_text === 'do' ||
                 (flags.last_text === 'else' && token_text !== 'if') ||
                (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)))) {
                allow_wrap_or_preserved_newline();
                set_mode(MODE.Statement);
                indent();
                output_wrapped = false;
                return true;
            }
            return false;
        }

        function all_lines_start_with(lines, c) {
            for (var i = 0; i < lines.length; i++) {
                var line = trim(lines[i]);
                if (line.charAt(0) !== c) {
                    return false;
                }
            }
            return true;
        }

        function is_special_word(word) {
            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
        }

        function in_array(what, arr) {
            for (var i = 0; i < arr.length; i += 1) {
                if (arr[i] === what) {
                    return true;
                }
            }
            return false;
        }

        function unescape_string(s) {
            var esc = false,
                out = '',
                pos = 0,
                s_hex = '',
                escaped = 0,
                c;

            while (esc || pos < s.length) {

                c = s.charAt(pos);
                pos++;

                if (esc) {
                    esc = false;
                    if (c === 'x') {
                        // simple hex-escape \x24
                        s_hex = s.substr(pos, 2);
                        pos += 2;
                    } else if (c === 'u') {
                        // unicode-escape, \u2134
                        s_hex = s.substr(pos, 4);
                        pos += 4;
                    } else {
                        // some common escape, e.g \n
                        out += '\\' + c;
                        continue;
                    }
                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
                        // some weird escaping, bail out,
                        // leaving whole string intact
                        return s;
                    }

                    escaped = parseInt(s_hex, 16);

                    if (escaped >= 0x00 && escaped < 0x20) {
                        // leave 0x00...0x1f escaped
                        if (c === 'x') {
                            out += '\\x' + s_hex;
                        } else {
                            out += '\\u' + s_hex;
                        }
                        continue;
                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
                        // single-quote, apostrophe, backslash - escape these
                        out += '\\' + String.fromCharCode(escaped);
                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
                        // we bail out on \x7f..\xff,
                        // leaving whole string escaped,
                        // as it's probably completely binary
                        return s;
                    } else {
                        out += String.fromCharCode(escaped);
                    }
                } else if (c === '\\') {
                    esc = true;
                } else {
                    out += c;
                }
            }
            return out;
        }

        function is_next(find) {
            var local_pos = parser_pos;
            var c = input.charAt(local_pos);
            while (in_array(c, whitespace) && c !== find) {
                local_pos++;
                if (local_pos >= input_length) {
                    return false;
                }
                c = input.charAt(local_pos);
            }
            return c === find;
        }

        function get_next_token() {
            var i, resulting_string;

            n_newlines = 0;

            if (parser_pos >= input_length) {
                return ['', 'TK_EOF'];
            }

            wanted_newline = false;
            whitespace_before_token = [];

            var c = input.charAt(parser_pos);
            parser_pos += 1;

            while (in_array(c, whitespace)) {

                if (c === '\n') {
                    n_newlines += 1;
                    whitespace_before_token = [];
                } else if (n_newlines) {
                    if (c === indent_string) {
                        whitespace_before_token.push(indent_string);
                    } else if (c !== '\r') {
                        whitespace_before_token.push(' ');
                    }
                }

                if (parser_pos >= input_length) {
                    return ['', 'TK_EOF'];
                }

                c = input.charAt(parser_pos);
                parser_pos += 1;
            }

            if (in_array(c, wordchar)) {
                if (parser_pos < input_length) {
                    while (in_array(input.charAt(parser_pos), wordchar)) {
                        c += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos === input_length) {
                            break;
                        }
                    }
                }

                // small and surprisingly unugly hack for 1E-10 representation
                if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {

                    var sign = input.charAt(parser_pos);
                    parser_pos += 1;

                    var t = get_next_token();
                    c += sign + t[0];
                    return [c, 'TK_WORD'];
                }

                if (c === 'in') { // hack for 'in' operator
                    return [c, 'TK_OPERATOR'];
                }
                return [c, 'TK_WORD'];
            }

            if (c === '(' || c === '[') {
                return [c, 'TK_START_EXPR'];
            }

            if (c === ')' || c === ']') {
                return [c, 'TK_END_EXPR'];
            }

            if (c === '{') {
                return [c, 'TK_START_BLOCK'];
            }

            if (c === '}') {
                return [c, 'TK_END_BLOCK'];
            }

            if (c === ';') {
                return [c, 'TK_SEMICOLON'];
            }

            if (c === '/') {
                var comment = '';
                // peek for comment /* ... */
                var inline_comment = true;
                if (input.charAt(parser_pos) === '*') {
                    parser_pos += 1;
                    if (parser_pos < input_length) {
                        while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {
                            c = input.charAt(parser_pos);
                            comment += c;
                            if (c === "\n" || c === "\r") {
                                inline_comment = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                break;
                            }
                        }
                    }
                    parser_pos += 2;
                    if (inline_comment && n_newlines === 0) {
                        return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];
                    } else {
                        return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
                    }
                }
                // peek for comment // ...
                if (input.charAt(parser_pos) === '/') {
                    comment = c;
                    while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
                        comment += input.charAt(parser_pos);
                        parser_pos += 1;
                        if (parser_pos >= input_length) {
                            break;
                        }
                    }
                    return [comment, 'TK_COMMENT'];
                }

            }

            if (c === "'" || c === '"' || // string
            (c === '/' &&
                ((last_type === 'TK_WORD' && is_special_word (flags.last_text)) ||
                (last_type === 'TK_END_EXPR' && in_array(previous_flags.mode, [MODE.Conditional, MODE.ForInitializer])) ||
                (in_array(last_type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
            ]))))) { // regexp
                var sep = c,
                    esc = false,
                    has_char_escapes = false;

                resulting_string = c;

                if (parser_pos < input_length) {
                    if (sep === '/') {
                        //
                        // handle regexp separately...
                        //
                        var in_char_class = false;
                        while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
                            resulting_string += input.charAt(parser_pos);
                            if (!esc) {
                                esc = input.charAt(parser_pos) === '\\';
                                if (input.charAt(parser_pos) === '[') {
                                    in_char_class = true;
                                } else if (input.charAt(parser_pos) === ']') {
                                    in_char_class = false;
                                }
                            } else {
                                esc = false;
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                // incomplete string/rexp when end-of-file reached.
                                // bail out with what had been received so far.
                                return [resulting_string, 'TK_STRING'];
                            }
                        }

                    } else {
                        //
                        // and handle string also separately
                        //
                        while (esc || input.charAt(parser_pos) !== sep) {
                            resulting_string += input.charAt(parser_pos);
                            if (esc) {
                                if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
                                    has_char_escapes = true;
                                }
                                esc = false;
                            } else {
                                esc = input.charAt(parser_pos) === '\\';
                            }
                            parser_pos += 1;
                            if (parser_pos >= input_length) {
                                // incomplete string/rexp when end-of-file reached.
                                // bail out with what had been received so far.
                                return [resulting_string, 'TK_STRING'];
                            }
                        }

                    }
                }

                parser_pos += 1;
                resulting_string += sep;

                if (has_char_escapes && opt.unescape_strings) {
                    resulting_string = unescape_string(resulting_string);
                }

                if (sep === '/') {
                    // regexps may have modifiers /regexp/MOD , so fetch those, too
                    while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {
                        resulting_string += input.charAt(parser_pos);
                        parser_pos += 1;
                    }
                }
                return [resulting_string, 'TK_STRING'];
            }

            if (c === '#') {


                if (output.length === 0 && input.charAt(parser_pos) === '!') {
                    // shebang
                    resulting_string = c;
                    while (parser_pos < input_length && c !== '\n') {
                        c = input.charAt(parser_pos);
                        resulting_string += c;
                        parser_pos += 1;
                    }
                    return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
                }



                // Spidermonkey-specific sharp variables for circular references
                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
                var sharp = '#';
                if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {
                    do {
                        c = input.charAt(parser_pos);
                        sharp += c;
                        parser_pos += 1;
                    } while (parser_pos < input_length && c !== '#' && c !== '=');
                    if (c === '#') {
                        //
                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
                        sharp += '[]';
                        parser_pos += 2;
                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
                        sharp += '{}';
                        parser_pos += 2;
                    }
                    return [sharp, 'TK_WORD'];
                }
            }

            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
                parser_pos += 3;
                c = '<!--';
                while (input.charAt(parser_pos) !== '\n' && parser_pos < input_length) {
                    c += input.charAt(parser_pos);
                    parser_pos++;
                }
                flags.in_html_comment = true;
                return [c, 'TK_COMMENT'];
            }

            if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
                flags.in_html_comment = false;
                parser_pos += 2;
                return ['-->', 'TK_COMMENT'];
            }

            if (c === '.') {
                return [c, 'TK_DOT'];
            }

            if (in_array(c, punct)) {
                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
                    c += input.charAt(parser_pos);
                    parser_pos += 1;
                    if (parser_pos >= input_length) {
                        break;
                    }
                }

                if (c === ',') {
                    return [c, 'TK_COMMA'];
                } else if (c === '=') {
                    return [c, 'TK_EQUALS'];
                } else {
                    return [c, 'TK_OPERATOR'];
                }
            }

            return [c, 'TK_UNKNOWN'];
        }

        function handle_start_expr() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            }

            if (token_text === '[') {

                if (last_type === 'TK_WORD' || flags.last_text === ')') {
                    // this is array index specifier, break immediately
                    // a[x], fn()[x]
                    if (in_array (flags.last_text, line_starters)) {
                        output_space_before_token = true;
                    }
                    set_mode(MODE.Expression);
                    print_token();
                    return;
                }

                if (is_array(flags.mode)) {
                    if ( (flags.last_text === '[') ||
                        (last_last_text === ']' && flags.last_text === ',')) {
                        // ], [ goes to new line
                        if (!opt.keep_array_indentation) {
                            print_newline();
                        }
                    }
                }

            } else {
                if  (flags.last_text === 'for') {
                    set_mode(MODE.ForInitializer);
                } else if (in_array (flags.last_text, ['if', 'while'])) {
                    set_mode(MODE.Conditional);
                } else {
                    set_mode(MODE.Expression);
                }
            }

            if  (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
                print_newline();
            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
                if (wanted_newline) {
                    print_newline();
                }
                // do nothing on (( and )( and ][ and ]( and .(
            } else if (last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
                output_space_before_token = true;
            } else if (flags.last_word === 'function' || flags.last_word === 'typeof') {
                // function() vs function ()
                if (opt.jslint_happy) {
                    output_space_before_token = true;
                }
            } else if (in_array (flags.last_text, line_starters) || flags.last_text === 'catch') {
                if (opt.space_before_conditional) {
                    output_space_before_token = true;
                }
            }

            // Support of this kind of newline preservation.
            // a = (b &&
            //     (c || d));
            if (token_text === '(') {
                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                    if (flags.mode !== MODE.ObjectLiteral) {
                        allow_wrap_or_preserved_newline();
                    }
                }
            }
            print_token();
            if (token_text === '[') {
                set_mode(MODE.ArrayLiteral);
                indent();
            }
        }

        function handle_end_expr() {
            // statements inside expressions are not valid syntax, but...
            // statements must all be closed when their container closes
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }

            if (token_text === ']' && is_array(flags.mode) && flags.multiline_array && !opt.keep_array_indentation) {
                print_newline();
            }
            restore_mode();
            print_token();

            // do {} while () // no statement required after
            if (flags.do_while && previous_flags.mode === MODE.Conditional) {
                previous_flags.mode = MODE.Expression;
                flags.do_block = false;
                flags.do_while = false;

            }
        }

        function handle_start_block() {
            set_mode(MODE.BlockStatement);

            var empty_braces = is_next('}');

            if (opt.brace_style === "expand-strict") {
                if (!empty_braces) {
                    print_newline();
                }
            } else if (opt.brace_style === "expand") {
                if (last_type !== 'TK_OPERATOR') {
                    if (last_type === 'TK_EQUALS' ||
                        (is_special_word (flags.last_text) && flags.last_text !== 'else')) {
                        output_space_before_token = true;
                    } else {
                        print_newline();
                    }
                }
            } else { // collapse
                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
                    if (last_type === 'TK_START_BLOCK') {
                        print_newline();
                    } else {
                        output_space_before_token = true;
                    }
                } else {
                    // if TK_OPERATOR or TK_START_EXPR
                    if (is_array(previous_flags.mode) && flags.last_text === ',') {
                        if (last_last_text === '}') {
                            // }, { in array context
                            output_space_before_token = true;
                        } else {
                            print_newline(); // [a, b, c, {
                        }
                    }
                }
            }
            print_token();
            indent();
        }

        function handle_end_block() {
            // statements must all be closed when their container closes
            while (flags.mode === MODE.Statement) {
                restore_mode();
            }
            restore_mode();
            if (opt.brace_style === "expand" || opt.brace_style === "expand-strict") {
                if  (last_type !== 'TK_START_BLOCK') {
                    print_newline();
                }
            } else {
                // skip {}
                if (last_type !== 'TK_START_BLOCK') {
                    if (is_array(flags.mode) && opt.keep_array_indentation) {
                        // we REALLY need a newline here, but newliner would skip that
                        opt.keep_array_indentation = false;
                        print_newline();
                        opt.keep_array_indentation = true;

                    } else {
                        print_newline();
                    }
                }
            }
            print_token();
        }

        function handle_word() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
            } else if (wanted_newline && !is_expression(flags.mode) &&
                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
                last_type !== 'TK_EQUALS' &&
                (opt.preserve_newlines || flags.last_text !== 'var')) {

                print_newline();
            }

            if (flags.do_block && !flags.do_while) {
                if (token_text === 'while') {
                    // do {} ## while ()
                    output_space_before_token = true;
                    print_token();
                    output_space_before_token = true;
                    flags.do_while = true;
                    return;
                } else {
                    // do {} should always have while as the next word.
                    // if we don't see the expected while, recover
                    print_newline();
                    flags.do_block = false;
                }
            }

            // if may be followed by else, or not
            // Bare/inline ifs are tricky
            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
            if (flags.if_block) {
                if (token_text !== 'else') {
                    while (flags.mode === MODE.Statement) {
                        restore_mode();
                    }
                    flags.if_block = false;
                }
            }

            if (token_text === 'function') {
                if (flags.var_line && last_type !== 'TK_EQUALS') {
                    flags.var_line_reindented = true;
                }
                if ((just_added_newline() || flags.last_text === ';') && flags.last_text !== '{' && last_type !== 'TK_BLOCK_COMMENT' && last_type !== 'TK_COMMENT') {
                    // make sure there is a nice clean space of at least one blank line
                    // before a new function definition
                    n_newlines = just_added_newline() ? n_newlines : 0;
                    if (!opt.preserve_newlines) {
                        n_newlines = 1;
                    }

                    for (var i = 0; i < 2 - n_newlines; i++) {
                        print_newline(true);
                    }
                }
                if (last_type === 'TK_WORD') {
                    if  (flags.last_text === 'get' || flags.last_text === 'set' || flags.last_text === 'new' || flags.last_text === 'return') {
                        output_space_before_token = true;
                    } else {
                        print_newline();
                    }
                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
                    // foo = function
                    output_space_before_token = true;
                } else if (is_expression(flags.mode)) {
                    // (function
                } else {
                    print_newline();
                }

                print_token();
                flags.last_word = token_text;
                return;
            }

            if (token_text === 'case' || (token_text === 'default' && flags.in_case_statement)) {
                print_newline();
                if (flags.case_body) {
                    // switch cases following one another
                    flags.indentation_level--;
                    flags.case_body = false;
                }
                print_token();
                flags.in_case = true;
                flags.in_case_statement = true;
                return;
            }

            prefix = 'NONE';

            if (last_type === 'TK_END_BLOCK') {
                if (!in_array(token_text, ['else', 'catch', 'finally'])) {
                    prefix = 'NEWLINE';
                } else {
                    if (opt.brace_style === "expand" || opt.brace_style === "end-expand" || opt.brace_style === "expand-strict") {
                        prefix = 'NEWLINE';
                    } else {
                        prefix = 'SPACE';
                        output_space_before_token = true;
                    }
                }
            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
                // TODO: Should this be for STATEMENT as well?
                prefix = 'NEWLINE';
            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
                prefix = 'SPACE';
            } else if (last_type === 'TK_STRING') {
                prefix = 'NEWLINE';
            } else if (last_type === 'TK_WORD') {
                prefix = 'SPACE';
            } else if (last_type === 'TK_START_BLOCK') {
                prefix = 'NEWLINE';
            } else if (last_type === 'TK_END_EXPR') {
                output_space_before_token = true;
                prefix = 'NEWLINE';
            }

            if (in_array(token_text, line_starters) && flags.last_text !== ')') {
                if  (flags.last_text === 'else') {
                    prefix = 'SPACE';
                } else {
                    prefix = 'NEWLINE';
                }

            }

            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (flags.mode !== MODE.ObjectLiteral) {
                    allow_wrap_or_preserved_newline();
                }
            }

            if (in_array(token_text, ['else', 'catch', 'finally'])) {
                if (last_type !== 'TK_END_BLOCK' || opt.brace_style === "expand" || opt.brace_style === "end-expand" || opt.brace_style === "expand-strict") {
                    print_newline();
                } else {
                    trim_output(true);
                    // If we trimmed and there's something other than a close block before us
                    // put a newline back in.  Handles '} // comment' scenario.
                    if (output[output.length - 1] !== '}') {
                        print_newline();
                    }
                    output_space_before_token = true;
                }
            } else if (prefix === 'NEWLINE') {
                if (is_special_word (flags.last_text)) {
                    // no newline between 'return nnn'
                    output_space_before_token = true;
                } else if (last_type !== 'TK_END_EXPR') {
                    if ((last_type !== 'TK_START_EXPR' || token_text !== 'var') && flags.last_text !== ':') {
                        // no need to force newline on 'var': for (var x = 0...)
                        if (token_text === 'if' && flags.last_word === 'else' && flags.last_text !== '{') {
                            // no newline for } else if {
                            output_space_before_token = true;
                        } else {
                            flags.var_line = false;
                            flags.var_line_reindented = false;
                            print_newline();
                        }
                    }
                } else if (in_array(token_text, line_starters) && flags.last_text !== ')') {
                    flags.var_line = false;
                    flags.var_line_reindented = false;
                    print_newline();
                }
            } else if (is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
                print_newline(); // }, in lists get a newline treatment
            } else if (prefix === 'SPACE') {
                output_space_before_token = true;
            }
            print_token();
            flags.last_word = token_text;

            if (token_text === 'var') {
                flags.var_line = true;
                flags.var_line_reindented = false;
                flags.var_line_tainted = false;
            }

            if (token_text === 'do') {
                flags.do_block = true;
            }

            if (token_text === 'if') {
                flags.if_block = true;
            }
        }

        function handle_semicolon() {
            while (flags.mode === MODE.Statement && !flags.if_block) {
                restore_mode();
            }
            print_token();
            flags.var_line = false;
            flags.var_line_reindented = false;
            if (flags.mode === MODE.ObjectLiteral) {
                // if we're in OBJECT mode and see a semicolon, its invalid syntax
                // recover back to treating this as a BLOCK
                flags.mode = MODE.BlockStatement;
            }
        }

        function handle_string() {
            if (start_of_statement()) {
                // The conditional starts the statement if appropriate.
                // One difference - strings want at least a space before
                output_space_before_token = true;
            } else if (last_type === 'TK_WORD') {
                output_space_before_token = true;
            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
                if (flags.mode !== MODE.ObjectLiteral) {
                    allow_wrap_or_preserved_newline();
                }
            } else {
                print_newline();
            }
            print_token();
        }

        function handle_equals() {
            if (flags.var_line) {
                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
                flags.var_line_tainted = true;
            }
            output_space_before_token = true;
            print_token();
            output_space_before_token = true;
        }

        function handle_comma() {
            if (flags.var_line) {
                if (is_expression(flags.mode) || last_type === 'TK_END_BLOCK') {
                    // do not break on comma, for(var a = 1, b = 2)
                    flags.var_line_tainted = false;
                }

                if (flags.var_line) {
                    flags.var_line_reindented = true;
                }

                print_token();

                if (flags.var_line_tainted) {
                    flags.var_line_tainted = false;
                    print_newline();
                } else {
                    output_space_before_token = true;
                }
                return;
            }

            if (last_type === 'TK_END_BLOCK' && flags.mode !== MODE.Expression) {
                print_token();
                if (flags.mode === MODE.ObjectLiteral && flags.last_text === '}') {
                    print_newline();
                } else {
                    output_space_before_token = true;
                }
            } else {
                if (flags.mode === MODE.ObjectLiteral) {
                    print_token();
                    print_newline();
                } else {
                    // EXPR or DO_BLOCK
                    print_token();
                    output_space_before_token = true;
                }
            }
        }

        function handle_operator() {
            var space_before = true;
            var space_after = true;
            if (is_special_word (flags.last_text)) {
                // "return" had a special handling in TK_WORD. Now we need to return the favor
                output_space_before_token = true;
                print_token();
                return;
            }

            // hack for actionscript's import .*;
            if (token_text === '*' && last_type === 'TK_DOT' && !last_last_text.match(/^\d+$/)) {
                print_token();
                return;
            }

            if (token_text === ':' && flags.in_case) {
                flags.case_body = true;
                indent();
                print_token();
                print_newline();
                flags.in_case = false;
                return;
            }

            if (token_text === '::') {
                // no spaces around exotic namespacing syntax operator
                print_token();
                return;
            }

            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
            // if there is a newline between -- or ++ and anything else we should preserve it.
            if (wanted_newline && (token_text === '--' || token_text === '++')) {
                print_newline();
            }

            if (in_array(token_text, ['--', '++', '!']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array (flags.last_text, line_starters) || flags.last_text === ','))) {
                // unary operators (and binary +/- pretending to be unary) special cases

                space_before = false;
                space_after = false;

                if  (flags.last_text === ';' && is_expression(flags.mode)) {
                    // for (;; ++i)
                    //        ^^^
                    space_before = true;
                }

                if (last_type === 'TK_WORD' && in_array (flags.last_text, line_starters)) {
                    space_before = true;
                }

                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) &&  (flags.last_text === '{' || flags.last_text === ';')) {
                    // { foo; --i }
                    // foo(); --bar;
                    print_newline();
                }
            } else if (token_text === ':') {
                if (flags.ternary_depth === 0) {
                    if (flags.mode === MODE.BlockStatement) {
                        flags.mode = MODE.ObjectLiteral;
                    }
                    space_before = false;
                } else {
                    flags.ternary_depth -= 1;
                }
            } else if (token_text === '?') {
                flags.ternary_depth += 1;
            }
            output_space_before_token = output_space_before_token || space_before;
            print_token();
            output_space_before_token = space_after;
        }

        function handle_block_comment() {
            var lines = split_newlines(token_text);
            var j; // iterator for this case

            if (all_lines_start_with(lines.slice(1), '*')) {
                // javadoc: reformat and reindent
                print_newline(false, true);
                print_token(lines[0]);
                for (j = 1; j < lines.length; j++) {
                    print_newline(false, true);
                    print_token(' ' + trim(lines[j]));
                }

            } else {

                // simple block comment: leave intact
                if (lines.length > 1) {
                    // multiline comment block starts with a new line
                    print_newline(false, true);
                } else {
                    // single-line /* comment */ stays where it is
                    if (last_type === 'TK_END_BLOCK') {
                        print_newline(false, true);
                    } else {
                        output_space_before_token = true;
                    }

                }

                print_token(lines[0]);
                output.push("\n");
                for (j = 1; j < lines.length; j++) {
                    output.push(lines[j]);
                    output.push("\n");
                }

            }

            if (!is_next('\n')) {
                print_newline(false, true);
            }
        }

        function handle_inline_comment() {
            output_space_before_token = true;
            print_token();
            output_space_before_token = true;
        }

        function handle_comment() {
            if (wanted_newline) {
                print_newline(false, true);
            }
            if  (flags.last_text === ',' && !wanted_newline) {
                trim_output(true);
            }

            output_space_before_token = true;
            print_token();
            print_newline(false, true);
        }

        function handle_dot() {
            if (is_special_word (flags.last_text)) {
                output_space_before_token = true;
            } else {
                // allow preserved newlines before dots in general
                // force newlines on dots after close paren when break_chained - for bar().baz()
                allow_wrap_or_preserved_newline (flags.last_text === ')' && opt.break_chained_methods);
            }

            print_token();
        }

        function handle_unknown() {
            print_token();
            if (token_text[token_text.length - 1] === '\n') {
                print_newline();
            }
        }
    }


    if (typeof define === "function") {
        // Add support for require.js
        define(function(require, exports, module) {
            exports.js_beautify = js_beautify;
        });
    } else if (typeof exports !== "undefined") {
        // Add support for CommonJS. Just put this file somewhere on your require.paths
        // and you will be able to `var js_beautify = require("beautify").js_beautify`.
        exports.js_beautify = js_beautify;
    } else if (typeof window !== "undefined") {
        // If we're running a web page and don't have either of the above, add our one global
        window.js_beautify = js_beautify;
    }

}());


/* **********************************************
     Begin htmlbeautify.js
********************************************** */

/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <elfz@laacz.lv>
    http://jsbeautifier.org/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_size (default 4)          — indentation size,
    indent_char (default space)      — character to indent with,
    max_char (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"

    e.g.

    style_html(html_source, {
      'indent_size': 2,
      'indent_char': ' ',
      'max_char': 78,
      'brace_style': 'expand',
      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u']
    });
*/

if (typeof process !== 'undefined' && process.argv[0] === "node") {
    var css_beautify = require(__dirname + '/beautify-css.js').css_beautify;
    var js_beautify  = require(__dirname + '/beautify.js').js_beautify;
}

function style_html(html_source, options) {
//Wrapper function to invoke all the necessary constructors and deal with the output.

  var multi_parser,
      indent_size,
      indent_character,
      max_char,
      brace_style,
      unformatted;

  options = options || {};
  indent_size = options.indent_size || 4;
  indent_character = options.indent_char || ' ';
  brace_style = options.brace_style || 'collapse';
  max_char = options.max_char === 0 ? Infinity : options.max_char || 250;
  unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];

  function Parser() {

    this.pos = 0; //Parser position
    this.token = '';
    this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
    this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
      parent: 'parent1',
      parentcount: 1,
      parent1: ''
    };
    this.tag_type = '';
    this.token_text = this.last_token = this.last_text = this.token_type = '';

    this.Utils = { //Uilities made available to the various functions
      whitespace: "\n\r\t ".split(''),
      single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML
      extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them
      in_array: function (what, arr) {
        for (var i=0; i<arr.length; i++) {
          if (what === arr[i]) {
            return true;
          }
        }
        return false;
      }
    };

    this.get_content = function () { //function to capture regular content between tags

      var input_char = '',
          content = [],
          space = false; //if a space is needed

      while (this.input.charAt(this.pos) !== '<') {
        if (this.pos >= this.input.length) {
          return content.length?content.join(''):['', 'TK_EOF'];
        }

        input_char = this.input.charAt(this.pos);
        this.pos++;
        this.line_char_count++;

        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          if (content.length) {
            space = true;
          }
          this.line_char_count--;
          continue; //don't want to insert unnecessary space
        }
        else if (space) {
          if (this.line_char_count >= this.max_char) { //insert a line when the max_char is reached
            content.push('\n');
            for (var i=0; i<this.indent_level; i++) {
              content.push(this.indent_string);
            }
            this.line_char_count = 0;
          }
          else{
            content.push(' ');
            this.line_char_count++;
          }
          space = false;
        }
        content.push(input_char); //letter at-a-time (or string) inserted to an array
      }
      return content.length?content.join(''):'';
    };

    this.get_contents_to = function (name) { //get the full content of a script or style to pass to js_beautify
      if (this.pos === this.input.length) {
        return ['', 'TK_EOF'];
      }
      var input_char = '';
      var content = '';
      var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
      reg_match.lastIndex = this.pos;
      var reg_array = reg_match.exec(this.input);
      var end_script = reg_array?reg_array.index:this.input.length; //absolute end of script
      if(this.pos < end_script) { //get everything in between the script tags
        content = this.input.substring(this.pos, end_script);
        this.pos = end_script;
      }
      return content;
    };

    this.record_tag = function (tag){ //function to record a tag and its parent in this.tags Object
      if (this.tags[tag + 'count']) { //check for the existence of this tag type
        this.tags[tag + 'count']++;
        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
      }
      else { //otherwise initialize this tag type
        this.tags[tag + 'count'] = 1;
        this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
      }
      this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
      this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
    };

    this.retrieve_tag = function (tag) { //function to retrieve the opening tag to the corresponding closer
      if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
        var temp_parent = this.tags.parent; //check to see if it's a closable tag.
        while (temp_parent) { //till we reach '' (the initial value);
          if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
            break;
          }
          temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
        }
        if (temp_parent) { //if we caught something
          this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
          this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
        }
        delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
        delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
        if (this.tags[tag + 'count'] === 1) {
          delete this.tags[tag + 'count'];
        }
        else {
          this.tags[tag + 'count']--;
        }
      }
    };

    this.get_tag = function (peek) { //function to get a full tag and parse its type
      var input_char = '',
          content = [],
          comment = '',
          space = false,
          tag_start, tag_end,
          orig_pos = this.pos,
          orig_line_char_count = this.line_char_count;

      peek = peek !== undefined ? peek : false;

      do {
        if (this.pos >= this.input.length) {
          if (peek) {
            this.pos = orig_pos;
            this.line_char_count = orig_line_char_count;
          }
          return content.length?content.join(''):['', 'TK_EOF'];
        }

        input_char = this.input.charAt(this.pos);
        this.pos++;
        this.line_char_count++;

        if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
          space = true;
          this.line_char_count--;
          continue;
        }

        if (input_char === "'" || input_char === '"') {
          if (!content[1] || content[1] !== '!') { //if we're in a comment strings don't get treated specially
            input_char += this.get_unformatted(input_char);
            space = true;
          }
        }

        if (input_char === '=') { //no space before =
          space = false;
        }

        if (content.length && content[content.length-1] !== '=' && input_char !== '>' && space) {
            //no space after = or before >
          if (this.line_char_count >= this.max_char) {
            this.print_newline(false, content);
            this.line_char_count = 0;
          }
          else {
            content.push(' ');
            this.line_char_count++;
          }
          space = false;
        }
        if (input_char === '<') {
          tag_start = this.pos - 1;
        }
        content.push(input_char); //inserts character at-a-time (or string)
      } while (input_char !== '>');

      var tag_complete = content.join('');
      var tag_index;
      if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
        tag_index = tag_complete.indexOf(' ');
      }
      else { //otherwise go with the tag ending
        tag_index = tag_complete.indexOf('>');
      }
      var tag_check = tag_complete.substring(1, tag_index).toLowerCase();
      if (tag_complete.charAt(tag_complete.length-2) === '/' ||
        this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
        if ( ! peek) {
          this.tag_type = 'SINGLE';
        }
      }
      else if (tag_check === 'script') { //for later script handling
        if ( ! peek) {
          this.record_tag(tag_check);
          this.tag_type = 'SCRIPT';
        }
      }
      else if (tag_check === 'style') { //for future style handling (for now it justs uses get_content)
        if ( ! peek) {
          this.record_tag(tag_check);
          this.tag_type = 'STYLE';
        }
      }
      else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the "unformatted" tags
        comment = this.get_unformatted('</'+tag_check+'>', tag_complete); //...delegate to get_unformatted function
        content.push(comment);
        // Preserve collapsed whitespace either before or after this tag.
        if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)){
            content.splice(0, 0, this.input.charAt(tag_start - 1));
        }
        tag_end = this.pos - 1;
        if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)){
            content.push(this.input.charAt(tag_end + 1));
        }
        this.tag_type = 'SINGLE';
      }
      else if (tag_check.charAt(0) === '!') { //peek for <!-- comment
        if (tag_check.indexOf('[if') !== -1) { //peek for <!--[if conditional comment
          if (tag_complete.indexOf('!IE') !== -1) { //this type needs a closing --> so...
            comment = this.get_unformatted('-->', tag_complete); //...delegate to get_unformatted
            content.push(comment);
          }
          if ( ! peek) {
            this.tag_type = 'START';
          }
        }
        else if (tag_check.indexOf('[endif') !== -1) {//peek for <!--[endif end conditional comment
          this.tag_type = 'END';
          this.unindent();
        }
        else if (tag_check.indexOf('[cdata[') !== -1) { //if it's a <[cdata[ comment...
          comment = this.get_unformatted(']]>', tag_complete); //...delegate to get_unformatted function
          content.push(comment);
          if ( ! peek) {
            this.tag_type = 'SINGLE'; //<![CDATA[ comments are treated like single tags
          }
        }
        else {
          comment = this.get_unformatted('-->', tag_complete);
          content.push(comment);
          this.tag_type = 'SINGLE';
        }
      }
      else if ( ! peek) {
        if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
          this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
          this.tag_type = 'END';
        }
        else { //otherwise it's a start-tag
          this.record_tag(tag_check); //push it on the tag stack
          this.tag_type = 'START';
        }
        if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
          this.print_newline(true, this.output);
        }
      }

      if (peek) {
        this.pos = orig_pos;
        this.line_char_count = orig_line_char_count;
      }

      return content.join(''); //returns fully formatted tag
    };

    this.get_unformatted = function (delimiter, orig_tag) { //function to return unformatted content in its entirety

      if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
        return '';
      }
      var input_char = '';
      var content = '';
      var space = true;
      do {

        if (this.pos >= this.input.length) {
          return content;
        }

        input_char = this.input.charAt(this.pos);
        this.pos++;

        if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
          if (!space) {
            this.line_char_count--;
            continue;
          }
          if (input_char === '\n' || input_char === '\r') {
            content += '\n';
            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
            for (var i=0; i<this.indent_level; i++) {
              content += this.indent_string;
            }
            space = false; //...and make sure other indentation is erased
            */
            this.line_char_count = 0;
            continue;
          }
        }
        content += input_char;
        this.line_char_count++;
        space = true;


      } while (content.toLowerCase().indexOf(delimiter) === -1);
      return content;
    };

    this.get_token = function () { //initial handler for token-retrieval
      var token;

      if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
       var type = this.last_token.substr(7);
       token = this.get_contents_to(type);
        if (typeof token !== 'string') {
          return token;
        }
        return [token, 'TK_' + type];
      }
      if (this.current_mode === 'CONTENT') {
        token = this.get_content();
        if (typeof token !== 'string') {
          return token;
        }
        else {
          return [token, 'TK_CONTENT'];
        }
      }

      if (this.current_mode === 'TAG') {
        token = this.get_tag();
        if (typeof token !== 'string') {
          return token;
        }
        else {
          var tag_name_type = 'TK_TAG_' + this.tag_type;
          return [token, tag_name_type];
        }
      }
    };

    this.get_full_indent = function (level) {
      level = this.indent_level + level || 0;
      if (level < 1) {
        return '';
      }

      return Array(level + 1).join(this.indent_string);
    };

    this.is_unformatted = function(tag_check, unformatted) {
        //is this an HTML5 block-level link?
        if (!this.Utils.in_array(tag_check, unformatted)){
            return false;
        }

        if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)){
            return true;
        }

        //at this point we have an  tag; is its first child something we want to remain
        //unformatted?
        var next_tag = this.get_tag(true /* peek. */);
        if (next_tag && this.Utils.in_array(next_tag, unformatted)){
            return true;
        } else {
            return false;
        }
    };

    this.printer = function (js_source, indent_character, indent_size, max_char, brace_style) { //handles input/output and some other printing functions

      this.input = js_source || ''; //gets the input for the Parser
      this.output = [];
      this.indent_character = indent_character;
      this.indent_string = '';
      this.indent_size = indent_size;
      this.brace_style = brace_style;
      this.indent_level = 0;
      this.max_char = max_char;
      this.line_char_count = 0; //count to see if max_char was exceeded

      for (var i=0; i<this.indent_size; i++) {
        this.indent_string += this.indent_character;
      }

      this.print_newline = function (ignore, arr) {
        this.line_char_count = 0;
        if (!arr || !arr.length) {
          return;
        }
        if (!ignore) { //we might want the extra line
          while (this.Utils.in_array(arr[arr.length-1], this.Utils.whitespace)) {
            arr.pop();
          }
        }
        arr.push('\n');
        for (var i=0; i<this.indent_level; i++) {
          arr.push(this.indent_string);
        }
      };

      this.print_token = function (text) {
        this.output.push(text);
      };

      this.indent = function () {
        this.indent_level++;
      };

      this.unindent = function () {
        if (this.indent_level > 0) {
          this.indent_level--;
        }
      };
    };
    return this;
  }

  /*_____________________--------------------_____________________*/

  multi_parser = new Parser(); //wrapping functions Parser
  multi_parser.printer(html_source, indent_character, indent_size, max_char, brace_style); //initialize starting values

  while (true) {
      var t = multi_parser.get_token();
      multi_parser.token_text = t[0];
      multi_parser.token_type = t[1];

    if (multi_parser.token_type === 'TK_EOF') {
      break;
    }

    switch (multi_parser.token_type) {
      case 'TK_TAG_START':
        multi_parser.print_newline(false, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.indent();
        multi_parser.current_mode = 'CONTENT';
        break;
      case 'TK_TAG_STYLE':
      case 'TK_TAG_SCRIPT':
        multi_parser.print_newline(false, multi_parser.output);
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = 'CONTENT';
        break;
      case 'TK_TAG_END':
        //Print new line only if the tag has no content and has child
        if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
            var tag_name = multi_parser.token_text.match(/\w+/)[0];
            var tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length -1].match(/<\s*(\w+)/);
            if (tag_extracted_from_last_output === null || tag_extracted_from_last_output[1] !== tag_name) {
                multi_parser.print_newline(true, multi_parser.output);
            }
        }
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = 'CONTENT';
        break;
      case 'TK_TAG_SINGLE':
        // Don't add a newline before elements that should remain unformatted.
        var tag_check = multi_parser.token_text.match(/^\s*<([a-z]+)/i);
        if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)){
            multi_parser.print_newline(false, multi_parser.output);
        }
        multi_parser.print_token(multi_parser.token_text);
        multi_parser.current_mode = 'CONTENT';
        break;
      case 'TK_CONTENT':
        if (multi_parser.token_text !== '') {
          multi_parser.print_token(multi_parser.token_text);
        }
        multi_parser.current_mode = 'TAG';
        break;
      case 'TK_STYLE':
      case 'TK_SCRIPT':
        if (multi_parser.token_text !== '') {
          multi_parser.output.push('\n');
          var text = multi_parser.token_text,
              _beautifier,
              script_indent_level = 1;
          if (multi_parser.token_type === 'TK_SCRIPT') {
            _beautifier = typeof js_beautify === 'function' && js_beautify;
          } else if (multi_parser.token_type === 'TK_STYLE') {
            _beautifier = typeof css_beautify === 'function' && css_beautify;
          }

          if (options.indent_scripts === "keep") {
            script_indent_level = 0;
          } else if (options.indent_scripts === "separate") {
            script_indent_level = -multi_parser.indent_level;
          }

          var indentation = multi_parser.get_full_indent(script_indent_level);
          if (_beautifier) {
            // call the Beautifier if avaliable
            text = _beautifier(text.replace(/^\s*/, indentation), options);
          } else {
            // simply indent the string otherwise
            var white = text.match(/^\s*/)[0];
            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
            var reindent = multi_parser.get_full_indent(script_indent_level -_level);
            text = text.replace(/^\s*/, indentation)
                   .replace(/\r\n|\r|\n/g, '\n' + reindent)
                   .replace(/\s*$/, '');
          }
          if (text) {
            multi_parser.print_token(text);
            multi_parser.print_newline(true, multi_parser.output);
          }
        }
        multi_parser.current_mode = 'TAG';
        break;
    }
    multi_parser.last_token = multi_parser.token_type;
    multi_parser.last_text = multi_parser.token_text;
  }
  return multi_parser.output.join('');
}

// Add support for CommonJS. Just put this file somewhere on your require.paths
// and you will be able to `var html_beautify = require("beautify").html_beautify`.
if (typeof exports !== 'undefined') {
    exports.html_beautify = style_html;
}


/* **********************************************
     Begin cssmin.js
********************************************** */

/**
 * cssmin.js
 * Author: Stoyan Stefanov - http://phpied.com/
 * This is a JavaScript port of the CSS minification tool
 * distributed with YUICompressor, itself a port
 * of the cssmin utility by Isaac Schlueter - http://foohack.com/
 * Permission is hereby granted to use the JavaScript version under the same
 * conditions as the YUICompressor (original YUICompressor note below).
 */

/*
* YUI Compressor
* http://developer.yahoo.com/yui/compressor/
* Author: Julien Lecomte - http://www.julienlecomte.net/
* Copyright (c) 2011 Yahoo! Inc. All rights reserved.
* The copyrights embodied in the content of this file are licensed
* by Yahoo! Inc. under the BSD (revised) open source license.
*/
var YAHOO = YAHOO || {};
YAHOO.compressor = YAHOO.compressor || {};

/**
 * Utility method to replace all data urls with tokens before we start
 * compressing, to avoid performance issues running some of the subsequent
 * regexes against large strings chunks.
 *
 * @private
 * @method _extractDataUrls
 * @param {String} css The input css
 * @param {Array} The global array of tokens to preserve
 * @returns String The processed css
 */
YAHOO.compressor._extractDataUrls = function (css, preservedTokens) {

    // Leave data urls alone to increase parse performance.
    var maxIndex = css.length - 1,
        appendIndex = 0,
        startIndex,
        endIndex,
        terminator,
        foundTerminator,
        sb = [],
        m,
        preserver,
        token,
        pattern = /url\(\s*(["']?)data\:/g;

    // Since we need to account for non-base64 data urls, we need to handle 
    // ' and ) being part of the data string. Hence switching to indexOf,
    // to determine whether or not we have matching string terminators and
    // handling sb appends directly, instead of using matcher.append* methods.

    while ((m = pattern.exec(css)) !== null) {

        startIndex = m.index + 4;  // "url(".length()
        terminator = m[1];         // ', " or empty (not quoted)

        if (terminator.length === 0) {
            terminator = ")";
        }

        foundTerminator = false;

        endIndex = pattern.lastIndex - 1;

        while(foundTerminator === false && endIndex+1 <= maxIndex) {
            endIndex = css.indexOf(terminator, endIndex + 1);
    
            // endIndex == 0 doesn't really apply here
            if ((endIndex > 0) && (css.charAt(endIndex - 1) !== '\\')) {
                foundTerminator = true;
                if (")" != terminator) {
                    endIndex = css.indexOf(")", endIndex); 
                }
            }
        }

        // Enough searching, start moving stuff over to the buffer
        sb.push(css.substring(appendIndex, m.index));

        if (foundTerminator) {
            token = css.substring(startIndex, endIndex);
            token = token.replace(/\s+/g, "");
            preservedTokens.push(token);

            preserver = "url(___YUICSSMIN_PRESERVED_TOKEN_" + (preservedTokens.length - 1) + "___)";
            sb.push(preserver);

            appendIndex = endIndex + 1;
        } else {
            // No end terminator found, re-add the whole match. Should we throw/warn here?
            sb.push(css.substring(m.index, pattern.lastIndex));
            appendIndex = pattern.lastIndex;
        }
    }

    sb.push(css.substring(appendIndex));

    return sb.join("");
};

/**
 * Utility method to compress hex color values of the form #AABBCC to #ABC.
 * 
 * DOES NOT compress CSS ID selectors which match the above pattern (which would break things).
 * e.g. #AddressForm { ... }
 *
 * DOES NOT compress IE filters, which have hex color values (which would break things). 
 * e.g. filter: chroma(color="#FFFFFF");
 *
 * DOES NOT compress invalid hex values.
 * e.g. background-color: #aabbccdd
 *
 * @private
 * @method _compressHexColors
 * @param {String} css The input css
 * @returns String The processed css
 */
YAHOO.compressor._compressHexColors = function(css) {

    // Look for hex colors inside { ... } (to avoid IDs) and which don't have a =, or a " in front of them (to avoid filters)
    var pattern = /(\=\s*?["']?)?#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])(\}|[^0-9a-f{][^{]*?\})/gi,
        m,
        index = 0,
        isFilter,
        sb = [];

    while ((m = pattern.exec(css)) !== null) {

        sb.push(css.substring(index, m.index));

        isFilter = m[1];

        if (isFilter) {
            // Restore, maintain case, otherwise filter will break
            sb.push(m[1] + "#" + (m[2] + m[3] + m[4] + m[5] + m[6] + m[7]));
        } else {
            if (m[2].toLowerCase() == m[3].toLowerCase() &&
                m[4].toLowerCase() == m[5].toLowerCase() &&
                m[6].toLowerCase() == m[7].toLowerCase()) {

                // Compress.
                sb.push("#" + (m[3] + m[5] + m[7]).toLowerCase());
            } else {
                // Non compressible color, restore but lower case.
                sb.push("#" + (m[2] + m[3] + m[4] + m[5] + m[6] + m[7]).toLowerCase());
            }
        }

        index = pattern.lastIndex = pattern.lastIndex - m[8].length;
    }

    sb.push(css.substring(index));

    return sb.join("");
};

YAHOO.compressor.cssmin = function (css, linebreakpos) {

    var startIndex = 0,
        endIndex = 0,
        i = 0, max = 0,
        preservedTokens = [],
        comments = [],
        token = '',
        totallen = css.length,
        placeholder = '';

    css = this._extractDataUrls(css, preservedTokens);

    // collect all comment blocks...
    while ((startIndex = css.indexOf("/*", startIndex)) >= 0) {
        endIndex = css.indexOf("*/", startIndex + 2);
        if (endIndex < 0) {
            endIndex = totallen;
        }
        token = css.slice(startIndex + 2, endIndex);
        comments.push(token);
        css = css.slice(0, startIndex + 2) + "___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_" + (comments.length - 1) + "___" + css.slice(endIndex);
        startIndex += 2;
    }

    // preserve strings so their content doesn't get accidentally minified
    css = css.replace(/("([^\\"]|\\.|\\)*")|('([^\\']|\\.|\\)*')/g, function (match) {
        var i, max, quote = match.substring(0, 1);

        match = match.slice(1, -1);

        // maybe the string contains a comment-like substring?
        // one, maybe more? put'em back then
        if (match.indexOf("___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_") >= 0) {
            for (i = 0, max = comments.length; i < max; i = i + 1) {
                match = match.replace("___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_" + i + "___", comments[i]);
            }
        }

        // minify alpha opacity in filter strings
        match = match.replace(/progid:DXImageTransform\.Microsoft\.Alpha\(Opacity=/gi, "alpha(opacity=");

        preservedTokens.push(match);
        return quote + "___YUICSSMIN_PRESERVED_TOKEN_" + (preservedTokens.length - 1) + "___" + quote;
    });

    // strings are safe, now wrestle the comments
    for (i = 0, max = comments.length; i < max; i = i + 1) {

        token = comments[i];
        placeholder = "___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_" + i + "___";

        // ! in the first position of the comment means preserve
        // so push to the preserved tokens keeping the !
        if (token.charAt(0) === "!") {
            preservedTokens.push(token);
            css = css.replace(placeholder,  "___YUICSSMIN_PRESERVED_TOKEN_" + (preservedTokens.length - 1) + "___");
            continue;
        }

        // \ in the last position looks like hack for Mac/IE5
        // shorten that to /*\*/ and the next one to /**/
        if (token.charAt(token.length - 1) === "\\") {
            preservedTokens.push("\\");
            css = css.replace(placeholder,  "___YUICSSMIN_PRESERVED_TOKEN_" + (preservedTokens.length - 1) + "___");
            i = i + 1; // attn: advancing the loop
            preservedTokens.push("");
            css = css.replace("___YUICSSMIN_PRESERVE_CANDIDATE_COMMENT_" + i + "___",  "___YUICSSMIN_PRESERVED_TOKEN_" + (preservedTokens.length - 1) + "___");
            continue;
        }

        // keep empty comments after child selectors (IE7 hack)
        // e.g. html >/**/ body
        if (token.length === 0) {
            startIndex = css.indexOf(placeholder);
            if (startIndex > 2) {
                if (css.charAt(startIndex - 3) === '>') {
                    preservedTokens.push("");
                    css = css.replace(placeholder,  "___YUICSSMIN_PRESERVED_TOKEN_" + (preservedTokens.length - 1) + "___");
                }
            }
        }

        // in all other cases kill the comment
        css = css.replace("/*" + placeholder + "*/", "");
    }


    // Normalize all whitespace strings to single spaces. Easier to work with that way.
    css = css.replace(/\s+/g, " ");

    // Remove the spaces before the things that should not have spaces before them.
    // But, be careful not to turn "p :link {...}" into "p:link{...}"
    // Swap out any pseudo-class colons with the token, and then swap back.
    css = css.replace(/(^|\})(([^\{:])+:)+([^\{]*\{)/g, function (m) {
        return m.replace(":", "___YUICSSMIN_PSEUDOCLASSCOLON___");
    });
    css = css.replace(/\s+([!{};:>+\(\)\],])/g, '$1');
    css = css.replace(/___YUICSSMIN_PSEUDOCLASSCOLON___/g, ":");

    // retain space for special IE6 cases
    css = css.replace(/:first-(line|letter)(\{|,)/g, ":first-$1 $2");

    // no space after the end of a preserved comment
    css = css.replace(/\*\/ /g, '*/');


    // If there is a @charset, then only allow one, and push to the top of the file.
    css = css.replace(/^(.*)(@charset "[^"]*";)/gi, '$2$1');
    css = css.replace(/^(\s*@charset [^;]+;\s*)+/gi, '$1');

    // Put the space back in some cases, to support stuff like
    // @media screen and (-webkit-min-device-pixel-ratio:0){
    css = css.replace(/\band\(/gi, "and (");


    // Remove the spaces after the things that should not have spaces after them.
    css = css.replace(/([!{}:;>+\(\[,])\s+/g, '$1');

    // remove unnecessary semicolons
    css = css.replace(/;+\}/g, "}");

    // Replace 0(px,em,%) with 0.
    css = css.replace(/([\s:])(0)(px|em|%|in|cm|mm|pc|pt|ex)/gi, "$1$2");

    // Replace 0 0 0 0; with 0.
    css = css.replace(/:0 0 0 0(;|\})/g, ":0$1");
    css = css.replace(/:0 0 0(;|\})/g, ":0$1");
    css = css.replace(/:0 0(;|\})/g, ":0$1");

    // Replace background-position:0; with background-position:0 0;
    // same for transform-origin
    css = css.replace(/(background-position|transform-origin|webkit-transform-origin|moz-transform-origin|o-transform-origin|ms-transform-origin):0(;|\})/gi, function(all, prop, tail) {
        return prop.toLowerCase() + ":0 0" + tail;
    });

    // Replace 0.6 to .6, but only when preceded by : or a white-space
    css = css.replace(/(:|\s)0+\.(\d+)/g, "$1.$2");

    // Shorten colors from rgb(51,102,153) to #336699
    // This makes it more likely that it'll get further compressed in the next step.
    css = css.replace(/rgb\s*\(\s*([0-9,\s]+)\s*\)/gi, function () {
        var i, rgbcolors = arguments[1].split(',');
        for (i = 0; i < rgbcolors.length; i = i + 1) {
            rgbcolors[i] = parseInt(rgbcolors[i], 10).toString(16);
            if (rgbcolors[i].length === 1) {
                rgbcolors[i] = '0' + rgbcolors[i];
            }
        }
        return '#' + rgbcolors.join('');
    });

    // Shorten colors from #AABBCC to #ABC.
    css = this._compressHexColors(css);

    // Shorten color from #f00 to red
    css = css.replace(/(:|\s)(#f00)(;|})/g, "$1red$3");
    // Other colors
    css = css.replace(/(:|\s)(#000080)(;|})/g, "$1navy$3");
    css = css.replace(/(:|\s)(#808080)(;|})/g, "$1gray$3");
    css = css.replace(/(:|\s)(#808000)(;|})/g, "$1olive$3");
    css = css.replace(/(:|\s)(#800080)(;|})/g, "$1purple$3");
    css = css.replace(/(:|\s)(#c0c0c0)(;|})/g, "$1silver$3");
    css = css.replace(/(:|\s)(#008080)(;|})/g, "$1teal$3");
    css = css.replace(/(:|\s)(#ffa500)(;|})/g, "$1orange$3");
    css = css.replace(/(:|\s)(#800000)(;|})/g, "$1maroon$3");

    // border: none -> border:0
    css = css.replace(/(border|border-top|border-right|border-bottom|border-left|outline|background):none(;|\})/gi, function(all, prop, tail) {
        return prop.toLowerCase() + ":0" + tail;
    });

    // shorter opacity IE filter
    css = css.replace(/progid:DXImageTransform\.Microsoft\.Alpha\(Opacity=/gi, "alpha(opacity=");

    // Remove empty rules.
    css = css.replace(/[^\};\{\/]+\{\}/g, "");

    if (linebreakpos >= 0) {
        // Some source control tools don't like it when files containing lines longer
        // than, say 8000 characters, are checked in. The linebreak option is used in
        // that case to split long lines after a specific column.
        startIndex = 0;
        i = 0;
        while (i < css.length) {
            i = i + 1;
            if (css[i - 1] === '}' && i - startIndex > linebreakpos) {
                css = css.slice(0, i) + '\n' + css.slice(i);
                startIndex = i;
            }
        }
    }

    // Replace multiple semi-colons in a row by a single one
    // See SF bug #1980989
    css = css.replace(/;;+/g, ";");

    // restore preserved comments and strings
    for (i = 0, max = preservedTokens.length; i < max; i = i + 1) {
        css = css.replace("___YUICSSMIN_PRESERVED_TOKEN_" + i + "___", preservedTokens[i]);
    }

    // Trim the final string (for any leading or trailing white spaces)
    css = css.replace(/^\s+|\s+$/g, "");

    return css;

};


/* **********************************************
     Begin csslint.js
********************************************** */

/*!
CSSLint
Copyright (c) 2011 Nicole Sullivan and Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Build time: 17-January-2013 10:55:01 */
var CSSLint = (function(){
/*!
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.2, Build time: 17-January-2013 10:26:34 */
var parserlib = {};
(function(){


/**
 * A generic base to inherit from for any object
 * that needs event handling.
 * @class EventTarget
 * @constructor
 */
function EventTarget(){

    /**
     * The array of listeners for various events.
     * @type Object
     * @property _listeners
     * @private
     */
    this._listeners = {};    
}

EventTarget.prototype = {

    //restore constructor
    constructor: EventTarget,

    /**
     * Adds a listener for a given event type.
     * @param {String} type The type of event to add a listener for.
     * @param {Function} listener The function to call when the event occurs.
     * @return {void}
     * @method addListener
     */
    addListener: function(type, listener){
        if (!this._listeners[type]){
            this._listeners[type] = [];
        }

        this._listeners[type].push(listener);
    },
    
    /**
     * Fires an event based on the passed-in object.
     * @param {Object|String} event An object with at least a 'type' attribute
     *      or a string indicating the event name.
     * @return {void}
     * @method fire
     */    
    fire: function(event){
        if (typeof event == "string"){
            event = { type: event };
        }
        if (typeof event.target != "undefined"){
            event.target = this;
        }
        
        if (typeof event.type == "undefined"){
            throw new Error("Event object missing 'type' property.");
        }
        
        if (this._listeners[event.type]){
        
            //create a copy of the array and use that so listeners can't chane
            var listeners = this._listeners[event.type].concat();
            for (var i=0, len=listeners.length; i < len; i++){
                listeners[i].call(this, event);
            }
        }            
    },

    /**
     * Removes a listener for a given event type.
     * @param {String} type The type of event to remove a listener from.
     * @param {Function} listener The function to remove from the event.
     * @return {void}
     * @method removeListener
     */
    removeListener: function(type, listener){
        if (this._listeners[type]){
            var listeners = this._listeners[type];
            for (var i=0, len=listeners.length; i < len; i++){
                if (listeners[i] === listener){
                    listeners.splice(i, 1);
                    break;
                }
            }
            
            
        }            
    }
};
/**
 * Convenient way to read through strings.
 * @namespace parserlib.util
 * @class StringReader
 * @constructor
 * @param {String} text The text to read.
 */
function StringReader(text){

    /**
     * The input text with line endings normalized.
     * @property _input
     * @type String
     * @private
     */
    this._input = text.replace(/\n\r?/g, "\n");


    /**
     * The row for the character to be read next.
     * @property _line
     * @type int
     * @private
     */
    this._line = 1;


    /**
     * The column for the character to be read next.
     * @property _col
     * @type int
     * @private
     */
    this._col = 1;

    /**
     * The index of the character in the input to be read next.
     * @property _cursor
     * @type int
     * @private
     */
    this._cursor = 0;
}

StringReader.prototype = {

    //restore constructor
    constructor: StringReader,

    //-------------------------------------------------------------------------
    // Position info
    //-------------------------------------------------------------------------

    /**
     * Returns the column of the character to be read next.
     * @return {int} The column of the character to be read next.
     * @method getCol
     */
    getCol: function(){
        return this._col;
    },

    /**
     * Returns the row of the character to be read next.
     * @return {int} The row of the character to be read next.
     * @method getLine
     */
    getLine: function(){
        return this._line ;
    },

    /**
     * Determines if you're at the end of the input.
     * @return {Boolean} True if there's no more input, false otherwise.
     * @method eof
     */
    eof: function(){
        return (this._cursor == this._input.length);
    },

    //-------------------------------------------------------------------------
    // Basic reading
    //-------------------------------------------------------------------------

    /**
     * Reads the next character without advancing the cursor.
     * @param {int} count How many characters to look ahead (default is 1).
     * @return {String} The next character or null if there is no next character.
     * @method peek
     */
    peek: function(count){
        var c = null;
        count = (typeof count == "undefined" ? 1 : count);

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor + count - 1);
        }

        return c;
    },

    /**
     * Reads the next character from the input and adjusts the row and column
     * accordingly.
     * @return {String} The next character or null if there is no next character.
     * @method read
     */
    read: function(){
        var c = null;

        //if we're not at the end of the input...
        if (this._cursor < this._input.length){

            //if the last character was a newline, increment row count
            //and reset column count
            if (this._input.charAt(this._cursor) == "\n"){
                this._line++;
                this._col=1;
            } else {
                this._col++;
            }

            //get character and increment cursor and column
            c = this._input.charAt(this._cursor++);
        }

        return c;
    },

    //-------------------------------------------------------------------------
    // Misc
    //-------------------------------------------------------------------------

    /**
     * Saves the current location so it can be returned to later.
     * @method mark
     * @return {void}
     */
    mark: function(){
        this._bookmark = {
            cursor: this._cursor,
            line:   this._line,
            col:    this._col
        };
    },

    reset: function(){
        if (this._bookmark){
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
        }
    },

    //-------------------------------------------------------------------------
    // Advanced reading
    //-------------------------------------------------------------------------

    /**
     * Reads up to and including the given string. Throws an error if that
     * string is not found.
     * @param {String} pattern The string to read.
     * @return {String} The string when it is found.
     * @throws Error when the string pattern is not found.
     * @method readTo
     */
    readTo: function(pattern){

        var buffer = "",
            c;

        /*
         * First, buffer must be the same length as the pattern.
         * Then, buffer must end with the pattern or else reach the
         * end of the input.
         */
        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) != buffer.length - pattern.length){
            c = this.read();
            if (c){
                buffer += c;
            } else {
                throw new Error("Expected \"" + pattern + "\" at line " + this._line  + ", col " + this._col + ".");
            }
        }

        return buffer;

    },

    /**
     * Reads characters while each character causes the given
     * filter function to return true. The function is passed
     * in each character and either returns true to continue
     * reading or false to stop.
     * @param {Function} filter The function to read on each character.
     * @return {String} The string made up of all characters that passed the
     *      filter check.
     * @method readWhile
     */
    readWhile: function(filter){

        var buffer = "",
            c = this.read();

        while(c !== null && filter(c)){
            buffer += c;
            c = this.read();
        }

        return buffer;

    },

    /**
     * Reads characters that match either text or a regular expression and
     * returns those characters. If a match is found, the row and column
     * are adjusted; if no match is found, the reader's state is unchanged.
     * reading or false to stop.
     * @param {String|RegExp} matchter If a string, then the literal string
     *      value is searched for. If a regular expression, then any string
     *      matching the pattern is search for.
     * @return {String} The string made up of all characters that matched or
     *      null if there was no match.
     * @method readMatch
     */
    readMatch: function(matcher){

        var source = this._input.substring(this._cursor),
            value = null;

        //if it's a string, just do a straight match
        if (typeof matcher == "string"){
            if (source.indexOf(matcher) === 0){
                value = this.readCount(matcher.length);
            }
        } else if (matcher instanceof RegExp){
            if (matcher.test(source)){
                value = this.readCount(RegExp.lastMatch.length);
            }
        }

        return value;
    },


    /**
     * Reads a given number of characters. If the end of the input is reached,
     * it reads only the remaining characters and does not throw an error.
     * @param {int} count The number of characters to read.
     * @return {String} The string made up the read characters.
     * @method readCount
     */
    readCount: function(count){
        var buffer = "";

        while(count--){
            buffer += this.read();
        }

        return buffer;
    }

};
/**
 * Type to use when a syntax error occurs.
 * @class SyntaxError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function SyntaxError(message, line, col){

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
SyntaxError.prototype = new Error();
/**
 * Base type to represent a single syntactic unit.
 * @class SyntaxUnit
 * @namespace parserlib.util
 * @constructor
 * @param {String} text The text of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SyntaxUnit(text, line, col, type){


    /**
     * The column of text on which the unit resides.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line of text on which the unit resides.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.text = text;

    /**
     * The type of syntax unit.
     * @type int
     * @property type
     */
    this.type = type;
}

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.util.SyntaxUnit} The object representing the token.
 * @static
 * @method fromToken
 */
SyntaxUnit.fromToken = function(token){
    return new SyntaxUnit(token.value, token.startLine, token.startCol);
};

SyntaxUnit.prototype = {

    //restore constructor
    constructor: SyntaxUnit,
    
    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method valueOf
     */
    valueOf: function(){
        return this.toString();
    },
    
    /**
     * Returns the text representation of the unit.
     * @return {String} The text representation of the unit.
     * @method toString
     */
    toString: function(){
        return this.text;
    }

};
/*global StringReader, SyntaxError*/

/**
 * Generic TokenStream providing base functionality.
 * @class TokenStreamBase
 * @namespace parserlib.util
 * @constructor
 * @param {String|StringReader} input The text to tokenize or a reader from 
 *      which to read the input.
 */
function TokenStreamBase(input, tokenData){

    /**
     * The string reader for easy access to the text.
     * @type StringReader
     * @property _reader
     * @private
     */
    this._reader = input ? new StringReader(input.toString()) : null;
    
    /**
     * Token object for the last consumed token.
     * @type Token
     * @property _token
     * @private
     */
    this._token = null;    
    
    /**
     * The array of token information.
     * @type Array
     * @property _tokenData
     * @private
     */
    this._tokenData = tokenData;
    
    /**
     * Lookahead token buffer.
     * @type Array
     * @property _lt
     * @private
     */
    this._lt = [];
    
    /**
     * Lookahead token buffer index.
     * @type int
     * @property _ltIndex
     * @private
     */
    this._ltIndex = 0;
    
    this._ltIndexCache = [];
}

/**
 * Accepts an array of token information and outputs
 * an array of token data containing key-value mappings
 * and matching functions that the TokenStream needs.
 * @param {Array} tokens An array of token descriptors.
 * @return {Array} An array of processed token data.
 * @method createTokenData
 * @static
 */
TokenStreamBase.createTokenData = function(tokens){

    var nameMap     = [],
        typeMap     = {},
        tokenData     = tokens.concat([]),
        i            = 0,
        len            = tokenData.length+1;
    
    tokenData.UNKNOWN = -1;
    tokenData.unshift({name:"EOF"});

    for (; i < len; i++){
        nameMap.push(tokenData[i].name);
        tokenData[tokenData[i].name] = i;
        if (tokenData[i].text){
            typeMap[tokenData[i].text] = i;
        }
    }
    
    tokenData.name = function(tt){
        return nameMap[tt];
    };
    
    tokenData.type = function(c){
        return typeMap[c];
    };
    
    return tokenData;
};

TokenStreamBase.prototype = {

    //restore constructor
    constructor: TokenStreamBase,    
    
    //-------------------------------------------------------------------------
    // Matching methods
    //-------------------------------------------------------------------------
    
    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, the token is placed
     * back onto the token stream. You can pass in any number of
     * token types and this will return true if any of the token
     * types is found.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token might be. If an array is passed,
     *      it's assumed that the token can be any of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {Boolean} True if the token type matches, false if not.
     * @method match
     */
    match: function(tokenTypes, channel){
    
        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }
                
        var tt  = this.get(channel),
            i   = 0,
            len = tokenTypes.length;
            
        while(i < len){
            if (tt == tokenTypes[i++]){
                return true;
            }
        }
        
        //no match found, put the token back
        this.unget();
        return false;
    },    
    
    /**
     * Determines if the next token matches the given token type.
     * If so, that token is consumed; if not, an error is thrown.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method mustMatch
     */    
    mustMatch: function(tokenTypes, channel){

        var token;

        //always convert to an array, makes things easier
        if (!(tokenTypes instanceof Array)){
            tokenTypes = [tokenTypes];
        }

        if (!this.match.apply(this, arguments)){    
            token = this.LT(1);
            throw new SyntaxError("Expected " + this._tokenData[tokenTypes[0]].name + 
                " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
        }
    },
    
    //-------------------------------------------------------------------------
    // Consuming methods
    //-------------------------------------------------------------------------
    
    /**
     * Keeps reading from the token stream until either one of the specified
     * token types is found or until the end of the input is reached.
     * @param {int|int[]} tokenTypes Either a single token type or an array of
     *      token types that the next token should be. If an array is passed,
     *      it's assumed that the token must be one of these.
     * @param {variant} channel (Optional) The channel to read from. If not
     *      provided, reads from the default (unnamed) channel.
     * @return {void}
     * @method advance
     */
    advance: function(tokenTypes, channel){
        
        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){
            this.get();
        }

        return this.LA(0);    
    },
    
    /**
     * Consumes the next token from the token stream. 
     * @return {int} The token type of the token that was just consumed.
     * @method get
     */      
    get: function(channel){
    
        var tokenInfo   = this._tokenData,
            reader      = this._reader,
            value,
            i           =0,
            len         = tokenInfo.length,
            found       = false,
            token,
            info;
            
        //check the lookahead buffer first
        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){  
                           
            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            
            //obey channels logic
            while((info.channel !== undefined && channel !== info.channel) &&
                    this._ltIndex < this._lt.length){
                this._token = this._lt[this._ltIndex++];
                info = tokenInfo[this._token.type];
                i++;
            }
            
            //here be dragons
            if ((info.channel === undefined || channel === info.channel) &&
                    this._ltIndex <= this._lt.length){
                this._ltIndexCache.push(i);
                return this._token.type;
            }
        }
        
        //call token retriever method
        token = this._getToken();

        //if it should be hidden, don't save a token
        if (token.type > -1 && !tokenInfo[token.type].hide){
                     
            //apply token channel
            token.channel = tokenInfo[token.type].channel;
         
            //save for later
            this._token = token;
            this._lt.push(token);

            //save space that will be moved (must be done before array is truncated)
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);  
        
            //keep the buffer under 5 items
            if (this._lt.length > 5){
                this._lt.shift();                
            }
            
            //also keep the shift buffer under 5 items
            if (this._ltIndexCache.length > 5){
                this._ltIndexCache.shift();
            }
                
            //update lookahead index
            this._ltIndex = this._lt.length;
        }
            
        /*
         * Skip to the next token if:
         * 1. The token type is marked as hidden.
         * 2. The token type has a channel specified and it isn't the current channel.
         */
        info = tokenInfo[token.type];
        if (info && 
                (info.hide || 
                (info.channel !== undefined && channel !== info.channel))){
            return this.get(channel);
        } else {
            //return just the type
            return token.type;
        }
    },
    
    /**
     * Looks ahead a certain number of tokens and returns the token type at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {int} The token type of the token in the given position.
     * @method LA
     */
    LA: function(index){
        var total = index,
            tt;
        if (index > 0){
            //TODO: Store 5 somewhere
            if (index > 5){
                throw new Error("Too much lookahead.");
            }
        
            //get all those tokens
            while(total){
                tt = this.get();   
                total--;                            
            }
            
            //unget all those tokens
            while(total < index){
                this.unget();
                total++;
            }
        } else if (index < 0){
        
            if(this._lt[this._ltIndex+index]){
                tt = this._lt[this._ltIndex+index].type;
            } else {
                throw new Error("Too much lookbehind.");
            }
        
        } else {
            tt = this._token.type;
        }
        
        return tt;
    
    },
    
    /**
     * Looks ahead a certain number of tokens and returns the token at
     * that position. This will throw an error if you lookahead past the
     * end of input, past the size of the lookahead buffer, or back past
     * the first token in the lookahead buffer.
     * @param {int} The index of the token type to retrieve. 0 for the
     *      current token, 1 for the next, -1 for the previous, etc.
     * @return {Object} The token of the token in the given position.
     * @method LA
     */    
    LT: function(index){
    
        //lookahead first to prime the token buffer
        this.LA(index);
        
        //now find the token, subtract one because _ltIndex is already at the next index
        return this._lt[this._ltIndex+index-1];    
    },
    
    /**
     * Returns the token type for the next token in the stream without 
     * consuming it.
     * @return {int} The token type of the next token in the stream.
     * @method peek
     */
    peek: function(){
        return this.LA(1);
    },
    
    /**
     * Returns the actual token object for the last consumed token.
     * @return {Token} The token object for the last consumed token.
     * @method token
     */
    token: function(){
        return this._token;
    },
    
    /**
     * Returns the name of the token for the given token type.
     * @param {int} tokenType The type of token to get the name of.
     * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
     *      invalid token type.
     * @method tokenName
     */
    tokenName: function(tokenType){
        if (tokenType < 0 || tokenType > this._tokenData.length){
            return "UNKNOWN_TOKEN";
        } else {
            return this._tokenData[tokenType].name;
        }
    },
    
    /**
     * Returns the token type value for the given token name.
     * @param {String} tokenName The name of the token whose value should be returned.
     * @return {int} The token type value for the given token name or -1
     *      for an unknown token.
     * @method tokenName
     */    
    tokenType: function(tokenName){
        return this._tokenData[tokenName] || -1;
    },
    
    /**
     * Returns the last consumed token to the token stream.
     * @method unget
     */      
    unget: function(){
        //if (this._ltIndex > -1){
        if (this._ltIndexCache.length){
            this._ltIndex -= this._ltIndexCache.pop();//--;
            this._token = this._lt[this._ltIndex - 1];
        } else {
            throw new Error("Too much lookahead.");
        }
    }

};




parserlib.util = {
StringReader: StringReader,
SyntaxError : SyntaxError,
SyntaxUnit  : SyntaxUnit,
EventTarget : EventTarget,
TokenStreamBase : TokenStreamBase
};
})();


/*
Parser-Lib
Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
/* Version v0.2.2, Build time: 17-January-2013 10:26:34 */
(function(){
var EventTarget = parserlib.util.EventTarget,
TokenStreamBase = parserlib.util.TokenStreamBase,
StringReader = parserlib.util.StringReader,
SyntaxError = parserlib.util.SyntaxError,
SyntaxUnit  = parserlib.util.SyntaxUnit;


var Colors = {
    aliceblue       :"#f0f8ff",
    antiquewhite    :"#faebd7",
    aqua            :"#00ffff",
    aquamarine      :"#7fffd4",
    azure           :"#f0ffff",
    beige           :"#f5f5dc",
    bisque          :"#ffe4c4",
    black           :"#000000",
    blanchedalmond  :"#ffebcd",
    blue            :"#0000ff",
    blueviolet      :"#8a2be2",
    brown           :"#a52a2a",
    burlywood       :"#deb887",
    cadetblue       :"#5f9ea0",
    chartreuse      :"#7fff00",
    chocolate       :"#d2691e",
    coral           :"#ff7f50",
    cornflowerblue  :"#6495ed",
    cornsilk        :"#fff8dc",
    crimson         :"#dc143c",
    cyan            :"#00ffff",
    darkblue        :"#00008b",
    darkcyan        :"#008b8b",
    darkgoldenrod   :"#b8860b",
    darkgray        :"#a9a9a9",
    darkgreen       :"#006400",
    darkkhaki       :"#bdb76b",
    darkmagenta     :"#8b008b",
    darkolivegreen  :"#556b2f",
    darkorange      :"#ff8c00",
    darkorchid      :"#9932cc",
    darkred         :"#8b0000",
    darksalmon      :"#e9967a",
    darkseagreen    :"#8fbc8f",
    darkslateblue   :"#483d8b",
    darkslategray   :"#2f4f4f",
    darkturquoise   :"#00ced1",
    darkviolet      :"#9400d3",
    deeppink        :"#ff1493",
    deepskyblue     :"#00bfff",
    dimgray         :"#696969",
    dodgerblue      :"#1e90ff",
    firebrick       :"#b22222",
    floralwhite     :"#fffaf0",
    forestgreen     :"#228b22",
    fuchsia         :"#ff00ff",
    gainsboro       :"#dcdcdc",
    ghostwhite      :"#f8f8ff",
    gold            :"#ffd700",
    goldenrod       :"#daa520",
    gray            :"#808080",
    green           :"#008000",
    greenyellow     :"#adff2f",
    honeydew        :"#f0fff0",
    hotpink         :"#ff69b4",
    indianred       :"#cd5c5c",
    indigo          :"#4b0082",
    ivory           :"#fffff0",
    khaki           :"#f0e68c",
    lavender        :"#e6e6fa",
    lavenderblush   :"#fff0f5",
    lawngreen       :"#7cfc00",
    lemonchiffon    :"#fffacd",
    lightblue       :"#add8e6",
    lightcoral      :"#f08080",
    lightcyan       :"#e0ffff",
    lightgoldenrodyellow  :"#fafad2",
    lightgray       :"#d3d3d3",
    lightgreen      :"#90ee90",
    lightpink       :"#ffb6c1",
    lightsalmon     :"#ffa07a",
    lightseagreen   :"#20b2aa",
    lightskyblue    :"#87cefa",
    lightslategray  :"#778899",
    lightsteelblue  :"#b0c4de",
    lightyellow     :"#ffffe0",
    lime            :"#00ff00",
    limegreen       :"#32cd32",
    linen           :"#faf0e6",
    magenta         :"#ff00ff",
    maroon          :"#800000",
    mediumaquamarine:"#66cdaa",
    mediumblue      :"#0000cd",
    mediumorchid    :"#ba55d3",
    mediumpurple    :"#9370d8",
    mediumseagreen  :"#3cb371",
    mediumslateblue :"#7b68ee",
    mediumspringgreen   :"#00fa9a",
    mediumturquoise :"#48d1cc",
    mediumvioletred :"#c71585",
    midnightblue    :"#191970",
    mintcream       :"#f5fffa",
    mistyrose       :"#ffe4e1",
    moccasin        :"#ffe4b5",
    navajowhite     :"#ffdead",
    navy            :"#000080",
    oldlace         :"#fdf5e6",
    olive           :"#808000",
    olivedrab       :"#6b8e23",
    orange          :"#ffa500",
    orangered       :"#ff4500",
    orchid          :"#da70d6",
    palegoldenrod   :"#eee8aa",
    palegreen       :"#98fb98",
    paleturquoise   :"#afeeee",
    palevioletred   :"#d87093",
    papayawhip      :"#ffefd5",
    peachpuff       :"#ffdab9",
    peru            :"#cd853f",
    pink            :"#ffc0cb",
    plum            :"#dda0dd",
    powderblue      :"#b0e0e6",
    purple          :"#800080",
    red             :"#ff0000",
    rosybrown       :"#bc8f8f",
    royalblue       :"#4169e1",
    saddlebrown     :"#8b4513",
    salmon          :"#fa8072",
    sandybrown      :"#f4a460",
    seagreen        :"#2e8b57",
    seashell        :"#fff5ee",
    sienna          :"#a0522d",
    silver          :"#c0c0c0",
    skyblue         :"#87ceeb",
    slateblue       :"#6a5acd",
    slategray       :"#708090",
    snow            :"#fffafa",
    springgreen     :"#00ff7f",
    steelblue       :"#4682b4",
    tan             :"#d2b48c",
    teal            :"#008080",
    thistle         :"#d8bfd8",
    tomato          :"#ff6347",
    turquoise       :"#40e0d0",
    violet          :"#ee82ee",
    wheat           :"#f5deb3",
    white           :"#ffffff",
    whitesmoke      :"#f5f5f5",
    yellow          :"#ffff00",
    yellowgreen     :"#9acd32",
    //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system
    activeBorder        :"Active window border.",
    activecaption       :"Active window caption.",
    appworkspace        :"Background color of multiple document interface.",
    background          :"Desktop background.",
    buttonface          :"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonhighlight     :"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttonshadow        :"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
    buttontext          :"Text on push buttons.",
    captiontext         :"Text in caption, size box, and scrollbar arrow box.",
    graytext            :"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
    highlight           :"Item(s) selected in a control.",
    highlighttext       :"Text of item(s) selected in a control.",
    inactiveborder      :"Inactive window border.",
    inactivecaption     :"Inactive window caption.",
    inactivecaptiontext :"Color of text in an inactive caption.",
    infobackground      :"Background color for tooltip controls.",
    infotext            :"Text color for tooltip controls.",
    menu                :"Menu background.",
    menutext            :"Text in menus.",
    scrollbar           :"Scroll bar gray area.",
    threeddarkshadow    :"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedface          :"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedhighlight     :"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedlightshadow   :"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    threedshadow        :"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
    window              :"Window background.",
    windowframe         :"Window frame.",
    windowtext          :"Text in windows."
};
/*global SyntaxUnit, Parser*/
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class Combinator
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit. 
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Combinator(text, line, col){
    
    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = "unknown";
    
    //pretty simple
    if (/^\s+$/.test(text)){
        this.type = "descendant";
    } else if (text == ">"){
        this.type = "child";
    } else if (text == "+"){
        this.type = "adjacent-sibling";
    } else if (text == "~"){
        this.type = "sibling";
    }

}

Combinator.prototype = new SyntaxUnit();
Combinator.prototype.constructor = Combinator;


/*global SyntaxUnit, Parser*/
/**
 * Represents a media feature, such as max-width:500.
 * @namespace parserlib.css
 * @class MediaFeature
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {SyntaxUnit} name The name of the feature.
 * @param {SyntaxUnit} value The value of the feature or null if none.
 */
function MediaFeature(name, value){
    
    SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);

    /**
     * The name of the media feature
     * @type String
     * @property name
     */
    this.name = name;

    /**
     * The value for the feature or null if there is none.
     * @type SyntaxUnit
     * @property value
     */
    this.value = value;
}

MediaFeature.prototype = new SyntaxUnit();
MediaFeature.prototype.constructor = MediaFeature;


/*global SyntaxUnit, Parser*/
/**
 * Represents an individual media query.
 * @namespace parserlib.css
 * @class MediaQuery
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} modifier The modifier "not" or "only" (or null).
 * @param {String} mediaType The type of media (i.e., "print").
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function MediaQuery(modifier, mediaType, features, line, col){
    
    SyntaxUnit.call(this, (modifier ? modifier + " ": "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE); 

    /**
     * The media modifier ("not" or "only")
     * @type String
     * @property modifier
     */
    this.modifier = modifier;

    /**
     * The mediaType (i.e., "print")
     * @type String
     * @property mediaType
     */
    this.mediaType = mediaType;    
    
    /**
     * The parts that make up the selector.
     * @type Array
     * @property features
     */
    this.features = features;

}

MediaQuery.prototype = new SyntaxUnit();
MediaQuery.prototype.constructor = MediaQuery;


/*global Tokens, TokenStream, SyntaxError, Properties, Validation, ValidationError, SyntaxUnit,
    PropertyValue, PropertyValuePart, SelectorPart, SelectorSubPart, Selector,
    PropertyName, Combinator, MediaFeature, MediaQuery, EventTarget */

/**
 * A CSS3 parser.
 * @namespace parserlib.css
 * @class Parser
 * @constructor
 * @param {Object} options (Optional) Various options for the parser:
 *      starHack (true|false) to allow IE6 star hack as valid,
 *      underscoreHack (true|false) to interpret leading underscores
 *      as IE6-7 targeting for known properties, ieFilters (true|false)
 *      to indicate that IE < 8 filters should be accepted and not throw
 *      syntax errors.
 */
function Parser(options){

    //inherit event functionality
    EventTarget.call(this);


    this.options = options || {};

    this._tokenStream = null;
}

//Static constants
Parser.DEFAULT_TYPE = 0;
Parser.COMBINATOR_TYPE = 1;
Parser.MEDIA_FEATURE_TYPE = 2;
Parser.MEDIA_QUERY_TYPE = 3;
Parser.PROPERTY_NAME_TYPE = 4;
Parser.PROPERTY_VALUE_TYPE = 5;
Parser.PROPERTY_VALUE_PART_TYPE = 6;
Parser.SELECTOR_TYPE = 7;
Parser.SELECTOR_PART_TYPE = 8;
Parser.SELECTOR_SUB_PART_TYPE = 9;

Parser.prototype = function(){

    var proto = new EventTarget(),  //new prototype
        prop,
        additions =  {
        
            //restore constructor
            constructor: Parser,
                        
            //instance constants - yuck
            DEFAULT_TYPE : 0,
            COMBINATOR_TYPE : 1,
            MEDIA_FEATURE_TYPE : 2,
            MEDIA_QUERY_TYPE : 3,
            PROPERTY_NAME_TYPE : 4,
            PROPERTY_VALUE_TYPE : 5,
            PROPERTY_VALUE_PART_TYPE : 6,
            SELECTOR_TYPE : 7,
            SELECTOR_PART_TYPE : 8,
            SELECTOR_SUB_PART_TYPE : 9,            
        
            //-----------------------------------------------------------------
            // Grammar
            //-----------------------------------------------------------------
        
            _stylesheet: function(){
            
                /*
                 * stylesheet
                 *  : [ CHARSET_SYM S* STRING S* ';' ]?
                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
                 *    [ namespace [S|CDO|CDC]* ]*
                 *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*
                 *  ;
                 */ 
               
                var tokenStream = this._tokenStream,
                    charset     = null,
                    count,
                    token,
                    tt;
                    
                this.fire("startstylesheet");
            
                //try to read character set
                this._charset();
                
                this._skipCruft();

                //try to read imports - may be more than one
                while (tokenStream.peek() == Tokens.IMPORT_SYM){
                    this._import();
                    this._skipCruft();
                }
                
                //try to read namespaces - may be more than one
                while (tokenStream.peek() == Tokens.NAMESPACE_SYM){
                    this._namespace();
                    this._skipCruft();
                }
                
                //get the next token
                tt = tokenStream.peek();
                
                //try to read the rest
                while(tt > Tokens.EOF){
                
                    try {
                
                        switch(tt){
                            case Tokens.MEDIA_SYM:
                                this._media();
                                this._skipCruft();
                                break;
                            case Tokens.PAGE_SYM:
                                this._page(); 
                                this._skipCruft();
                                break;                   
                            case Tokens.FONT_FACE_SYM:
                                this._font_face(); 
                                this._skipCruft();
                                break;  
                            case Tokens.KEYFRAMES_SYM:
                                this._keyframes(); 
                                this._skipCruft();
                                break;                                
                            case Tokens.UNKNOWN_SYM:  //unknown @ rule
                                tokenStream.get();
                                if (!this.options.strict){
                                
                                    //fire error event
                                    this.fire({
                                        type:       "error",
                                        error:      null,
                                        message:    "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                                        line:       tokenStream.LT(0).startLine,
                                        col:        tokenStream.LT(0).startCol
                                    });                          
                                    
                                    //skip braces
                                    count=0;
                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) == Tokens.LBRACE){
                                        count++;    //keep track of nesting depth
                                    }
                                    
                                    while(count){
                                        tokenStream.advance([Tokens.RBRACE]);
                                        count--;
                                    }
                                    
                                } else {
                                    //not a syntax error, rethrow it
                                    throw new SyntaxError("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                                }                                
                                break;
                            case Tokens.S:
                                this._readWhitespace();
                                break;
                            default:                            
                                if(!this._ruleset()){
                                
                                    //error handling for known issues
                                    switch(tt){
                                        case Tokens.CHARSET_SYM:
                                            token = tokenStream.LT(1);
                                            this._charset(false);
                                            throw new SyntaxError("@charset not allowed here.", token.startLine, token.startCol);
                                        case Tokens.IMPORT_SYM:
                                            token = tokenStream.LT(1);
                                            this._import(false);
                                            throw new SyntaxError("@import not allowed here.", token.startLine, token.startCol);
                                        case Tokens.NAMESPACE_SYM:
                                            token = tokenStream.LT(1);
                                            this._namespace(false);
                                            throw new SyntaxError("@namespace not allowed here.", token.startLine, token.startCol);
                                        default:
                                            tokenStream.get();  //get the last token
                                            this._unexpectedToken(tokenStream.token());
                                    }
                                
                                }
                        }
                    } catch(ex) {
                        if (ex instanceof SyntaxError && !this.options.strict){
                            this.fire({
                                type:       "error",
                                error:      ex,
                                message:    ex.message,
                                line:       ex.line,
                                col:        ex.col
                            });                     
                        } else {
                            throw ex;
                        }
                    }
                    
                    tt = tokenStream.peek();
                }
                
                if (tt != Tokens.EOF){
                    this._unexpectedToken(tokenStream.token());
                }
            
                this.fire("endstylesheet");
            },
            
            _charset: function(emit){
                var tokenStream = this._tokenStream,
                    charset,
                    token,
                    line,
                    col;
                    
                if (tokenStream.match(Tokens.CHARSET_SYM)){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                
                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.STRING);
                    
                    token = tokenStream.token();
                    charset = token.value;
                    
                    this._readWhitespace();
                    tokenStream.mustMatch(Tokens.SEMICOLON);
                    
                    if (emit !== false){
                        this.fire({ 
                            type:   "charset",
                            charset:charset,
                            line:   line,
                            col:    col
                        });
                    }
                }            
            },
            
            _import: function(emit){
                /*
                 * import
                 *   : IMPORT_SYM S*
                 *    [STRING|URI] S* media_query_list? ';' S*
                 */    
            
                var tokenStream = this._tokenStream,
                    tt,
                    uri,
                    importToken,
                    mediaList   = [];
                
                //read import symbol
                tokenStream.mustMatch(Tokens.IMPORT_SYM);
                importToken = tokenStream.token();
                this._readWhitespace();
                
                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                
                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");                

                this._readWhitespace();
                
                mediaList = this._media_query_list();
                
                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();
                
                if (emit !== false){
                    this.fire({
                        type:   "import",
                        uri:    uri,
                        media:  mediaList,
                        line:   importToken.startLine,
                        col:    importToken.startCol
                    });
                }
        
            },
            
            _namespace: function(emit){
                /*
                 * namespace
                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*
                 */    
            
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    prefix,
                    uri;
                
                //read import symbol
                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                this._readWhitespace();
                
                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT
                if (tokenStream.match(Tokens.IDENT)){
                    prefix = tokenStream.token().value;
                    this._readWhitespace();
                }
                
                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
                /*if (!tokenStream.match(Tokens.STRING)){
                    tokenStream.mustMatch(Tokens.URI);
                }*/
                
                //grab the URI value
                uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");                

                this._readWhitespace();

                //must end with a semicolon
                tokenStream.mustMatch(Tokens.SEMICOLON);
                this._readWhitespace();
                
                if (emit !== false){
                    this.fire({
                        type:   "namespace",
                        prefix: prefix,
                        uri:    uri,
                        line:   line,
                        col:    col
                    });
                }
        
            },            
                       
            _media: function(){
                /*
                 * media
                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*
                 *   ;
                 */
                var tokenStream     = this._tokenStream,
                    line,
                    col,
                    mediaList;//       = [];
                
                //look for @media
                tokenStream.mustMatch(Tokens.MEDIA_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                
                this._readWhitespace();               

                mediaList = this._media_query_list();

                tokenStream.mustMatch(Tokens.LBRACE);
                this._readWhitespace();
                
                this.fire({
                    type:   "startmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
                
                while(true) {
                    if (tokenStream.peek() == Tokens.PAGE_SYM){
                        this._page();
                    } else if (!this._ruleset()){
                        break;
                    }                
                }
                
                tokenStream.mustMatch(Tokens.RBRACE);
                this._readWhitespace();
        
                this.fire({
                    type:   "endmedia",
                    media:  mediaList,
                    line:   line,
                    col:    col
                });
            },                           
        

            //CSS3 Media Queries
            _media_query_list: function(){
                /*
                 * media_query_list
                 *   : S* [media_query [ ',' S* media_query ]* ]?
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    mediaList   = [];
                
                
                this._readWhitespace();
                
                if (tokenStream.peek() == Tokens.IDENT || tokenStream.peek() == Tokens.LPAREN){
                    mediaList.push(this._media_query());
                }
                
                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    mediaList.push(this._media_query());
                }
                
                return mediaList;
            },
            
            /*
             * Note: "expression" in the grammar maps to the _media_expression
             * method.
             
             */
            _media_query: function(){
                /*
                 * media_query
                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
                 *   | expression [ AND S* expression ]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    type        = null,
                    ident       = null,
                    token       = null,
                    expressions = [];
                    
                if (tokenStream.match(Tokens.IDENT)){
                    ident = tokenStream.token().value.toLowerCase();
                    
                    //since there's no custom tokens for these, need to manually check
                    if (ident != "only" && ident != "not"){
                        tokenStream.unget();
                        ident = null;
                    } else {
                        token = tokenStream.token();
                    }
                }
                                
                this._readWhitespace();
                
                if (tokenStream.peek() == Tokens.IDENT){
                    type = this._media_type();
                    if (token === null){
                        token = tokenStream.token();
                    }
                } else if (tokenStream.peek() == Tokens.LPAREN){
                    if (token === null){
                        token = tokenStream.LT(1);
                    }
                    expressions.push(this._media_expression());
                }                               
                
                if (type === null && expressions.length === 0){
                    return null;
                } else {                
                    this._readWhitespace();
                    while (tokenStream.match(Tokens.IDENT)){
                        if (tokenStream.token().value.toLowerCase() != "and"){
                            this._unexpectedToken(tokenStream.token());
                        }
                        
                        this._readWhitespace();
                        expressions.push(this._media_expression());
                    }
                }

                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
            },

            //CSS3 Media Queries
            _media_type: function(){
                /*
                 * media_type
                 *   : IDENT
                 *   ;
                 */
                return this._media_feature();           
            },

            /**
             * Note: in CSS3 Media Queries, this is called "expression".
             * Renamed here to avoid conflict with CSS3 Selectors
             * definition of "expression". Also note that "expr" in the
             * grammar now maps to "expression" from CSS3 selectors.
             * @method _media_expression
             * @private
             */
            _media_expression: function(){
                /*
                 * expression
                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*
                 *  ;
                 */
                var tokenStream = this._tokenStream,
                    feature     = null,
                    token,
                    expression  = null;
                
                tokenStream.mustMatch(Tokens.LPAREN);
                
                feature = this._media_feature();
                this._readWhitespace();
                
                if (tokenStream.match(Tokens.COLON)){
                    this._readWhitespace();
                    token = tokenStream.LT(1);
                    expression = this._expression();
                }
                
                tokenStream.mustMatch(Tokens.RPAREN);
                this._readWhitespace();

                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));            
            },

            //CSS3 Media Queries
            _media_feature: function(){
                /*
                 * media_feature
                 *   : IDENT
                 *   ;
                 */
                var tokenStream = this._tokenStream;
                    
                tokenStream.mustMatch(Tokens.IDENT);
                
                return SyntaxUnit.fromToken(tokenStream.token());            
            },
            
            //CSS3 Paged Media
            _page: function(){
                /*
                 * page:
                 *    PAGE_SYM S* IDENT? pseudo_page? S* 
                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 *    ;
                 */            
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    identifier  = null,
                    pseudoPage  = null;
                
                //look for @page
                tokenStream.mustMatch(Tokens.PAGE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                
                this._readWhitespace();
                
                if (tokenStream.match(Tokens.IDENT)){
                    identifier = tokenStream.token().value;

                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.
                    if (identifier.toLowerCase() === "auto"){
                        this._unexpectedToken(tokenStream.token());
                    }
                }                
                
                //see if there's a colon upcoming
                if (tokenStream.peek() == Tokens.COLON){
                    pseudoPage = this._pseudo_page();
                }
            
                this._readWhitespace();
                
                this.fire({
                    type:   "startpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });                   

                this._readDeclarations(true, true);                
                
                this.fire({
                    type:   "endpage",
                    id:     identifier,
                    pseudo: pseudoPage,
                    line:   line,
                    col:    col
                });             
            
            },
            
            //CSS3 Paged Media
            _margin: function(){
                /*
                 * margin :
                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*
                 *    ;
                 */
                var tokenStream = this._tokenStream,
                    line,
                    col,
                    marginSym   = this._margin_sym();

                if (marginSym){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                
                    this.fire({
                        type: "startpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });    
                    
                    this._readDeclarations(true);

                    this.fire({
                        type: "endpagemargin",
                        margin: marginSym,
                        line:   line,
                        col:    col
                    });    
                    return true;
                } else {
                    return false;
                }
            },

            //CSS3 Paged Media
            _margin_sym: function(){
            
                /*
                 * margin_sym :
                 *    TOPLEFTCORNER_SYM | 
                 *    TOPLEFT_SYM | 
                 *    TOPCENTER_SYM | 
                 *    TOPRIGHT_SYM | 
                 *    TOPRIGHTCORNER_SYM |
                 *    BOTTOMLEFTCORNER_SYM | 
                 *    BOTTOMLEFT_SYM | 
                 *    BOTTOMCENTER_SYM | 
                 *    BOTTOMRIGHT_SYM |
                 *    BOTTOMRIGHTCORNER_SYM |
                 *    LEFTTOP_SYM |
                 *    LEFTMIDDLE_SYM |
                 *    LEFTBOTTOM_SYM |
                 *    RIGHTTOP_SYM |
                 *    RIGHTMIDDLE_SYM |
                 *    RIGHTBOTTOM_SYM 
                 *    ;
                 */
            
                var tokenStream = this._tokenStream;
            
                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,
                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,
                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM, 
                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,
                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM, 
                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,
                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))
                {
                    return SyntaxUnit.fromToken(tokenStream.token());                
                } else {
                    return null;
                }
            
            },
            
            _pseudo_page: function(){
                /*
                 * pseudo_page
                 *   : ':' IDENT
                 *   ;    
                 */
        
                var tokenStream = this._tokenStream;
                
                tokenStream.mustMatch(Tokens.COLON);
                tokenStream.mustMatch(Tokens.IDENT);
                
                //TODO: CSS3 Paged Media says only "left", "center", and "right" are allowed
                
                return tokenStream.token().value;
            },
            
            _font_face: function(){
                /*
                 * font_face
                 *   : FONT_FACE_SYM S* 
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */     
                var tokenStream = this._tokenStream,
                    line,
                    col;
                
                //look for @page
                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
                
                this._readWhitespace();

                this.fire({
                    type:   "startfontface",
                    line:   line,
                    col:    col
                });                    
                
                this._readDeclarations(true);
                
                this.fire({
                    type:   "endfontface",
                    line:   line,
                    col:    col
                });              
            },

            _operator: function(inFunction){
            
                /*
                 * operator (outside function)
                 *  : '/' S* | ',' S* | /( empty )/
                 * operator (inside function)
                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/
                 *  ;
                 */    
                 
                var tokenStream = this._tokenStream,
                    token       = null;
                
                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||
                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){
                    token =  tokenStream.token();
                    this._readWhitespace();
                } 
                return token ? PropertyValuePart.fromToken(token) : null;
                
            },
            
            _combinator: function(){
            
                /*
                 * combinator
                 *  : PLUS S* | GREATER S* | TILDE S* | S+
                 *  ;
                 */    
                 
                var tokenStream = this._tokenStream,
                    value       = null,
                    token;
                
                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){                
                    token = tokenStream.token();
                    value = new Combinator(token.value, token.startLine, token.startCol);
                    this._readWhitespace();
                }
                
                return value;
            },
            
            _unary_operator: function(){
            
                /*
                 * unary_operator
                 *  : '-' | '+'
                 *  ;
                 */
                 
                var tokenStream = this._tokenStream;
                
                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){
                    return tokenStream.token().value;
                } else {
                    return null;
                }         
            },
            
            _property: function(){
            
                /*
                 * property
                 *   : IDENT S*
                 *   ;        
                 */
                 
                var tokenStream = this._tokenStream,
                    value       = null,
                    hack        = null,
                    tokenValue,
                    token,
                    line,
                    col;
                    
                //check for star hack - throws error if not allowed
                if (tokenStream.peek() == Tokens.STAR && this.options.starHack){
                    tokenStream.get();
                    token = tokenStream.token();
                    hack = token.value;
                    line = token.startLine;
                    col = token.startCol;
                }
                
                if(tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    tokenValue = token.value;
                    
                    //check for underscore hack - no error if not allowed because it's valid CSS syntax
                    if (tokenValue.charAt(0) == "_" && this.options.underscoreHack){
                        hack = "_";
                        tokenValue = tokenValue.substring(1);
                    }
                    
                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));
                    this._readWhitespace();
                }
                
                return value;
            },
        
            //Augmented with CSS3 Selectors
            _ruleset: function(){
                /*
                 * ruleset
                 *   : selectors_group
                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*
                 *   ;    
                 */    
                 
                var tokenStream = this._tokenStream,
                    tt,
                    selectors;


                /*
                 * Error Recovery: If even a single selector fails to parse,
                 * then the entire ruleset should be thrown away.
                 */
                try {
                    selectors = this._selectors_group();
                } catch (ex){
                    if (ex instanceof SyntaxError && !this.options.strict){
                    
                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });                          
                        
                        //skip over everything until closing brace
                        tt = tokenStream.advance([Tokens.RBRACE]);
                        if (tt == Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                        } else {
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }                        
                        
                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }                
                
                    //trigger parser to continue
                    return true;
                }
                
                //if it got here, all selectors parsed
                if (selectors){ 
                                    
                    this.fire({
                        type:       "startrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });                
                    
                    this._readDeclarations(true);                
                    
                    this.fire({
                        type:       "endrule",
                        selectors:  selectors,
                        line:       selectors[0].line,
                        col:        selectors[0].col
                    });  
                    
                }
                
                return selectors;
                
            },

            //CSS3 Selectors
            _selectors_group: function(){
            
                /*            
                 * selectors_group
                 *   : selector [ COMMA S* selector ]*
                 *   ;
                 */           
                var tokenStream = this._tokenStream,
                    selectors   = [],
                    selector;
                    
                selector = this._selector();
                if (selector !== null){
                
                    selectors.push(selector);
                    while(tokenStream.match(Tokens.COMMA)){
                        this._readWhitespace();
                        selector = this._selector();
                        if (selector !== null){
                            selectors.push(selector);
                        } else {
                            this._unexpectedToken(tokenStream.LT(1));
                        }
                    }
                }

                return selectors.length ? selectors : null;
            },
                
            //CSS3 Selectors
            _selector: function(){
                /*
                 * selector
                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*
                 *   ;    
                 */
                 
                var tokenStream = this._tokenStream,
                    selector    = [],
                    nextSelector = null,
                    combinator  = null,
                    ws          = null;
                
                //if there's no simple selector, then there's no selector
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null){
                    return null;
                }
                
                selector.push(nextSelector);
                
                do {
                    
                    //look for a combinator
                    combinator = this._combinator();
                    
                    if (combinator !== null){
                        selector.push(combinator);
                        nextSelector = this._simple_selector_sequence();
                        
                        //there must be a next selector
                        if (nextSelector === null){
                            this._unexpectedToken(tokenStream.LT(1));
                        } else {
                        
                            //nextSelector is an instance of SelectorPart
                            selector.push(nextSelector);
                        }
                    } else {
                        
                        //if there's not whitespace, we're done
                        if (this._readWhitespace()){           
        
                            //add whitespace separator
                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);
                            
                            //combinator is not required
                            combinator = this._combinator();
                            
                            //selector is required if there's a combinator
                            nextSelector = this._simple_selector_sequence();
                            if (nextSelector === null){                        
                                if (combinator !== null){
                                    this._unexpectedToken(tokenStream.LT(1));
                                }
                            } else {
                                
                                if (combinator !== null){
                                    selector.push(combinator);
                                } else {
                                    selector.push(ws);
                                }
                                
                                selector.push(nextSelector);
                            }     
                        } else {
                            break;
                        }               
                    
                    }
                } while(true);
                
                return new Selector(selector, selector[0].line, selector[0].col);
            },
            
            //CSS3 Selectors
            _simple_selector_sequence: function(){
                /*
                 * simple_selector_sequence
                 *   : [ type_selector | universal ]
                 *     [ HASH | class | attrib | pseudo | negation ]*
                 *   | [ HASH | class | attrib | pseudo | negation ]+
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                
                    //parts of a simple selector
                    elementName = null,
                    modifiers   = [],
                    
                    //complete selector text
                    selectorText= "",

                    //the different parts after the element name to search for
                    components  = [
                        //HASH
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;
                        },
                        this._class,
                        this._attrib,
                        this._pseudo,
                        this._negation
                    ],
                    i           = 0,
                    len         = components.length,
                    component   = null,
                    found       = false,
                    line,
                    col;
                    
                    
                //get starting line and column for the selector
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;
                                        
                elementName = this._type_selector();
                if (!elementName){
                    elementName = this._universal();
                }
                
                if (elementName !== null){
                    selectorText += elementName;
                }                
                
                while(true){

                    //whitespace means we're done
                    if (tokenStream.peek() === Tokens.S){
                        break;
                    }
                
                    //check for each component
                    while(i < len && component === null){
                        component = components[i++].call(this);
                    }
        
                    if (component === null){
                    
                        //we don't have a selector
                        if (selectorText === ""){
                            return null;
                        } else {
                            break;
                        }
                    } else {
                        i = 0;
                        modifiers.push(component);
                        selectorText += component.toString(); 
                        component = null;
                    }
                }

                 
                return selectorText !== "" ?
                        new SelectorPart(elementName, modifiers, selectorText, line, col) :
                        null;
            },            
            
            //CSS3 Selectors
            _type_selector: function(){
                /*
                 * type_selector
                 *   : [ namespace_prefix ]? element_name
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                    ns          = this._namespace_prefix(),
                    elementName = this._element_name();
                    
                if (!elementName){                    
                    /*
                     * Need to back out the namespace that was read due to both
                     * type_selector and universal reading namespace_prefix
                     * first. Kind of hacky, but only way I can figure out
                     * right now how to not change the grammar.
                     */
                    if (ns){
                        tokenStream.unget();
                        if (ns.length > 1){
                            tokenStream.unget();
                        }
                    }
                
                    return null;
                } else {     
                    if (ns){
                        elementName.text = ns + elementName.text;
                        elementName.col -= ns.length;
                    }
                    return elementName;
                }
            },
            
            //CSS3 Selectors
            _class: function(){
                /*
                 * class
                 *   : '.' IDENT
                 *   ;
                 */    
                 
                var tokenStream = this._tokenStream,
                    token;
                
                if (tokenStream.match(Tokens.DOT)){
                    tokenStream.mustMatch(Tokens.IDENT);    
                    token = tokenStream.token();
                    return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);        
                } else {
                    return null;
                }
        
            },
            
            //CSS3 Selectors
            _element_name: function(){
                /*
                 * element_name
                 *   : IDENT
                 *   ;
                 */    
                
                var tokenStream = this._tokenStream,
                    token;
                
                if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();
                    return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);        
                
                } else {
                    return null;
                }
            },
            
            //CSS3 Selectors
            _namespace_prefix: function(){
                /*            
                 * namespace_prefix
                 *   : [ IDENT | '*' ]? '|'
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    value       = "";
                    
                //verify that this is a namespace prefix
                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){
                        
                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){
                        value += tokenStream.token().value;
                    }
                    
                    tokenStream.mustMatch(Tokens.PIPE);
                    value += "|";
                    
                }
                
                return value.length ? value : null;                
            },
            
            //CSS3 Selectors
            _universal: function(){
                /*
                 * universal
                 *   : [ namespace_prefix ]? '*'
                 *   ;            
                 */
                var tokenStream = this._tokenStream,
                    value       = "",
                    ns;
                    
                ns = this._namespace_prefix();
                if(ns){
                    value += ns;
                }
                
                if(tokenStream.match(Tokens.STAR)){
                    value += "*";
                }
                
                return value.length ? value : null;
                
           },
            
            //CSS3 Selectors
            _attrib: function(){
                /*
                 * attrib
                 *   : '[' S* [ namespace_prefix ]? IDENT S*
                 *         [ [ PREFIXMATCH |
                 *             SUFFIXMATCH |
                 *             SUBSTRINGMATCH |
                 *             '=' |
                 *             INCLUDES |
                 *             DASHMATCH ] S* [ IDENT | STRING ] S*
                 *         ]? ']'
                 *   ;    
                 */
                 
                var tokenStream = this._tokenStream,
                    value       = null,
                    ns,
                    token;
                
                if (tokenStream.match(Tokens.LBRACKET)){
                    token = tokenStream.token();
                    value = token.value;
                    value += this._readWhitespace();
                    
                    ns = this._namespace_prefix();
                    
                    if (ns){
                        value += ns;
                    }
                                        
                    tokenStream.mustMatch(Tokens.IDENT);
                    value += tokenStream.token().value;                    
                    value += this._readWhitespace();
                    
                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,
                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){
                    
                        value += tokenStream.token().value;                    
                        value += this._readWhitespace();
                        
                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                        value += tokenStream.token().value;                    
                        value += this._readWhitespace();
                    }
                    
                    tokenStream.mustMatch(Tokens.RBRACKET);
                                        
                    return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
                } else {
                    return null;
                }
            },
            
            //CSS3 Selectors
            _pseudo: function(){
            
                /*
                 * pseudo
                 *   : ':' ':'? [ IDENT | functional_pseudo ]
                 *   ;    
                 */   
            
                var tokenStream = this._tokenStream,
                    pseudo      = null,
                    colons      = ":",
                    line,
                    col;
                
                if (tokenStream.match(Tokens.COLON)){
                
                    if (tokenStream.match(Tokens.COLON)){
                        colons += ":";
                    }
                
                    if (tokenStream.match(Tokens.IDENT)){
                        pseudo = tokenStream.token().value;
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol - colons.length;
                    } else if (tokenStream.peek() == Tokens.FUNCTION){
                        line = tokenStream.LT(1).startLine;
                        col = tokenStream.LT(1).startCol - colons.length;
                        pseudo = this._functional_pseudo();
                    }
                    
                    if (pseudo){
                        pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
                    }
                }
        
                return pseudo;
            },
            
            //CSS3 Selectors
            _functional_pseudo: function(){
                /*
                 * functional_pseudo
                 *   : FUNCTION S* expression ')'
                 *   ;
                */            
                
                var tokenStream = this._tokenStream,
                    value = null;
                
                if(tokenStream.match(Tokens.FUNCTION)){
                    value = tokenStream.token().value;
                    value += this._readWhitespace();
                    value += this._expression();
                    tokenStream.mustMatch(Tokens.RPAREN);
                    value += ")";
                }
                
                return value;
            },
            
            //CSS3 Selectors
            _expression: function(){
                /*
                 * expression
                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                    value       = "";
                    
                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,
                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,
                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,
                        Tokens.RESOLUTION, Tokens.SLASH])){
                    
                    value += tokenStream.token().value;
                    value += this._readWhitespace();                        
                }
                
                return value.length ? value : null;
                
            },

            //CSS3 Selectors
            _negation: function(){
                /*            
                 * negation
                 *   : NOT S* negation_arg S* ')'
                 *   ;
                 */

                var tokenStream = this._tokenStream,
                    line,
                    col,
                    value       = "",
                    arg,
                    subpart     = null;
                    
                if (tokenStream.match(Tokens.NOT)){
                    value = tokenStream.token().value;
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                    value += this._readWhitespace();
                    arg = this._negation_arg();
                    value += arg;
                    value += this._readWhitespace();
                    tokenStream.match(Tokens.RPAREN);
                    value += tokenStream.token().value;
                    
                    subpart = new SelectorSubPart(value, "not", line, col);
                    subpart.args.push(arg);
                }
                
                return subpart;
            },
            
            //CSS3 Selectors
            _negation_arg: function(){            
                /*
                 * negation_arg
                 *   : type_selector | universal | HASH | class | attrib | pseudo
                 *   ;            
                 */           
                 
                var tokenStream = this._tokenStream,
                    args        = [
                        this._type_selector,
                        this._universal,
                        function(){
                            return tokenStream.match(Tokens.HASH) ?
                                    new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) :
                                    null;                        
                        },
                        this._class,
                        this._attrib,
                        this._pseudo                    
                    ],
                    arg         = null,
                    i           = 0,
                    len         = args.length,
                    elementName,
                    line,
                    col,
                    part;
                    
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol;
                
                while(i < len && arg === null){
                    
                    arg = args[i].call(this);
                    i++;
                }
                
                //must be a negation arg
                if (arg === null){
                    this._unexpectedToken(tokenStream.LT(1));
                }
 
                //it's an element name
                if (arg.type == "elementName"){
                    part = new SelectorPart(arg, [], arg.toString(), line, col);
                } else {
                    part = new SelectorPart(null, [arg], arg.toString(), line, col);
                }
                
                return part;                
            },
            
            _declaration: function(){
            
                /*
                 * declaration
                 *   : property ':' S* expr prio?
                 *   | /( empty )/
                 *   ;     
                 */    
            
                var tokenStream = this._tokenStream,
                    property    = null,
                    expr        = null,
                    prio        = null,
                    error       = null,
                    invalid     = null,
                    propertyName= "";
                
                property = this._property();
                if (property !== null){

                    tokenStream.mustMatch(Tokens.COLON);
                    this._readWhitespace();
                    
                    expr = this._expr();
                    
                    //if there's no parts for the value, it's an error
                    if (!expr || expr.length === 0){
                        this._unexpectedToken(tokenStream.LT(1));
                    }
                    
                    prio = this._prio();
                    
                    /*
                     * If hacks should be allowed, then only check the root
                     * property. If hacks should not be allowed, treat
                     * _property or *property as invalid properties.
                     */
                    propertyName = property.toString();
                    if (this.options.starHack && property.hack == "*" ||
                            this.options.underscoreHack && property.hack == "_") {
                         
                        propertyName = property.text;
                    }
                    
                    try {
                        this._validateProperty(propertyName, expr);
                    } catch (ex) {
                        invalid = ex;
                    }
                    
                    this.fire({
                        type:       "property",
                        property:   property,
                        value:      expr,
                        important:  prio,
                        line:       property.line,
                        col:        property.col,
                        invalid:    invalid
                    });                      
                    
                    return true;
                } else {
                    return false;
                }
            },
            
            _prio: function(){
                /*
                 * prio
                 *   : IMPORTANT_SYM S*
                 *   ;    
                 */
                 
                var tokenStream = this._tokenStream,
                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);
                    
                this._readWhitespace();
                return result;
            },
            
            _expr: function(inFunction){
                /*
                 * expr
                 *   : term [ operator term ]*
                 *   ;
                 */
        
                var tokenStream = this._tokenStream,
                    values      = [],
					//valueParts	= [],
                    value       = null,
                    operator    = null;
                    
                value = this._term();
                if (value !== null){
                
                    values.push(value);
                    
                    do {
                        operator = this._operator(inFunction);

                        //if there's an operator, keep building up the value parts
                        if (operator){
                            values.push(operator);
                        } /*else {
                            //if there's not an operator, you have a full value
							values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
							valueParts = [];
						}*/
                        
                        value = this._term();
                        
                        if (value === null){
                            break;
                        } else {
                            values.push(value);
                        }
                    } while(true);
                }
				
				//cleanup
                /*if (valueParts.length){
                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));
                }*/
        
                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
            },
            
            _term: function(){                       
            
                /*
                 * term
                 *   : unary_operator?
                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |
                 *       TIME S* | FREQ S* | function | ie_function ]
                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor
                 *   ;
                 */    
        
                var tokenStream = this._tokenStream,
                    unary       = null,
                    value       = null,
                    token,
                    line,
                    col;
                    
                //returns the operator or null
                unary = this._unary_operator();
                if (unary !== null){
                    line = tokenStream.token().startLine;
                    col = tokenStream.token().startCol;
                }                
               
                //exception for IE filters
                if (tokenStream.peek() == Tokens.IE_FUNCTION && this.options.ieFilters){
                
                    value = this._ie_function();
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                
                //see if there's a simple match
                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,
                        Tokens.ANGLE, Tokens.TIME,
                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){
                 
                    value = tokenStream.token().value;
                    if (unary === null){
                        line = tokenStream.token().startLine;
                        col = tokenStream.token().startCol;
                    }
                    this._readWhitespace();
                } else {
                
                    //see if it's a color
                    token = this._hexcolor();
                    if (token === null){
                    
                        //if there's no unary, get the start of the next token for line/col info
                        if (unary === null){
                            line = tokenStream.LT(1).startLine;
                            col = tokenStream.LT(1).startCol;
                        }                    
                    
                        //has to be a function
                        if (value === null){
                            
                            /*
                             * This checks for alpha(opacity=0) style of IE
                             * functions. IE_FUNCTION only presents progid: style.
                             */
                            if (tokenStream.LA(3) == Tokens.EQUALS && this.options.ieFilters){
                                value = this._ie_function();
                            } else {
                                value = this._function();
                            }
                        }

                        /*if (value === null){
                            return null;
                            //throw new Error("Expected identifier at line " + tokenStream.token().startLine + ", character " +  tokenStream.token().startCol + ".");
                        }*/
                    
                    } else {
                        value = token.value;
                        if (unary === null){
                            line = token.startLine;
                            col = token.startCol;
                        }                    
                    }
                
                }                
                
                return value !== null ?
                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :
                        null;
        
            },
            
            _function: function(){
            
                /*
                 * function
                 *   : FUNCTION S* expr ')' S*
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;
                    
                if (tokenStream.match(Tokens.FUNCTION)){
                    functionText = tokenStream.token().value;
                    this._readWhitespace();
                    expr = this._expr(true);
                    functionText += expr;
                    
                    //START: Horrible hack in case it's an IE filter
                    if (this.options.ieFilters && tokenStream.peek() == Tokens.EQUALS){
                        do {
                        
                            if (this._readWhitespace()){
                                functionText += tokenStream.token().value;
                            }
                            
                            //might be second time in the loop
                            if (tokenStream.LA(0) == Tokens.COMMA){
                                functionText += tokenStream.token().value;
                            }
                        
                            tokenStream.match(Tokens.IDENT);
                            functionText += tokenStream.token().value;
                            
                            tokenStream.match(Tokens.EQUALS);
                            functionText += tokenStream.token().value;
                            
                            //functionText += this._term();
                            lt = tokenStream.peek();
                            while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){
                                tokenStream.get();
                                functionText += tokenStream.token().value;
                                lt = tokenStream.peek();
                            }
                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));
                    }

                    //END: Horrible Hack
                    
                    tokenStream.match(Tokens.RPAREN);    
                    functionText += ")";
                    this._readWhitespace();
                }                
                
                return functionText;
            }, 
            
            _ie_function: function(){
            
                /* (My own extension)
                 * ie_function
                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                    functionText = null,
                    expr        = null,
                    lt;
                    
                //IE function can begin like a regular function, too
                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){
                    functionText = tokenStream.token().value;
                    
                    do {
                    
                        if (this._readWhitespace()){
                            functionText += tokenStream.token().value;
                        }
                        
                        //might be second time in the loop
                        if (tokenStream.LA(0) == Tokens.COMMA){
                            functionText += tokenStream.token().value;
                        }
                    
                        tokenStream.match(Tokens.IDENT);
                        functionText += tokenStream.token().value;
                        
                        tokenStream.match(Tokens.EQUALS);
                        functionText += tokenStream.token().value;
                        
                        //functionText += this._term();
                        lt = tokenStream.peek();
                        while(lt != Tokens.COMMA && lt != Tokens.S && lt != Tokens.RPAREN){
                            tokenStream.get();
                            functionText += tokenStream.token().value;
                            lt = tokenStream.peek();
                        }
                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));                    
                    
                    tokenStream.match(Tokens.RPAREN);    
                    functionText += ")";
                    this._readWhitespace();
                }                
                
                return functionText;
            }, 
            
            _hexcolor: function(){
                /*
                 * There is a constraint on the color that it must
                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])
                 * after the "#"; e.g., "#000" is OK, but "#abcd" is not.
                 *
                 * hexcolor
                 *   : HASH S*
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                    token = null,
                    color;
                    
                if(tokenStream.match(Tokens.HASH)){
                
                    //need to do some validation here
                    
                    token = tokenStream.token();
                    color = token.value;
                    if (!/#[a-f0-9]{3,6}/i.test(color)){
                        throw new SyntaxError("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
                    }
                    this._readWhitespace();
                }
                
                return token;
            },
            
            //-----------------------------------------------------------------
            // Animations methods
            //-----------------------------------------------------------------
            
            _keyframes: function(){
            
                /*
                 * keyframes:
                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    tt,
                    name,
                    prefix = "";            
                    
                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
                token = tokenStream.token();
                if (/^@\-([^\-]+)\-/.test(token.value)) {
                    prefix = RegExp.$1;
                }
                
                this._readWhitespace();
                name = this._keyframe_name();
                
                this._readWhitespace();
                tokenStream.mustMatch(Tokens.LBRACE);
                    
                this.fire({
                    type:   "startkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });                
                
                this._readWhitespace();
                tt = tokenStream.peek();
                
                //check for key
                while(tt == Tokens.IDENT || tt == Tokens.PERCENTAGE) {
                    this._keyframe_rule();
                    this._readWhitespace();
                    tt = tokenStream.peek();
                }           
                
                this.fire({
                    type:   "endkeyframes",
                    name:   name,
                    prefix: prefix,
                    line:   token.startLine,
                    col:    token.startCol
                });                      
                    
                this._readWhitespace();
                tokenStream.mustMatch(Tokens.RBRACE);                    
                
            },
            
            _keyframe_name: function(){
            
                /*
                 * keyframe_name:
                 *   : IDENT
                 *   | STRING
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token;

                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                return SyntaxUnit.fromToken(tokenStream.token());            
            },
            
            _keyframe_rule: function(){
            
                /*
                 * keyframe_rule:
                 *   : key_list S* 
                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    keyList = this._key_list();
                                    
                this.fire({
                    type:   "startkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });                
                
                this._readDeclarations(true);                
                
                this.fire({
                    type:   "endkeyframerule",
                    keys:   keyList,
                    line:   keyList[0].line,
                    col:    keyList[0].col
                });  
                
            },
            
            _key_list: function(){
            
                /*
                 * key_list:
                 *   : key [ S* ',' S* key]*
                 *   ;
                 */
                var tokenStream = this._tokenStream,
                    token,
                    key,
                    keyList = [];
                    
                //must be least one key
                keyList.push(this._key());
                    
                this._readWhitespace();
                    
                while(tokenStream.match(Tokens.COMMA)){
                    this._readWhitespace();
                    keyList.push(this._key());
                    this._readWhitespace();
                }

                return keyList;
            },
                        
            _key: function(){
                /*
                 * There is a restriction that IDENT can be only "from" or "to".
                 *
                 * key
                 *   : PERCENTAGE
                 *   | IDENT
                 *   ;
                 */
                 
                var tokenStream = this._tokenStream,
                    token;
                    
                if (tokenStream.match(Tokens.PERCENTAGE)){
                    return SyntaxUnit.fromToken(tokenStream.token());
                } else if (tokenStream.match(Tokens.IDENT)){
                    token = tokenStream.token();                    
                    
                    if (/from|to/i.test(token.value)){
                        return SyntaxUnit.fromToken(token);
                    }
                    
                    tokenStream.unget();
                }
                
                //if it gets here, there wasn't a valid token, so time to explode
                this._unexpectedToken(tokenStream.LT(1));
            },
            
            //-----------------------------------------------------------------
            // Helper methods
            //-----------------------------------------------------------------
            
            /**
             * Not part of CSS grammar, but useful for skipping over
             * combination of white space and HTML-style comments.
             * @return {void}
             * @method _skipCruft
             * @private
             */
            _skipCruft: function(){
                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){
                    //noop
                }
            },

            /**
             * Not part of CSS grammar, but this pattern occurs frequently
             * in the official CSS grammar. Split out here to eliminate
             * duplicate code.
             * @param {Boolean} checkStart Indicates if the rule should check
             *      for the left brace at the beginning.
             * @param {Boolean} readMargins Indicates if the rule should check
             *      for margin patterns.
             * @return {void}
             * @method _readDeclarations
             * @private
             */
            _readDeclarations: function(checkStart, readMargins){
                /*
                 * Reads the pattern
                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*
                 * or
                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*
                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.
                 * A semicolon is only necessary following a delcaration is there's another declaration
                 * or margin afterwards. 
                 */
                var tokenStream = this._tokenStream,
                    tt;
                       

                this._readWhitespace();
                
                if (checkStart){
                    tokenStream.mustMatch(Tokens.LBRACE);            
                }
                
                this._readWhitespace();

                try {
                    
                    while(true){
                    
                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){
                            //noop
                        } else if (this._declaration()){
                            if (!tokenStream.match(Tokens.SEMICOLON)){
                                break;
                            }
                        } else {
                            break;
                        }
                    
                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){
                        //    break;
                        //}
                        this._readWhitespace();
                    }
                    
                    tokenStream.mustMatch(Tokens.RBRACE);
                    this._readWhitespace();
                    
                } catch (ex) {
                    if (ex instanceof SyntaxError && !this.options.strict){
                    
                        //fire error event
                        this.fire({
                            type:       "error",
                            error:      ex,
                            message:    ex.message,
                            line:       ex.line,
                            col:        ex.col
                        });                          
                        
                        //see if there's another declaration
                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                        if (tt == Tokens.SEMICOLON){
                            //if there's a semicolon, then there might be another declaration
                            this._readDeclarations(false, readMargins);                            
                        } else if (tt != Tokens.RBRACE){
                            //if there's a right brace, the rule is finished so don't do anything
                            //otherwise, rethrow the error because it wasn't handled properly
                            throw ex;
                        }                        
                        
                    } else {
                        //not a syntax error, rethrow it
                        throw ex;
                    }
                }    
            
            },      
            
            /**
             * In some cases, you can end up with two white space tokens in a
             * row. Instead of making a change in every function that looks for
             * white space, this function is used to match as much white space
             * as necessary.
             * @method _readWhitespace
             * @return {String} The white space if found, empty string if not.
             * @private
             */
            _readWhitespace: function(){
            
                var tokenStream = this._tokenStream,
                    ws = "";
                    
                while(tokenStream.match(Tokens.S)){
                    ws += tokenStream.token().value;
                }
                
                return ws;
            },
          

            /**
             * Throws an error when an unexpected token is found.
             * @param {Object} token The token that was found.
             * @method _unexpectedToken
             * @return {void}
             * @private
             */
            _unexpectedToken: function(token){
                throw new SyntaxError("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
            },
            
            /**
             * Helper method used for parsing subparts of a style sheet.
             * @return {void}
             * @method _verifyEnd
             * @private
             */
            _verifyEnd: function(){
                if (this._tokenStream.LA(1) != Tokens.EOF){
                    this._unexpectedToken(this._tokenStream.LT(1));
                }            
            },
            
            //-----------------------------------------------------------------
            // Validation methods
            //-----------------------------------------------------------------
            _validateProperty: function(property, value){
                Validation.validate(property, value);
            },
            
            //-----------------------------------------------------------------
            // Parsing methods
            //-----------------------------------------------------------------
            
            parse: function(input){    
                this._tokenStream = new TokenStream(input, Tokens);
                this._stylesheet();
            },
            
            parseStyleSheet: function(input){
                //just passthrough
                return this.parse(input);
            },
            
            parseMediaQuery: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                var result = this._media_query();
                
                //if there's anything more, then it's an invalid selector
                this._verifyEnd();
                
                //otherwise return result
                return result;            
            },
            
            /**
             * Parses a property value (everything after the semicolon).
             * @return {parserlib.css.PropertyValue} The property value.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parserPropertyValue
             */             
            parsePropertyValue: function(input){
            
                this._tokenStream = new TokenStream(input, Tokens);
                this._readWhitespace();
                
                var result = this._expr();
                
                //okay to have a trailing white space
                this._readWhitespace();
                
                //if there's anything more, then it's an invalid selector
                this._verifyEnd();
                
                //otherwise return result
                return result;
            },
            
            /**
             * Parses a complete CSS rule, including selectors and
             * properties.
             * @param {String} input The text to parser.
             * @return {Boolean} True if the parse completed successfully, false if not.
             * @method parseRule
             */
            parseRule: function(input){
                this._tokenStream = new TokenStream(input, Tokens);
                
                //skip any leading white space
                this._readWhitespace();
                
                var result = this._ruleset();
                
                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();
                
                //otherwise return result
                return result;            
            },
            
            /**
             * Parses a single CSS selector (no comma)
             * @param {String} input The text to parse as a CSS selector.
             * @return {Selector} An object representing the selector.
             * @throws parserlib.util.SyntaxError If an unexpected token is found.
             * @method parseSelector
             */
            parseSelector: function(input){
            
                this._tokenStream = new TokenStream(input, Tokens);
                
                //skip any leading white space
                this._readWhitespace();
                
                var result = this._selector();
                
                //skip any trailing white space
                this._readWhitespace();

                //if there's anything more, then it's an invalid selector
                this._verifyEnd();
                
                //otherwise return result
                return result;
            },

            /**
             * Parses an HTML style attribute: a set of CSS declarations 
             * separated by semicolons.
             * @param {String} input The text to parse as a style attribute
             * @return {void} 
             * @method parseStyleAttribute
             */
            parseStyleAttribute: function(input){
                input += "}"; // for error recovery in _readDeclarations()
                this._tokenStream = new TokenStream(input, Tokens);
                this._readDeclarations();
            }
        };
        
    //copy over onto prototype
    for (prop in additions){
        if (additions.hasOwnProperty(prop)){
            proto[prop] = additions[prop];
        }
    }   
    
    return proto;
}();


/*
nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;
*/
/*global Validation, ValidationTypes, ValidationError*/
var Properties = {

    //A
    "alignment-adjust"              : "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
    "alignment-baseline"            : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "animation"                     : 1,
    "animation-delay"               : { multi: "<time>", comma: true },
    "animation-direction"           : { multi: "normal | alternate", comma: true },
    "animation-duration"            : { multi: "<time>", comma: true },
    "animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "animation-name"                : { multi: "none | <ident>", comma: true },
    "animation-play-state"          : { multi: "running | paused", comma: true },
    "animation-timing-function"     : 1,
    
    //vendor prefixed
    "-moz-animation-delay"               : { multi: "<time>", comma: true },
    "-moz-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-moz-animation-duration"            : { multi: "<time>", comma: true },
    "-moz-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-moz-animation-name"                : { multi: "none | <ident>", comma: true },
    "-moz-animation-play-state"          : { multi: "running | paused", comma: true },
    
    "-ms-animation-delay"               : { multi: "<time>", comma: true },
    "-ms-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-ms-animation-duration"            : { multi: "<time>", comma: true },
    "-ms-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-ms-animation-name"                : { multi: "none | <ident>", comma: true },
    "-ms-animation-play-state"          : { multi: "running | paused", comma: true },
    
    "-webkit-animation-delay"               : { multi: "<time>", comma: true },
    "-webkit-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-webkit-animation-duration"            : { multi: "<time>", comma: true },
    "-webkit-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-webkit-animation-name"                : { multi: "none | <ident>", comma: true },
    "-webkit-animation-play-state"          : { multi: "running | paused", comma: true },
    
    "-o-animation-delay"               : { multi: "<time>", comma: true },
    "-o-animation-direction"           : { multi: "normal | alternate", comma: true },
    "-o-animation-duration"            : { multi: "<time>", comma: true },
    "-o-animation-iteration-count"     : { multi: "<number> | infinite", comma: true },
    "-o-animation-name"                : { multi: "none | <ident>", comma: true },
    "-o-animation-play-state"          : { multi: "running | paused", comma: true },        
    
    "appearance"                    : "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
    "azimuth"                       : function (expression) {
        var simple      = "<angle> | leftwards | rightwards | inherit",
            direction   = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side",
            behind      = false,
            valid       = false,
            part;
        
        if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
                behind = true;
                valid = true;
            }
            
            if (ValidationTypes.isAny(expression, direction)) {
                valid = true;
                if (!behind) {
                    ValidationTypes.isAny(expression, "behind");
                }
            }
        }
        
        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
        }        
    },
    
    //B
    "backface-visibility"           : "visible | hidden",
    "background"                    : 1,
    "background-attachment"         : { multi: "<attachment>", comma: true },
    "background-clip"               : { multi: "<box>", comma: true },
    "background-color"              : "<color> | inherit",
    "background-image"              : { multi: "<bg-image>", comma: true },
    "background-origin"             : { multi: "<box>", comma: true },
    "background-position"           : { multi: "<bg-position>", comma: true },
    "background-repeat"             : { multi: "<repeat-style>" },
    "background-size"               : { multi: "<bg-size>", comma: true },
    "baseline-shift"                : "baseline | sub | super | <percentage> | <length>",
    "behavior"                      : 1,
    "binding"                       : 1,
    "bleed"                         : "<length>",
    "bookmark-label"                : "<content> | <attr> | <string>",
    "bookmark-level"                : "none | <integer>",
    "bookmark-state"                : "open | closed",
    "bookmark-target"               : "none | <uri> | <attr>",
    "border"                        : "<border-width> || <border-style> || <color>",
    "border-bottom"                 : "<border-width> || <border-style> || <color>",
    "border-bottom-color"           : "<color>",
    "border-bottom-left-radius"     :  "<x-one-radius>",
    "border-bottom-right-radius"    :  "<x-one-radius>",
    "border-bottom-style"           : "<border-style>",
    "border-bottom-width"           : "<border-width>",
    "border-collapse"               : "collapse | separate | inherit",
    "border-color"                  : { multi: "<color> | inherit", max: 4 },
    "border-image"                  : 1,
    "border-image-outset"           : { multi: "<length> | <number>", max: 4 },
    "border-image-repeat"           : { multi: "stretch | repeat | round", max: 2 },
    "border-image-slice"            : function(expression) {
        
        var valid   = false,
            numeric = "<number> | <percentage>",
            fill    = false,
            count   = 0,
            max     = 4,
            part;
        
        if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
        }
        
        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
                break;
            }
            count++;
        }
        
        
        if (!fill) {
            ValidationTypes.isAny(expression, "fill");
        } else {
            valid = true;
        }
        
        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
        }         
    },
    "border-image-source"           : "<image> | none",
    "border-image-width"            : { multi: "<length> | <percentage> | <number> | auto", max: 4 },
    "border-left"                   : "<border-width> || <border-style> || <color>",
    "border-left-color"             : "<color> | inherit",
    "border-left-style"             : "<border-style>",
    "border-left-width"             : "<border-width>",
    "border-radius"                 : function(expression) {
        
        var valid   = false,
            numeric = "<length> | <percentage>",
            slash   = false,
            fill    = false,
            count   = 0,
            max     = 8,
            part;

        while (expression.hasNext() && count < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
            
                if (expression.peek() == "/" && count > 0 && !slash) {
                    slash = true;
                    max = count + 5;
                    expression.next();
                } else {
                    break;
                }
            }
            count++;
        }
        
        if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
        }         
    },
    "border-right"                  : "<border-width> || <border-style> || <color>",
    "border-right-color"            : "<color> | inherit",
    "border-right-style"            : "<border-style>",
    "border-right-width"            : "<border-width>",
    "border-spacing"                : { multi: "<length> | inherit", max: 2 },
    "border-style"                  : { multi: "<border-style>", max: 4 },
    "border-top"                    : "<border-width> || <border-style> || <color>",
    "border-top-color"              : "<color> | inherit",
    "border-top-left-radius"        : "<x-one-radius>",
    "border-top-right-radius"       : "<x-one-radius>",
    "border-top-style"              : "<border-style>",
    "border-top-width"              : "<border-width>",
    "border-width"                  : { multi: "<border-width>", max: 4 },
    "bottom"                        : "<margin-width> | inherit", 
    "box-align"                     : "start | end | center | baseline | stretch",        //http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/
    "box-decoration-break"          : "slice |clone",
    "box-direction"                 : "normal | reverse | inherit",
    "box-flex"                      : "<number>",
    "box-flex-group"                : "<integer>",
    "box-lines"                     : "single | multiple",
    "box-ordinal-group"             : "<integer>",
    "box-orient"                    : "horizontal | vertical | inline-axis | block-axis | inherit",
    "box-pack"                      : "start | end | center | justify",
    "box-shadow"                    : function (expression) {
        var result      = false,
            part;

        if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);                       
        } else {
            if (expression.hasNext()) {
                part = expression.next();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }   
        }
    },
    "box-sizing"                    : "content-box | border-box | inherit",
    "break-after"                   : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-before"                  : "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
    "break-inside"                  : "auto | avoid | avoid-page | avoid-column",
    
    //C
    "caption-side"                  : "top | bottom | inherit",
    "clear"                         : "none | right | left | both | inherit",
    "clip"                          : 1,
    "color"                         : "<color> | inherit",
    "color-profile"                 : 1,
    "column-count"                  : "<integer> | auto",                      //http://www.w3.org/TR/css3-multicol/
    "column-fill"                   : "auto | balance",
    "column-gap"                    : "<length> | normal",
    "column-rule"                   : "<border-width> || <border-style> || <color>",
    "column-rule-color"             : "<color>",
    "column-rule-style"             : "<border-style>",
    "column-rule-width"             : "<border-width>",
    "column-span"                   : "none | all",
    "column-width"                  : "<length> | auto",
    "columns"                       : 1,
    "content"                       : 1,
    "counter-increment"             : 1,
    "counter-reset"                 : 1,
    "crop"                          : "<shape> | auto",
    "cue"                           : "cue-after | cue-before | inherit",
    "cue-after"                     : 1,
    "cue-before"                    : 1,
    "cursor"                        : 1,
    
    //D
    "direction"                     : "ltr | rtl | inherit",
    "display"                       : "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | box | inline-box | grid | inline-grid | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker",
    "dominant-baseline"             : 1,
    "drop-initial-after-adjust"     : "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
    "drop-initial-after-align"      : "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-before-adjust"    : "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
    "drop-initial-before-align"     : "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
    "drop-initial-size"             : "auto | line | <length> | <percentage>",
    "drop-initial-value"            : "initial | <integer>",
    
    //E
    "elevation"                     : "<angle> | below | level | above | higher | lower | inherit",
    "empty-cells"                   : "show | hide | inherit",
    
    //F
    "filter"                        : 1,
    "fit"                           : "fill | hidden | meet | slice",
    "fit-position"                  : 1,
    "float"                         : "left | right | none | inherit",    
    "float-offset"                  : 1,
    "font"                          : 1,
    "font-family"                   : 1,
    "font-size"                     : "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
    "font-size-adjust"              : "<number> | none | inherit",
    "font-stretch"                  : "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
    "font-style"                    : "normal | italic | oblique | inherit",
    "font-variant"                  : "normal | small-caps | inherit",
    "font-weight"                   : "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",
    
    //G
    "grid-cell-stacking"            : "columns | rows | layer",
    "grid-column"                   : 1,
    "grid-columns"                  : 1,
    "grid-column-align"             : "start | end | center | stretch",
    "grid-column-sizing"            : 1,
    "grid-column-span"              : "<integer>",
    "grid-flow"                     : "none | rows | columns",
    "grid-layer"                    : "<integer>",
    "grid-row"                      : 1,
    "grid-rows"                     : 1,
    "grid-row-align"                : "start | end | center | stretch",
    "grid-row-span"                 : "<integer>",
    "grid-row-sizing"               : 1,
    
    //H
    "hanging-punctuation"           : 1,
    "height"                        : "<margin-width> | inherit",
    "hyphenate-after"               : "<integer> | auto",
    "hyphenate-before"              : "<integer> | auto",
    "hyphenate-character"           : "<string> | auto",
    "hyphenate-lines"               : "no-limit | <integer>",
    "hyphenate-resource"            : 1,
    "hyphens"                       : "none | manual | auto",
    
    //I
    "icon"                          : 1,
    "image-orientation"             : "angle | auto",
    "image-rendering"               : 1,
    "image-resolution"              : 1,
    "inline-box-align"              : "initial | last | <integer>",
    
    //L
    "left"                          : "<margin-width> | inherit",
    "letter-spacing"                : "<length> | normal | inherit",
    "line-height"                   : "<number> | <length> | <percentage> | normal | inherit",
    "line-break"                    : "auto | loose | normal | strict",
    "line-stacking"                 : 1,
    "line-stacking-ruby"            : "exclude-ruby | include-ruby",
    "line-stacking-shift"           : "consider-shifts | disregard-shifts",
    "line-stacking-strategy"        : "inline-line-height | block-line-height | max-height | grid-height",
    "list-style"                    : 1,
    "list-style-image"              : "<uri> | none | inherit",
    "list-style-position"           : "inside | outside | inherit",
    "list-style-type"               : "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",
    
    //M
    "margin"                        : { multi: "<margin-width> | inherit", max: 4 },
    "margin-bottom"                 : "<margin-width> | inherit",
    "margin-left"                   : "<margin-width> | inherit",
    "margin-right"                  : "<margin-width> | inherit",
    "margin-top"                    : "<margin-width> | inherit",
    "mark"                          : 1,
    "mark-after"                    : 1,
    "mark-before"                   : 1,
    "marks"                         : 1,
    "marquee-direction"             : 1,
    "marquee-play-count"            : 1,
    "marquee-speed"                 : 1,
    "marquee-style"                 : 1,
    "max-height"                    : "<length> | <percentage> | none | inherit",
    "max-width"                     : "<length> | <percentage> | none | inherit",
    "min-height"                    : "<length> | <percentage> | inherit",
    "min-width"                     : "<length> | <percentage> | inherit",
    "move-to"                       : 1,
    
    //N
    "nav-down"                      : 1,
    "nav-index"                     : 1,
    "nav-left"                      : 1,
    "nav-right"                     : 1,
    "nav-up"                        : 1,
    
    //O
    "opacity"                       : "<number> | inherit",
    "orphans"                       : "<integer> | inherit",
    "outline"                       : 1,
    "outline-color"                 : "<color> | invert | inherit",
    "outline-offset"                : 1,
    "outline-style"                 : "<border-style> | inherit",
    "outline-width"                 : "<border-width> | inherit",
    "overflow"                      : "visible | hidden | scroll | auto | inherit",
    "overflow-style"                : 1,
    "overflow-x"                    : 1,
    "overflow-y"                    : 1,
    
    //P
    "padding"                       : { multi: "<padding-width> | inherit", max: 4 },
    "padding-bottom"                : "<padding-width> | inherit",
    "padding-left"                  : "<padding-width> | inherit",
    "padding-right"                 : "<padding-width> | inherit",
    "padding-top"                   : "<padding-width> | inherit",
    "page"                          : 1,
    "page-break-after"              : "auto | always | avoid | left | right | inherit",
    "page-break-before"             : "auto | always | avoid | left | right | inherit",
    "page-break-inside"             : "auto | avoid | inherit",
    "page-policy"                   : 1,
    "pause"                         : 1,
    "pause-after"                   : 1,
    "pause-before"                  : 1,
    "perspective"                   : 1,
    "perspective-origin"            : 1,
    "phonemes"                      : 1,
    "pitch"                         : 1,
    "pitch-range"                   : 1,
    "play-during"                   : 1,
    "pointer-events"                : "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
    "position"                      : "static | relative | absolute | fixed | inherit",
    "presentation-level"            : 1,
    "punctuation-trim"              : 1,
    
    //Q
    "quotes"                        : 1,
    
    //R
    "rendering-intent"              : 1,
    "resize"                        : 1,
    "rest"                          : 1,
    "rest-after"                    : 1,
    "rest-before"                   : 1,
    "richness"                      : 1,
    "right"                         : "<margin-width> | inherit",
    "rotation"                      : 1,
    "rotation-point"                : 1,
    "ruby-align"                    : 1,
    "ruby-overhang"                 : 1,
    "ruby-position"                 : 1,
    "ruby-span"                     : 1,
    
    //S
    "size"                          : 1,
    "speak"                         : "normal | none | spell-out | inherit",
    "speak-header"                  : "once | always | inherit",
    "speak-numeral"                 : "digits | continuous | inherit",
    "speak-punctuation"             : "code | none | inherit",
    "speech-rate"                   : 1,
    "src"                           : 1,
    "stress"                        : 1,
    "string-set"                    : 1,
    
    "table-layout"                  : "auto | fixed | inherit",
    "tab-size"                      : "<integer> | <length>",
    "target"                        : 1,
    "target-name"                   : 1,
    "target-new"                    : 1,
    "target-position"               : 1,
    "text-align"                    : "left | right | center | justify | inherit" ,
    "text-align-last"               : 1,
    "text-decoration"               : 1,
    "text-emphasis"                 : 1,
    "text-height"                   : 1,
    "text-indent"                   : "<length> | <percentage> | inherit",
    "text-justify"                  : "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
    "text-outline"                  : 1,
    "text-overflow"                 : 1,
    "text-rendering"                : "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
    "text-shadow"                   : 1,
    "text-transform"                : "capitalize | uppercase | lowercase | none | inherit",
    "text-wrap"                     : "normal | none | avoid",
    "top"                           : "<margin-width> | inherit",
    "transform"                     : 1,
    "transform-origin"              : 1,
    "transform-style"               : 1,
    "transition"                    : 1,
    "transition-delay"              : 1,
    "transition-duration"           : 1,
    "transition-property"           : 1,
    "transition-timing-function"    : 1,
    
    //U
    "unicode-bidi"                  : "normal | embed | bidi-override | inherit",
    "user-modify"                   : "read-only | read-write | write-only | inherit",
    "user-select"                   : "none | text | toggle | element | elements | all | inherit",
    
    //V
    "vertical-align"                : "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>",
    "visibility"                    : "visible | hidden | collapse | inherit",
    "voice-balance"                 : 1,
    "voice-duration"                : 1,
    "voice-family"                  : 1,
    "voice-pitch"                   : 1,
    "voice-pitch-range"             : 1,
    "voice-rate"                    : 1,
    "voice-stress"                  : 1,
    "voice-volume"                  : 1,
    "volume"                        : 1,
    
    //W
    "white-space"                   : "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap", //http://perishablepress.com/wrapping-content/
    "white-space-collapse"          : 1,
    "widows"                        : "<integer> | inherit",
    "width"                         : "<length> | <percentage> | auto | inherit" ,
    "word-break"                    : "normal | keep-all | break-all",
    "word-spacing"                  : "<length> | normal | inherit",
    "word-wrap"                     : 1,
    
    //Z
    "z-index"                       : "<integer> | auto | inherit",
    "zoom"                          : "<number> | <percentage> | normal"
};
/*global SyntaxUnit, Parser*/
/**
 * Represents a selector combinator (whitespace, +, >).
 * @namespace parserlib.css
 * @class PropertyName
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit. 
 * @param {String} hack The type of IE hack applied ("*", "_", or null).
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function PropertyName(text, hack, line, col){
    
    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);

    /**
     * The type of IE hack applied ("*", "_", or null).
     * @type String
     * @property hack
     */
    this.hack = hack;

}

PropertyName.prototype = new SyntaxUnit();
PropertyName.prototype.constructor = PropertyName;
PropertyName.prototype.toString = function(){
    return (this.hack ? this.hack : "") + this.text;
};

/*global SyntaxUnit, Parser*/
/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just everything single part between ":" and ";". If there are multiple values
 * separated by commas, this type represents just one of the values.
 * @param {String[]} parts An array of value parts making up this value.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValue
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValue(parts, line, col){

    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);
    
    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;
    
}

PropertyValue.prototype = new SyntaxUnit();
PropertyValue.prototype.constructor = PropertyValue;


/*global SyntaxUnit, Parser*/
/**
 * A utility class that allows for easy iteration over the various parts of a
 * property value.
 * @param {parserlib.css.PropertyValue} value The property value to iterate over.
 * @namespace parserlib.css
 * @class PropertyValueIterator
 * @constructor
 */
function PropertyValueIterator(value){

    /** 
     * Iterator value
     * @type int
     * @property _i
     * @private
     */
    this._i = 0;
    
    /**
     * The parts that make up the value.
     * @type Array
     * @property _parts
     * @private
     */
    this._parts = value.parts;
    
    /**
     * Keeps track of bookmarks along the way.
     * @type Array
     * @property _marks
     * @private
     */
    this._marks = [];
    
    /**
     * Holds the original property value.
     * @type parserlib.css.PropertyValue
     * @property value
     */
    this.value = value;
    
}

/**
 * Returns the total number of parts in the value.
 * @return {int} The total number of parts in the value.
 * @method count
 */
PropertyValueIterator.prototype.count = function(){
    return this._parts.length;
};

/**
 * Indicates if the iterator is positioned at the first item.
 * @return {Boolean} True if positioned at first item, false if not.
 * @method isFirst
 */
PropertyValueIterator.prototype.isFirst = function(){
    return this._i === 0;
};

/**
 * Indicates if there are more parts of the property value.
 * @return {Boolean} True if there are more parts, false if not.
 * @method hasNext
 */
PropertyValueIterator.prototype.hasNext = function(){
    return (this._i < this._parts.length);
};

/**
 * Marks the current spot in the iteration so it can be restored to
 * later on.
 * @return {void}
 * @method mark
 */
PropertyValueIterator.prototype.mark = function(){
    this._marks.push(this._i);
};

/**
 * Returns the next part of the property value or null if there is no next
 * part. Does not move the internal counter forward.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method peek
 */
PropertyValueIterator.prototype.peek = function(count){
    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;
};

/**
 * Returns the next part of the property value or null if there is no next
 * part.
 * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next
 * part.
 * @method next
 */
PropertyValueIterator.prototype.next = function(){
    return this.hasNext() ? this._parts[this._i++] : null;
};

/**
 * Returns the previous part of the property value or null if there is no
 * previous part.
 * @return {parserlib.css.PropertyValuePart} The previous part of the 
 * property value or null if there is no next part.
 * @method previous
 */
PropertyValueIterator.prototype.previous = function(){
    return this._i > 0 ? this._parts[--this._i] : null;
};

/**
 * Restores the last saved bookmark.
 * @return {void}
 * @method restore
 */
PropertyValueIterator.prototype.restore = function(){
    if (this._marks.length){
        this._i = this._marks.pop();
    }
};


/*global SyntaxUnit, Parser, Colors*/
/**
 * Represents a single part of a CSS property value, meaning that it represents
 * just one part of the data between ":" and ";".
 * @param {String} text The text representation of the unit.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 * @namespace parserlib.css
 * @class PropertyValuePart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 */
function PropertyValuePart(text, line, col){

    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);
    
    /**
     * Indicates the type of value unit.
     * @type String
     * @property type
     */
    this.type = "unknown";

    //figure out what type of data it is
    
    var temp;
    
    //it is a measurement?
    if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)){  //dimension
        this.type = "dimension";
        this.value = +RegExp.$1;
        this.units = RegExp.$2;
        
        //try to narrow down
        switch(this.units.toLowerCase()){
        
            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
                this.type = "length";
                break;
                
            case "deg":
            case "rad":
            case "grad":
                this.type = "angle";
                break;
            
            case "ms":
            case "s":
                this.type = "time";
                break;
            
            case "hz":
            case "khz":
                this.type = "frequency";
                break;
            
            case "dpi":
            case "dpcm":
                this.type = "resolution";
                break;
                
            //default
                
        }
        
    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)%$/i.test(text)){  //percentage
        this.type = "percentage";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?\d+)$/i.test(text)){  //integer
        this.type = "integer";
        this.value = +RegExp.$1;
    } else if (/^([+\-]?[\d\.]+)$/i.test(text)){  //number
        this.type = "number";
        this.value = +RegExp.$1;
    
    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor
        this.type = "color";
        temp = RegExp.$1;
        if (temp.length == 3){
            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);
            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);
            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);            
        } else {
            this.red    = parseInt(temp.substring(0,2),16);
            this.green  = parseInt(temp.substring(2,4),16);
            this.blue   = parseInt(temp.substring(4,6),16);            
        }
    } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)){ //rgb() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
    } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //rgb() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
    } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with absolute numbers
        this.type   = "color";
        this.red    = +RegExp.$1;
        this.green  = +RegExp.$2;
        this.blue   = +RegExp.$3;
        this.alpha  = +RegExp.$4;
    } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //rgba() color with percentages
        this.type   = "color";
        this.red    = +RegExp.$1 * 255 / 100;
        this.green  = +RegExp.$2 * 255 / 100;
        this.blue   = +RegExp.$3 * 255 / 100;
        this.alpha  = +RegExp.$4;        
    } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)){ //hsl()
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;        
    } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)){ //hsla() color with percentages
        this.type   = "color";
        this.hue    = +RegExp.$1;
        this.saturation = +RegExp.$2 / 100;
        this.lightness  = +RegExp.$3 / 100;        
        this.alpha  = +RegExp.$4;        
    } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)){ //URI
        this.type   = "uri";
        this.uri    = RegExp.$1;
    } else if (/^([^\(]+)\(/i.test(text)){
        this.type   = "function";
        this.name   = RegExp.$1;
        this.value  = text;
    } else if (/^["'][^"']*["']/.test(text)){    //string
        this.type   = "string";
        this.value  = eval(text);
    } else if (Colors[text.toLowerCase()]){  //named color
        this.type   = "color";
        temp        = Colors[text.toLowerCase()].substring(1);
        this.red    = parseInt(temp.substring(0,2),16);
        this.green  = parseInt(temp.substring(2,4),16);
        this.blue   = parseInt(temp.substring(4,6),16);         
    } else if (/^[\,\/]$/.test(text)){
        this.type   = "operator";
        this.value  = text;
    } else if (/^[a-z\-\u0080-\uFFFF][a-z0-9\-\u0080-\uFFFF]*$/i.test(text)){
        this.type   = "identifier";
        this.value  = text;
    }

}

PropertyValuePart.prototype = new SyntaxUnit();
PropertyValuePart.prototype.constructor = PropertyValuePart;

/**
 * Create a new syntax unit based solely on the given token.
 * Convenience method for creating a new syntax unit when
 * it represents a single token instead of multiple.
 * @param {Object} token The token object to represent.
 * @return {parserlib.css.PropertyValuePart} The object representing the token.
 * @static
 * @method fromToken
 */
PropertyValuePart.fromToken = function(token){
    return new PropertyValuePart(token.value, token.startLine, token.startCol);
};
var Pseudos = {
    ":first-letter": 1,
    ":first-line":   1,
    ":before":       1,
    ":after":        1
};

Pseudos.ELEMENT = 1;
Pseudos.CLASS = 2;

Pseudos.isElement = function(pseudo){
    return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] == Pseudos.ELEMENT;
};
/*global SyntaxUnit, Parser, Specificity*/
/**
 * Represents an entire single selector, including all parts but not
 * including multiple selectors (those separated by commas).
 * @namespace parserlib.css
 * @class Selector
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {Array} parts Array of selectors parts making up this selector.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function Selector(parts, line, col){
    
    SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);
    
    /**
     * The parts that make up the selector.
     * @type Array
     * @property parts
     */
    this.parts = parts;
    
    /**
     * The specificity of the selector.
     * @type parserlib.css.Specificity
     * @property specificity
     */
    this.specificity = Specificity.calculate(this);

}

Selector.prototype = new SyntaxUnit();
Selector.prototype.constructor = Selector;


/*global SyntaxUnit, Parser*/
/**
 * Represents a single part of a selector string, meaning a single set of
 * element name and modifiers. This does not include combinators such as
 * spaces, +, >, etc.
 * @namespace parserlib.css
 * @class SelectorPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} elementName The element name in the selector or null
 *      if there is no element name.
 * @param {Array} modifiers Array of individual modifiers for the element.
 *      May be empty if there are none.
 * @param {String} text The text representation of the unit. 
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorPart(elementName, modifiers, text, line, col){
    
    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);

    /**
     * The tag name of the element to which this part
     * of the selector affects.
     * @type String
     * @property elementName
     */
    this.elementName = elementName;
    
    /**
     * The parts that come after the element name, such as class names, IDs,
     * pseudo classes/elements, etc.
     * @type Array
     * @property modifiers
     */
    this.modifiers = modifiers;

}

SelectorPart.prototype = new SyntaxUnit();
SelectorPart.prototype.constructor = SelectorPart;


/*global SyntaxUnit, Parser*/
/**
 * Represents a selector modifier string, meaning a class name, element name,
 * element ID, pseudo rule, etc.
 * @namespace parserlib.css
 * @class SelectorSubPart
 * @extends parserlib.util.SyntaxUnit
 * @constructor
 * @param {String} text The text representation of the unit. 
 * @param {String} type The type of selector modifier.
 * @param {int} line The line of text on which the unit resides.
 * @param {int} col The column of text on which the unit resides.
 */
function SelectorSubPart(text, type, line, col){
    
    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);

    /**
     * The type of modifier.
     * @type String
     * @property type
     */
    this.type = type;
    
    /**
     * Some subparts have arguments, this represents them.
     * @type Array
     * @property args
     */
    this.args = [];

}

SelectorSubPart.prototype = new SyntaxUnit();
SelectorSubPart.prototype.constructor = SelectorSubPart;


/*global Pseudos, SelectorPart*/
/**
 * Represents a selector's specificity.
 * @namespace parserlib.css
 * @class Specificity
 * @constructor
 * @param {int} a Should be 1 for inline styles, zero for stylesheet styles
 * @param {int} b Number of ID selectors
 * @param {int} c Number of classes and pseudo classes
 * @param {int} d Number of element names and pseudo elements
 */
function Specificity(a, b, c, d){
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
}

Specificity.prototype = {
    constructor: Specificity,
    
    /**
     * Compare this specificity to another.
     * @param {Specificity} other The other specificity to compare to.
     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
     * @method compare
     */
    compare: function(other){
        var comps = ["a", "b", "c", "d"],
            i, len;
            
        for (i=0, len=comps.length; i < len; i++){
            if (this[comps[i]] < other[comps[i]]){
                return -1;
            } else if (this[comps[i]] > other[comps[i]]){
                return 1;
            }
        }
        
        return 0;
    },
    
    /**
     * Creates a numeric value for the specificity.
     * @return {int} The numeric value for the specificity.
     * @method valueOf
     */
    valueOf: function(){
        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;
    },
    
    /**
     * Returns a string representation for specificity.
     * @return {String} The string representation of specificity.
     * @method toString
     */
    toString: function(){
        return this.a + "," + this.b + "," + this.c + "," + this.d;
    }

};

/**
 * Calculates the specificity of the given selector.
 * @param {parserlib.css.Selector} The selector to calculate specificity for.
 * @return {parserlib.css.Specificity} The specificity of the selector.
 * @static
 * @method calculate
 */
Specificity.calculate = function(selector){

    var i, len,
        part,
        b=0, c=0, d=0;
        
    function updateValues(part){
    
        var i, j, len, num,
            elementName = part.elementName ? part.elementName.text : "",
            modifier;
    
        if (elementName && elementName.charAt(elementName.length-1) != "*") {
            d++;
        }    
    
        for (i=0, len=part.modifiers.length; i < len; i++){
            modifier = part.modifiers[i];
            switch(modifier.type){
                case "class":
                case "attribute":
                    c++;
                    break;
                    
                case "id":
                    b++;
                    break;
                    
                case "pseudo":
                    if (Pseudos.isElement(modifier.text)){
                        d++;
                    } else {
                        c++;
                    }                    
                    break;
                    
                case "not":
                    for (j=0, num=modifier.args.length; j < num; j++){
                        updateValues(modifier.args[j]);
                    }
            }    
         }
    }
    
    for (i=0, len=selector.parts.length; i < len; i++){
        part = selector.parts[i];
        
        if (part instanceof SelectorPart){
            updateValues(part);                
        }
    }
    
    return new Specificity(0, b, c, d);
};

/*global Tokens, TokenStreamBase*/

var h = /^[0-9a-fA-F]$/,
    nonascii = /^[\u0080-\uFFFF]$/,
    nl = /\n|\r\n|\r|\f/;

//-----------------------------------------------------------------------------
// Helper functions
//-----------------------------------------------------------------------------


function isHexDigit(c){
    return c !== null && h.test(c);
}

function isDigit(c){
    return c !== null && /\d/.test(c);
}

function isWhitespace(c){
    return c !== null && /\s/.test(c);
}

function isNewLine(c){
    return c !== null && nl.test(c);
}

function isNameStart(c){
    return c !== null && (/[a-z_\u0080-\uFFFF\\]/i.test(c));
}

function isNameChar(c){
    return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
}

function isIdentStart(c){
    return c !== null && (isNameStart(c) || /\-\\/.test(c));
}

function mix(receiver, supplier){
	for (var prop in supplier){
		if (supplier.hasOwnProperty(prop)){
			receiver[prop] = supplier[prop];
		}
	}
	return receiver;
}

//-----------------------------------------------------------------------------
// CSS Token Stream
//-----------------------------------------------------------------------------


/**
 * A token stream that produces CSS tokens.
 * @param {String|Reader} input The source of text to tokenize.
 * @constructor
 * @class TokenStream
 * @namespace parserlib.css
 */
function TokenStream(input){
	TokenStreamBase.call(this, input, Tokens);
}

TokenStream.prototype = mix(new TokenStreamBase(), {

    /**
     * Overrides the TokenStreamBase method of the same name
     * to produce CSS tokens.
     * @param {variant} channel The name of the channel to use
     *      for the next token.
     * @return {Object} A token object representing the next token.
     * @method _getToken
     * @private
     */
    _getToken: function(channel){

        var c,
            reader = this._reader,
            token   = null,
            startLine   = reader.getLine(),
            startCol    = reader.getCol();

        c = reader.read();


        while(c){
            switch(c){

                /*
                 * Potential tokens:
                 * - COMMENT
                 * - SLASH
                 * - CHAR
                 */
                case "/":

                    if(reader.peek() == "*"){
                        token = this.commentToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DASHMATCH
                 * - INCLUDES
                 * - PREFIXMATCH
                 * - SUFFIXMATCH
                 * - SUBSTRINGMATCH
                 * - CHAR
                 */
                case "|":
                case "~":
                case "^":
                case "$":
                case "*":
                    if(reader.peek() == "="){
                        token = this.comparisonToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - STRING
                 * - INVALID
                 */
                case "\"":
                case "'":
                    token = this.stringToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - HASH
                 * - CHAR
                 */
                case "#":
                    if (isNameChar(reader.peek())){
                        token = this.hashToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - DOT
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case ".":
                    if (isDigit(reader.peek())){
                        token = this.numberToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - CDC
                 * - MINUS
                 * - NUMBER
                 * - DIMENSION
                 * - PERCENTAGE
                 */
                case "-":
                    if (reader.peek() == "-"){  //could be closing HTML-style comment
                        token = this.htmlCommentEndToken(c, startLine, startCol);
                    } else if (isNameStart(reader.peek())){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else {
                        token = this.charToken(c, startLine, startCol);
                    }
                    break;

                /*
                 * Potential tokens:
                 * - IMPORTANT_SYM
                 * - CHAR
                 */
                case "!":
                    token = this.importantToken(c, startLine, startCol);
                    break;

                /*
                 * Any at-keyword or CHAR
                 */
                case "@":
                    token = this.atRuleToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - NOT
                 * - CHAR
                 */
                case ":":
                    token = this.notToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - CDO
                 * - CHAR
                 */
                case "<":
                    token = this.htmlCommentStartToken(c, startLine, startCol);
                    break;

                /*
                 * Potential tokens:
                 * - UNICODE_RANGE
                 * - URL
                 * - CHAR
                 */
                case "U":
                case "u":
                    if (reader.peek() == "+"){
                        token = this.unicodeRangeToken(c, startLine, startCol);
                        break;
                    }
                    /* falls through */
                default:

                    /*
                     * Potential tokens:
                     * - NUMBER
                     * - DIMENSION
                     * - LENGTH
                     * - FREQ
                     * - TIME
                     * - EMS
                     * - EXS
                     * - ANGLE
                     */
                    if (isDigit(c)){
                        token = this.numberToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - S
                     */
                    if (isWhitespace(c)){
                        token = this.whitespaceToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - IDENT
                     */
                    if (isIdentStart(c)){
                        token = this.identOrFunctionToken(c, startLine, startCol);
                    } else

                    /*
                     * Potential tokens:
                     * - CHAR
                     * - PLUS
                     */
                    {
                        token = this.charToken(c, startLine, startCol);
                    }






            }

            //make sure this token is wanted
            //TODO: check channel
            break;
        }

        if (!token && c === null){
            token = this.createToken(Tokens.EOF,null,startLine,startCol);
        }

        return token;
    },

    //-------------------------------------------------------------------------
    // Methods to create tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token based on available data and the current
     * reader position information. This method is called by other
     * private methods to create tokens and is never called directly.
     * @param {int} tt The token type.
     * @param {String} value The text value of the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @param {Object} options (Optional) Specifies a channel property
     *      to indicate that a different channel should be scanned
     *      and/or a hide property indicating that the token should
     *      be hidden.
     * @return {Object} A token object.
     * @method createToken
     */
    createToken: function(tt, value, startLine, startCol, options){
        var reader = this._reader;
        options = options || {};

        return {
            value:      value,
            type:       tt,
            channel:    options.channel,
            hide:       options.hide || false,
            startLine:  startLine,
            startCol:   startCol,
            endLine:    reader.getLine(),
            endCol:     reader.getCol()
        };
    },

    //-------------------------------------------------------------------------
    // Methods to create specific tokens
    //-------------------------------------------------------------------------

    /**
     * Produces a token for any at-rule. If the at-rule is unknown, then
     * the token is for a single "@" character.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method atRuleToken
     */
    atRuleToken: function(first, startLine, startCol){
        var rule    = first,
            reader  = this._reader,
            tt      = Tokens.CHAR,
            valid   = false,
            ident,
            c;

        /*
         * First, mark where we are. There are only four @ rules,
         * so anything else is really just an invalid token.
         * Basically, if this doesn't match one of the known @
         * rules, just return '@' as an unknown token and allow
         * parsing to continue after that point.
         */
        reader.mark();

        //try to find the at-keyword
        ident = this.readName();
        rule = first + ident;
        tt = Tokens.type(rule.toLowerCase());

        //if it's not valid, use the first character only and reset the reader
        if (tt == Tokens.CHAR || tt == Tokens.UNKNOWN){
            if (rule.length > 1){
                tt = Tokens.UNKNOWN_SYM;                
            } else {
                tt = Tokens.CHAR;
                rule = first;
                reader.reset();
            }
        }

        return this.createToken(tt, rule, startLine, startCol);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method charToken
     */
    charToken: function(c, startLine, startCol){
        var tt = Tokens.type(c);

        if (tt == -1){
            tt = Tokens.CHAR;
        }

        return this.createToken(tt, c, startLine, startCol);
    },

    /**
     * Produces a character token based on the given character
     * and location in the stream. If there's a special (non-standard)
     * token name, this is used; otherwise CHAR is used.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method commentToken
     */
    commentToken: function(first, startLine, startCol){
        var reader  = this._reader,
            comment = this.readComment(first);

        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
    },

    /**
     * Produces a comparison token based on the given character
     * and location in the stream. The next character must be
     * read and is already known to be an equals sign.
     * @param {String} c The character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method comparisonToken
     */
    comparisonToken: function(c, startLine, startCol){
        var reader  = this._reader,
            comparison  = c + reader.read(),
            tt      = Tokens.type(comparison) || Tokens.CHAR;

        return this.createToken(tt, comparison, startLine, startCol);
    },

    /**
     * Produces a hash token based on the specified information. The
     * first character provided is the pound sign (#) and then this
     * method reads a name afterward.
     * @param {String} first The first character (#) in the hash name.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method hashToken
     */
    hashToken: function(first, startLine, startCol){
        var reader  = this._reader,
            name    = this.readName(first);

        return this.createToken(Tokens.HASH, name, startLine, startCol);
    },

    /**
     * Produces a CDO or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentStartToken
     */
    htmlCommentStartToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(3);

        if (text == "<!--"){
            return this.createToken(Tokens.CDO, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a CDC or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method htmlCommentEndToken
     */
    htmlCommentEndToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(2);

        if (text == "-->"){
            return this.createToken(Tokens.CDC, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces an IDENT or FUNCTION token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the identifier.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method identOrFunctionToken
     */
    identOrFunctionToken: function(first, startLine, startCol){
        var reader  = this._reader,
            ident   = this.readName(first),
            tt      = Tokens.IDENT;

        //if there's a left paren immediately after, it's a URI or function
        if (reader.peek() == "("){
            ident += reader.read();
            if (ident.toLowerCase() == "url("){
                tt = Tokens.URI;
                ident = this.readURI(ident);

                //didn't find a valid URL or there's no closing paren
                if (ident.toLowerCase() == "url("){
                    tt = Tokens.FUNCTION;
                }
            } else {
                tt = Tokens.FUNCTION;
            }
        } else if (reader.peek() == ":"){  //might be an IE function

            //IE-specific functions always being with progid:
            if (ident.toLowerCase() == "progid"){
                ident += reader.readTo("(");
                tt = Tokens.IE_FUNCTION;
            }
        }

        return this.createToken(tt, ident, startLine, startCol);
    },

    /**
     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method importantToken
     */
    importantToken: function(first, startLine, startCol){
        var reader      = this._reader,
            important   = first,
            tt          = Tokens.CHAR,
            temp,
            c;

        reader.mark();
        c = reader.read();

        while(c){

            //there can be a comment in here
            if (c == "/"){

                //if the next character isn't a star, then this isn't a valid !important token
                if (reader.peek() != "*"){
                    break;
                } else {
                    temp = this.readComment(c);
                    if (temp === ""){    //broken!
                        break;
                    }
                }
            } else if (isWhitespace(c)){
                important += c + this.readWhitespace();
            } else if (/i/i.test(c)){
                temp = reader.readCount(8);
                if (/mportant/i.test(temp)){
                    important += c + temp;
                    tt = Tokens.IMPORTANT_SYM;

                }
                break;  //we're done
            } else {
                break;
            }

            c = reader.read();
        }

        if (tt == Tokens.CHAR){
            reader.reset();
            return this.charToken(first, startLine, startCol);
        } else {
            return this.createToken(tt, important, startLine, startCol);
        }


    },

    /**
     * Produces a NOT or CHAR token based on the specified information. The
     * first character is provided and the rest is read by the function to determine
     * the correct token to create.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method notToken
     */
    notToken: function(first, startLine, startCol){
        var reader      = this._reader,
            text        = first;

        reader.mark();
        text += reader.readCount(4);

        if (text.toLowerCase() == ":not("){
            return this.createToken(Tokens.NOT, text, startLine, startCol);
        } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
        }
    },

    /**
     * Produces a number token based on the given character
     * and location in the stream. This may return a token of
     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
     * or PERCENTAGE.
     * @param {String} first The first character for the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method numberToken
     */
    numberToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = this.readNumber(first),
            ident,
            tt      = Tokens.NUMBER,
            c       = reader.peek();

        if (isIdentStart(c)){
            ident = this.readName(reader.read());
            value += ident;

            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vm$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){
                tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)){
                tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)){
                tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)){
                tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)){
                tt = Tokens.RESOLUTION;
            } else {
                tt = Tokens.DIMENSION;
            }

        } else if (c == "%"){
            value += reader.read();
            tt = Tokens.PERCENTAGE;
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a string token based on the given character
     * and location in the stream. Since strings may be indicated
     * by single or double quotes, a failure to match starting
     * and ending quotes results in an INVALID token being generated.
     * The first character in the string is passed in and then
     * the rest are read up to and including the final quotation mark.
     * @param {String} first The first character in the string.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method stringToken
     */
    stringToken: function(first, startLine, startCol){
        var delim   = first,
            string  = first,
            reader  = this._reader,
            prev    = first,
            tt      = Tokens.STRING,
            c       = reader.read();

        while(c){
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c == delim && prev != "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c != "\\"){
                tt = Tokens.INVALID;
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.read();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            tt = Tokens.INVALID;
        }

        return this.createToken(tt, string, startLine, startCol);
    },

    unicodeRangeToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first,
            temp,
            tt      = Tokens.CHAR;

        //then it should be a unicode range
        if (reader.peek() == "+"){
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);

            //ensure there's an actual unicode range here
            if (value.length == 2){
                reader.reset();
            } else {

                tt = Tokens.UNICODE_RANGE;

                //if there's a ? in the first part, there can't be a second part
                if (value.indexOf("?") == -1){

                    if (reader.peek() == "-"){
                        reader.mark();
                        temp = reader.read();
                        temp += this.readUnicodeRangePart(false);

                        //if there's not another value, back up and just take the first
                        if (temp.length == 1){
                            reader.reset();
                        } else {
                            value += temp;
                        }
                    }

                }
            }
        }

        return this.createToken(tt, value, startLine, startCol);
    },

    /**
     * Produces a S token based on the specified information. Since whitespace
     * may have multiple characters, this consumes all whitespace characters
     * into a single token.
     * @param {String} first The first character in the token.
     * @param {int} startLine The beginning line for the character.
     * @param {int} startCol The beginning column for the character.
     * @return {Object} A token object.
     * @method whitespaceToken
     */
    whitespaceToken: function(first, startLine, startCol){
        var reader  = this._reader,
            value   = first + this.readWhitespace();
        return this.createToken(Tokens.S, value, startLine, startCol);
    },




    //-------------------------------------------------------------------------
    // Methods to read values from the string stream
    //-------------------------------------------------------------------------

    readUnicodeRangePart: function(allowQuestionMark){
        var reader  = this._reader,
            part = "",
            c       = reader.peek();

        //first read hex digits
        while(isHexDigit(c) && part.length < 6){
            reader.read();
            part += c;
            c = reader.peek();
        }

        //then read question marks if allowed
        if (allowQuestionMark){
            while(c == "?" && part.length < 6){
                reader.read();
                part += c;
                c = reader.peek();
            }
        }

        //there can't be any other characters after this point

        return part;
    },

    readWhitespace: function(){
        var reader  = this._reader,
            whitespace = "",
            c       = reader.peek();

        while(isWhitespace(c)){
            reader.read();
            whitespace += c;
            c = reader.peek();
        }

        return whitespace;
    },
    readNumber: function(first){
        var reader  = this._reader,
            number  = first,
            hasDot  = (first == "."),
            c       = reader.peek();


        while(c){
            if (isDigit(c)){
                number += reader.read();
            } else if (c == "."){
                if (hasDot){
                    break;
                } else {
                    hasDot = true;
                    number += reader.read();
                }
            } else {
                break;
            }

            c = reader.peek();
        }

        return number;
    },
    readString: function(){
        var reader  = this._reader,
            delim   = reader.read(),
            string  = delim,
            prev    = delim,
            c       = reader.peek();

        while(c){
            c = reader.read();
            string += c;

            //if the delimiter is found with an escapement, we're done.
            if (c == delim && prev != "\\"){
                break;
            }

            //if there's a newline without an escapement, it's an invalid string
            if (isNewLine(reader.peek()) && c != "\\"){
                string = "";
                break;
            }

            //save previous and get next
            prev = c;
            c = reader.peek();
        }

        //if c is null, that means we're out of input and the string was never closed
        if (c === null){
            string = "";
        }

        return string;
    },
    readURI: function(first){
        var reader  = this._reader,
            uri     = first,
            inner   = "",
            c       = reader.peek();

        reader.mark();

        //skip whitespace before
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //it's a string
        if (c == "'" || c == "\""){
            inner = this.readString();
        } else {
            inner = this.readURL();
        }

        c = reader.peek();

        //skip whitespace after
        while(c && isWhitespace(c)){
            reader.read();
            c = reader.peek();
        }

        //if there was no inner value or the next character isn't closing paren, it's not a URI
        if (inner === "" || c != ")"){
            uri = first;
            reader.reset();
        } else {
            uri += inner + reader.read();
        }

        return uri;
    },
    readURL: function(){
        var reader  = this._reader,
            url     = "",
            c       = reader.peek();

        //TODO: Check for escape and nonascii
        while (/^[!#$%&\\*-~]$/.test(c)){
            url += reader.read();
            c = reader.peek();
        }

        return url;

    },
    readName: function(first){
        var reader  = this._reader,
            ident   = first || "",
            c       = reader.peek();

        while(true){
            if (c == "\\"){
                ident += this.readEscape(reader.read());
                c = reader.peek();
            } else if(c && isNameChar(c)){
                ident += reader.read();
                c = reader.peek();
            } else {
                break;
            }
        }

        return ident;
    },
    
    readEscape: function(first){
        var reader  = this._reader,
            cssEscape = first || "",
            i       = 0,
            c       = reader.peek();    
    
        if (isHexDigit(c)){
            do {
                cssEscape += reader.read();
                c = reader.peek();
            } while(c && isHexDigit(c) && ++i < 6);
        }
        
        if (cssEscape.length == 3 && /\s/.test(c) ||
            cssEscape.length == 7 || cssEscape.length == 1){
                reader.read();
        } else {
            c = "";
        }
        
        return cssEscape + c;
    },
    
    readComment: function(first){
        var reader  = this._reader,
            comment = first || "",
            c       = reader.read();

        if (c == "*"){
            while(c){
                comment += c;

                //look for end of comment
                if (comment.length > 2 && c == "*" && reader.peek() == "/"){
                    comment += reader.read();
                    break;
                }

                c = reader.read();
            }

            return comment;
        } else {
            return "";
        }

    }
});


var Tokens  = [

    /*
     * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical
     */
     
    //HTML-style comments
    { name: "CDO"},
    { name: "CDC"},

    //ignorables
    { name: "S", whitespace: true/*, channel: "ws"*/},
    { name: "COMMENT", comment: true, hide: true, channel: "comment" },
        
    //attribute equality
    { name: "INCLUDES", text: "~="},
    { name: "DASHMATCH", text: "|="},
    { name: "PREFIXMATCH", text: "^="},
    { name: "SUFFIXMATCH", text: "$="},
    { name: "SUBSTRINGMATCH", text: "*="},
        
    //identifier types
    { name: "STRING"},     
    { name: "IDENT"},
    { name: "HASH"},

    //at-keywords
    { name: "IMPORT_SYM", text: "@import"},
    { name: "PAGE_SYM", text: "@page"},
    { name: "MEDIA_SYM", text: "@media"},
    { name: "FONT_FACE_SYM", text: "@font-face"},
    { name: "CHARSET_SYM", text: "@charset"},
    { name: "NAMESPACE_SYM", text: "@namespace"},
    { name: "UNKNOWN_SYM" },
    //{ name: "ATKEYWORD"},
    
    //CSS3 animations
    { name: "KEYFRAMES_SYM", text: [ "@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes" ] },

    //important symbol
    { name: "IMPORTANT_SYM"},

    //measurements
    { name: "LENGTH"},
    { name: "ANGLE"},
    { name: "TIME"},
    { name: "FREQ"},
    { name: "DIMENSION"},
    { name: "PERCENTAGE"},
    { name: "NUMBER"},
    
    //functions
    { name: "URI"},
    { name: "FUNCTION"},
    
    //Unicode ranges
    { name: "UNICODE_RANGE"},
    
    /*
     * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax
     */    
    
    //invalid string
    { name: "INVALID"},
    
    //combinators
    { name: "PLUS", text: "+" },
    { name: "GREATER", text: ">"},
    { name: "COMMA", text: ","},
    { name: "TILDE", text: "~"},
    
    //modifier
    { name: "NOT"},        
    
    /*
     * Defined in CSS3 Paged Media
     */
    { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner"},
    { name: "TOPLEFT_SYM", text: "@top-left"},
    { name: "TOPCENTER_SYM", text: "@top-center"},
    { name: "TOPRIGHT_SYM", text: "@top-right"},
    { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner"},
    { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner"},
    { name: "BOTTOMLEFT_SYM", text: "@bottom-left"},
    { name: "BOTTOMCENTER_SYM", text: "@bottom-center"},
    { name: "BOTTOMRIGHT_SYM", text: "@bottom-right"},
    { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner"},
    { name: "LEFTTOP_SYM", text: "@left-top"},
    { name: "LEFTMIDDLE_SYM", text: "@left-middle"},
    { name: "LEFTBOTTOM_SYM", text: "@left-bottom"},
    { name: "RIGHTTOP_SYM", text: "@right-top"},
    { name: "RIGHTMIDDLE_SYM", text: "@right-middle"},
    { name: "RIGHTBOTTOM_SYM", text: "@right-bottom"},

    /*
     * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax
     */
    /*{ name: "MEDIA_ONLY", state: "media"},
    { name: "MEDIA_NOT", state: "media"},
    { name: "MEDIA_AND", state: "media"},*/
    { name: "RESOLUTION", state: "media"},

    /*
     * The following token names are not defined in any CSS specification but are used by the lexer.
     */
    
    //not a real token, but useful for stupid IE filters
    { name: "IE_FUNCTION" },

    //part of CSS3 grammar but not the Flex code
    { name: "CHAR" },
    
    //TODO: Needed?
    //Not defined as tokens, but might as well be
    {
        name: "PIPE",
        text: "|"
    },
    {
        name: "SLASH",
        text: "/"
    },
    {
        name: "MINUS",
        text: "-"
    },
    {
        name: "STAR",
        text: "*"
    },

    {
        name: "LBRACE",
        text: "{"
    },   
    {
        name: "RBRACE",
        text: "}"
    },      
    {
        name: "LBRACKET",
        text: "["
    },   
    {
        name: "RBRACKET",
        text: "]"
    },    
    {
        name: "EQUALS",
        text: "="
    },
    {
        name: "COLON",
        text: ":"
    },    
    {
        name: "SEMICOLON",
        text: ";"
    },    
 
    {
        name: "LPAREN",
        text: "("
    },   
    {
        name: "RPAREN",
        text: ")"
    },     
    {
        name: "DOT",
        text: "."
    }
];

(function(){

    var nameMap = [],
        typeMap = {};
    
    Tokens.UNKNOWN = -1;
    Tokens.unshift({name:"EOF"});
    for (var i=0, len = Tokens.length; i < len; i++){
        nameMap.push(Tokens[i].name);
        Tokens[Tokens[i].name] = i;
        if (Tokens[i].text){
            if (Tokens[i].text instanceof Array){
                for (var j=0; j < Tokens[i].text.length; j++){
                    typeMap[Tokens[i].text[j]] = i;
                }
            } else {
                typeMap[Tokens[i].text] = i;
            }
        }
    }
    
    Tokens.name = function(tt){
        return nameMap[tt];
    };
    
    Tokens.type = function(c){
        return typeMap[c] || -1;
    };

})();




//This file will likely change a lot! Very experimental!
/*global Properties, ValidationTypes, ValidationError, PropertyValueIterator */
var Validation = {

    validate: function(property, value){
    
        //normalize name
        var name        = property.toString().toLowerCase(),
            parts       = value.parts,
            expression  = new PropertyValueIterator(value),
            spec        = Properties[name],
            part,
            valid,            
            j, count,
            msg,
            types,
            last,
            literals,
            max, multi, group;
            
        if (!spec) {
            if (name.indexOf("-") !== 0){    //vendor prefixed are ok
                throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
        } else if (typeof spec != "number"){
        
            //initialization
            if (typeof spec == "string"){
                if (spec.indexOf("||") > -1) {
                    this.groupProperty(spec, expression);
                } else {
                    this.singleProperty(spec, expression, 1);
                }

            } else if (spec.multi) {
                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec == "function") {
                spec(expression);
            }

        }

    },
    
    singleProperty: function(types, expression, max, partial) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            part;
         
        while (expression.hasNext() && count < max) {
            result = ValidationTypes.isAny(expression, types);
            if (!result) {
                break;
            }
            count++;
        }
        
        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                 throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }        
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }          
                 
    },    
    
    multiProperty: function (types, expression, comma, max) {

        var result      = false,
            value       = expression.value,
            count       = 0,
            sep         = false,
            part;
            
        while(expression.hasNext() && !result && count < max) {
            if (ValidationTypes.isAny(expression, types)) {
                count++;
                if (!expression.hasNext()) {
                    result = true;

                } else if (comma) {
                    if (expression.peek() == ",") {
                        part = expression.next();
                    } else {
                        break;
                    }
                }
            } else {
                break;

            }
        }
        
        if (!result) {
            if (expression.hasNext() && !expression.isFirst()) {
                part = expression.peek();
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                part = expression.previous();
                if (comma && part == ",") {
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col); 
                } else {
                    throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
                }
            }
        
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }  

    },
    
    groupProperty: function (types, expression, comma) {

        var result      = false,
            value       = expression.value,
            typeCount   = types.split("||").length,
            groups      = { count: 0 },
            partial     = false,
            name,
            part;
            
        while(expression.hasNext() && !result) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {
            
                //no dupes
                if (groups[name]) {
                    break;
                } else {
                    groups[name] = 1;
                    groups.count++;
                    partial = true;
                    
                    if (groups.count == typeCount || !expression.hasNext()) {
                        result = true;
                    }
                }
            } else {
                break;
            }
        }
        
        if (!result) {        
            if (partial && expression.hasNext()) {
                    part = expression.peek();
                    throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
        } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
        }           
    }

    

};
/**
 * Type to use when a validation error occurs.
 * @class ValidationError
 * @namespace parserlib.util
 * @constructor
 * @param {String} message The error message.
 * @param {int} line The line at which the error occurred.
 * @param {int} col The column at which the error occurred.
 */
function ValidationError(message, line, col){

    /**
     * The column at which the error occurred.
     * @type int
     * @property col
     */
    this.col = col;

    /**
     * The line at which the error occurred.
     * @type int
     * @property line
     */
    this.line = line;

    /**
     * The text representation of the unit.
     * @type String
     * @property text
     */
    this.message = message;

}

//inherit from Error
ValidationError.prototype = new Error();
//This file will likely change a lot! Very experimental!
/*global Properties, Validation, ValidationError, PropertyValueIterator, console*/
var ValidationTypes = {

    isLiteral: function (part, literals) {
        var text = part.text.toString().toLowerCase(),
            args = literals.split(" | "),
            i, len, found = false;
        
        for (i=0,len=args.length; i < len && !found; i++){
            if (text == args[i].toLowerCase()){
                found = true;
            }
        }
        
        return found;    
    },
    
    isSimple: function(type) {
        return !!this.simple[type];
    },
    
    isComplex: function(type) {
        return !!this.complex[type];
    },
    
    /**
     * Determines if the next part(s) of the given expression
     * are any of the given types.
     */
    isAny: function (expression, types) {
        var args = types.split(" | "),
            i, len, found = false;
        
        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){
            found = this.isType(expression, args[i]);
        }
        
        return found;    
    },
    
    /**
     * Determines if the next part(s) of the given expression
     * are one of a group.
     */
    isAnyOfGroup: function(expression, types) {
        var args = types.split(" || "),
            i, len, found = false;
        
        for (i=0,len=args.length; i < len && !found; i++){
            found = this.isType(expression, args[i]);
        }
        
        return found ? args[i-1] : false;
    },
    
    /**
     * Determines if the next part(s) of the given expression
     * are of a given type.
     */
    isType: function (expression, type) {
        var part = expression.peek(),
            result = false;
            
        if (type.charAt(0) != "<") {
            result = this.isLiteral(part, type);
            if (result) {
                expression.next();
            }
        } else if (this.simple[type]) {
            result = this.simple[type](part);
            if (result) {
                expression.next();
            }
        } else {
            result = this.complex[type](expression);
        }
        
        return result;
    },
    
    
    
    simple: {

        "<absolute-size>": function(part){
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
        },
        
        "<attachment>": function(part){
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
        },
        
        "<attr>": function(part){
            return part.type == "function" && part.name == "attr";
        },
                
        "<bg-image>": function(part){
            return this["<image>"](part) || this["<gradient>"](part) ||  part == "none";
        },        
        
        "<gradient>": function(part) {
            return part.type == "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
        },
        
        "<box>": function(part){
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
        },
        
        "<content>": function(part){
            return part.type == "function" && part.name == "content";
        },        
        
        "<relative-size>": function(part){
            return ValidationTypes.isLiteral(part, "smaller | larger");
        },
        
        //any identifier
        "<ident>": function(part){
            return part.type == "identifier";
        },
        
        "<length>": function(part){
            if (part.type == "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)){
                return true;
            }else{
                return part.type == "length" || part.type == "number" || part.type == "integer" || part == "0";
            }
        },
        
        "<color>": function(part){
            return part.type == "color" || part == "transparent";
        },
        
        "<number>": function(part){
            return part.type == "number" || this["<integer>"](part);
        },
        
        "<integer>": function(part){
            return part.type == "integer";
        },
        
        "<line>": function(part){
            return part.type == "integer";
        },
        
        "<angle>": function(part){
            return part.type == "angle";
        },        
        
        "<uri>": function(part){
            return part.type == "uri";
        },
        
        "<image>": function(part){
            return this["<uri>"](part);
        },
        
        "<percentage>": function(part){
            return part.type == "percentage" || part == "0";
        },

        "<border-width>": function(part){
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
        },
        
        "<border-style>": function(part){
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
        },
        
        "<margin-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
        },
        
        "<padding-width>": function(part){
            return this["<length>"](part) || this["<percentage>"](part);
        },
        
        "<shape>": function(part){
            return part.type == "function" && (part.name == "rect" || part.name == "inset-rect");
        },
        
        "<time>": function(part) {
            return part.type == "time";
        }
    },
    
    complex: {

        "<bg-position>": function(expression){
            var types   = this,
                result  = false,
                numeric = "<percentage> | <length>",
                xDir    = "left | right",
                yDir    = "top | bottom",
                count = 0,
                hasNext = function() {
                    return expression.hasNext() && expression.peek() != ",";
                };

            while (expression.peek(count) && expression.peek(count) != ",") {
                count++;
            }
            
/*
<position> = [
  [ left | center | right | top | bottom | <percentage> | <length> ]
|
  [ left | center | right | <percentage> | <length> ]
  [ top | center | bottom | <percentage> | <length> ]
|
  [ center | [ left | right ] [ <percentage> | <length> ]? ] &&
  [ center | [ top | bottom ] [ <percentage> | <length> ]? ]
]
*/

            if (count < 3) {
                if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                        result = true;
                        ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
                } else if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, xDir + " | center");
                }
            } else {
                if (ValidationTypes.isAny(expression, xDir)) {
                    if (ValidationTypes.isAny(expression, yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, yDir)) {
                            result = true;
                            ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, yDir)) {
                    if (ValidationTypes.isAny(expression, xDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    } else if (ValidationTypes.isAny(expression, numeric)) {
                        if (ValidationTypes.isAny(expression, xDir)) {
                                result = true;
                                ValidationTypes.isAny(expression, numeric);
                        } else if (ValidationTypes.isAny(expression, "center")) {
                            result = true;
                        }
                    }
                } else if (ValidationTypes.isAny(expression, "center")) {
                    if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                        result = true;
                        ValidationTypes.isAny(expression, numeric);
                    }
                }
            }
            
            return result;
        },

        "<bg-size>": function(expression){
            //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain
            var types   = this,
                result  = false,
                numeric = "<percentage> | <length> | auto",
                part,
                i, len;      
      
            if (ValidationTypes.isAny(expression, "cover | contain")) {
                result = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
                result = true;                
                ValidationTypes.isAny(expression, numeric);
            }
            
            return result;
        },
        
        "<repeat-style>": function(expression){
            //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
            var result  = false,
                values  = "repeat | space | round | no-repeat",
                part;
            
            if (expression.hasNext()){
                part = expression.next();
                
                if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                    result = true;                    
                } else if (ValidationTypes.isLiteral(part, values)) {
                    result = true;

                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                        expression.next();
                    }
                }
            }
            
            return result;
            
        },
        
        "<shadow>": function(expression) {
            //inset? && [ <length>{2,4} && <color>? ]
            var result  = false,
                count   = 0,
                inset   = false,
                color   = false,
                part;
                
            if (expression.hasNext()) {            
                
                if (ValidationTypes.isAny(expression, "inset")){
                    inset = true;
                }
                
                if (ValidationTypes.isAny(expression, "<color>")) {
                    color = true;
                }                
                
                while (ValidationTypes.isAny(expression, "<length>") && count < 4) {
                    count++;
                }
                
                
                if (expression.hasNext()) {
                    if (!color) {
                        ValidationTypes.isAny(expression, "<color>");
                    }
                    
                    if (!inset) {
                        ValidationTypes.isAny(expression, "inset");
                    }

                }
                
                result = (count >= 2 && count <= 4);
            
            }
            
            return result;
        },
        
        "<x-one-radius>": function(expression) {
            //[ <length> | <percentage> ] [ <length> | <percentage> ]?
            var result  = false,
                count   = 0,
                numeric = "<length> | <percentage>",
                part;
                
            if (ValidationTypes.isAny(expression, numeric)){
                result = true;
                
                ValidationTypes.isAny(expression, numeric);
            }                
            
            return result;
        }
    }
};



parserlib.css = {
Colors              :Colors,
Combinator          :Combinator,
Parser              :Parser,
PropertyName        :PropertyName,
PropertyValue       :PropertyValue,
PropertyValuePart   :PropertyValuePart,
MediaFeature        :MediaFeature,
MediaQuery          :MediaQuery,
Selector            :Selector,
SelectorPart        :SelectorPart,
SelectorSubPart     :SelectorSubPart,
Specificity         :Specificity,
TokenStream         :TokenStream,
Tokens              :Tokens,
ValidationError     :ValidationError
};
})();


/**
 * Main CSSLint object.
 * @class CSSLint
 * @static
 * @extends parserlib.util.EventTarget
 */
/*global parserlib, Reporter*/
var CSSLint = (function(){

    var rules           = [],
        formatters      = [],
        embeddedRuleset = /\/\*csslint([^\*]*)\*\//,
        api             = new parserlib.util.EventTarget();

    api.version = "0.9.10";

    //-------------------------------------------------------------------------
    // Rule Management
    //-------------------------------------------------------------------------

    /**
     * Adds a new rule to the engine.
     * @param {Object} rule The rule to add.
     * @method addRule
     */
    api.addRule = function(rule){
        rules.push(rule);
        rules[rule.id] = rule;
    };

    /**
     * Clears all rule from the engine.
     * @method clearRules
     */
    api.clearRules = function(){
        rules = [];
    };

    /**
     * Returns the rule objects.
     * @return An array of rule objects.
     * @method getRules
     */
    api.getRules = function(){
        return [].concat(rules).sort(function(a,b){
            return a.id > b.id ? 1 : 0;
        });
    };

    /**
     * Returns a ruleset configuration object with all current rules.
     * @return A ruleset object.
     * @method getRuleset
     */
    api.getRuleset = function() {
        var ruleset = {},
            i = 0,
            len = rules.length;

        while (i < len){
            ruleset[rules[i++].id] = 1;    //by default, everything is a warning
        }

        return ruleset;
    };

    /**
     * Returns a ruleset object based on embedded rules.
     * @param {String} text A string of css containing embedded rules.
     * @param {Object} ruleset A ruleset object to modify.
     * @return {Object} A ruleset object.
     * @method getEmbeddedRuleset
     */
    function applyEmbeddedRuleset(text, ruleset){
        var valueMap,
            embedded = text && text.match(embeddedRuleset),
            rules = embedded && embedded[1];

        if (rules) {
            valueMap = {
                "true": 2,  // true is error
                "": 1,      // blank is warning
                "false": 0, // false is ignore

                "2": 2,     // explicit error
                "1": 1,     // explicit warning
                "0": 0      // explicit ignore
            };

            rules.toLowerCase().split(",").forEach(function(rule){
                var pair = rule.split(":"),
                    property = pair[0] || "",
                    value = pair[1] || "";

                ruleset[property.trim()] = valueMap[value.trim()];
            });
        }

        return ruleset;
    }

    //-------------------------------------------------------------------------
    // Formatters
    //-------------------------------------------------------------------------

    /**
     * Adds a new formatter to the engine.
     * @param {Object} formatter The formatter to add.
     * @method addFormatter
     */
    api.addFormatter = function(formatter) {
        // formatters.push(formatter);
        formatters[formatter.id] = formatter;
    };

    /**
     * Retrieves a formatter for use.
     * @param {String} formatId The name of the format to retrieve.
     * @return {Object} The formatter or undefined.
     * @method getFormatter
     */
    api.getFormatter = function(formatId){
        return formatters[formatId];
    };

    /**
     * Formats the results in a particular format for a single file.
     * @param {Object} result The results returned from CSSLint.verify().
     * @param {String} filename The filename for which the results apply.
     * @param {String} formatId The name of the formatter to use.
     * @param {Object} options (Optional) for special output handling.
     * @return {String} A formatted string for the results.
     * @method format
     */
    api.format = function(results, filename, formatId, options) {
        var formatter = this.getFormatter(formatId),
            result = null;

        if (formatter){
            result = formatter.startFormat();
            result += formatter.formatResults(results, filename, options || {});
            result += formatter.endFormat();
        }

        return result;
    };

    /**
     * Indicates if the given format is supported.
     * @param {String} formatId The ID of the format to check.
     * @return {Boolean} True if the format exists, false if not.
     * @method hasFormat
     */
    api.hasFormat = function(formatId){
        return formatters.hasOwnProperty(formatId);
    };

    //-------------------------------------------------------------------------
    // Verification
    //-------------------------------------------------------------------------

    /**
     * Starts the verification process for the given CSS text.
     * @param {String} text The CSS text to verify.
     * @param {Object} ruleset (Optional) List of rules to apply. If null, then
     *      all rules are used. If a rule has a value of 1 then it's a warning,
     *      a value of 2 means it's an error.
     * @return {Object} Results of the verification.
     * @method verify
     */
    api.verify = function(text, ruleset){

        var i       = 0,
            len     = rules.length,
            reporter,
            lines,
            report,
            parser = new parserlib.css.Parser({ starHack: true, ieFilters: true,
                                                underscoreHack: true, strict: false });

        // normalize line endings
        lines = text.replace(/\n\r?/g, "$split$").split('$split$');

        if (!ruleset){
            ruleset = this.getRuleset();
        }

        if (embeddedRuleset.test(text)){
            ruleset = applyEmbeddedRuleset(text, ruleset);
        }

        reporter = new Reporter(lines, ruleset);

        ruleset.errors = 2;       //always report parsing errors as errors
        for (i in ruleset){
            if(ruleset.hasOwnProperty(i) && ruleset[i]){
                if (rules[i]){
                    rules[i].init(parser, reporter);
                }
            }
        }


        //capture most horrible error type
        try {
            parser.parse(text);
        } catch (ex) {
            reporter.error("Fatal error, cannot continue: " + ex.message, ex.line, ex.col, {});
        }

        report = {
            messages    : reporter.messages,
            stats       : reporter.stats,
            ruleset     : reporter.ruleset
        };

        //sort by line numbers, rollups at the bottom
        report.messages.sort(function (a, b){
            if (a.rollup && !b.rollup){
                return 1;
            } else if (!a.rollup && b.rollup){
                return -1;
            } else {
                return a.line - b.line;
            }
        });

        return report;
    };

    //-------------------------------------------------------------------------
    // Publish the API
    //-------------------------------------------------------------------------

    return api;

})();
/*global CSSLint*/
/**
 * An instance of Report is used to report results of the
 * verification back to the main API.
 * @class Reporter
 * @constructor
 * @param {String[]} lines The text lines of the source.
 * @param {Object} ruleset The set of rules to work with, including if
 *      they are errors or warnings.
 */
function Reporter(lines, ruleset){

    /**
     * List of messages being reported.
     * @property messages
     * @type String[]
     */
    this.messages = [];

    /**
     * List of statistics being reported.
     * @property stats
     * @type String[]
     */
    this.stats = [];

    /**
     * Lines of code being reported on. Used to provide contextual information
     * for messages.
     * @property lines
     * @type String[]
     */
    this.lines = lines;
    
    /**
     * Information about the rules. Used to determine whether an issue is an
     * error or warning.
     * @property ruleset
     * @type Object
     */
    this.ruleset = ruleset;
}

Reporter.prototype = {

    //restore constructor
    constructor: Reporter,

    /**
     * Report an error.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method error
     */
    error: function(message, line, col, rule){
        this.messages.push({
            type    : "error",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule || {}
        });
    },

    /**
     * Report an warning.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method warn
     * @deprecated Use report instead.
     */
    warn: function(message, line, col, rule){
        this.report(message, line, col, rule);
    },

    /**
     * Report an issue.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method report
     */
    report: function(message, line, col, rule){
        this.messages.push({
            type    : this.ruleset[rule.id] == 2 ? "error" : "warning",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },

    /**
     * Report some informational text.
     * @param {String} message The message to store.
     * @param {int} line The line number.
     * @param {int} col The column number.
     * @param {Object} rule The rule this message relates to.
     * @method info
     */
    info: function(message, line, col, rule){
        this.messages.push({
            type    : "info",
            line    : line,
            col     : col,
            message : message,
            evidence: this.lines[line-1],
            rule    : rule
        });
    },

    /**
     * Report some rollup error information.
     * @param {String} message The message to store.
     * @param {Object} rule The rule this message relates to.
     * @method rollupError
     */
    rollupError: function(message, rule){
        this.messages.push({
            type    : "error",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },

    /**
     * Report some rollup warning information.
     * @param {String} message The message to store.
     * @param {Object} rule The rule this message relates to.
     * @method rollupWarn
     */
    rollupWarn: function(message, rule){
        this.messages.push({
            type    : "warning",
            rollup  : true,
            message : message,
            rule    : rule
        });
    },

    /**
     * Report a statistic.
     * @param {String} name The name of the stat to store.
     * @param {Variant} value The value of the stat.
     * @method stat
     */
    stat: function(name, value){
        this.stats[name] = value;
    }
};

//expose for testing purposes
CSSLint._Reporter = Reporter;

/*global CSSLint*/

/*
 * Utility functions that make life easier.
 */
CSSLint.Util = {
    /*
     * Adds all properties from supplier onto receiver,
     * overwriting if the same name already exists on
     * reciever.
     * @param {Object} The object to receive the properties.
     * @param {Object} The object to provide the properties.
     * @return {Object} The receiver
     */
    mix: function(receiver, supplier){
        var prop;

        for (prop in supplier){
            if (supplier.hasOwnProperty(prop)){
                receiver[prop] = supplier[prop];
            }
        }

        return prop;
    },

    /*
     * Polyfill for array indexOf() method.
     * @param {Array} values The array to search.
     * @param {Variant} value The value to search for.
     * @return {int} The index of the value if found, -1 if not.
     */
    indexOf: function(values, value){
        if (values.indexOf){
            return values.indexOf(value);
        } else {
            for (var i=0, len=values.length; i < len; i++){
                if (values[i] === value){
                    return i;
                }
            }
            return -1;
        }
    },

    /*
     * Polyfill for array forEach() method.
     * @param {Array} values The array to operate on.
     * @param {Function} func The function to call on each item.
     * @return {void}
     */
    forEach: function(values, func) {
        if (values.forEach){
            return values.forEach(func);
        } else {
            for (var i=0, len=values.length; i < len; i++){
                func(values[i], i, values);
            }
        }
    }
};
/*global CSSLint*/
/*
 * Rule: Don't use adjoining classes (.foo.bar).
 */
CSSLint.addRule({

    //rule information
    id: "adjoining-classes",
    name: "Disallow adjoining classes",
    desc: "Don't use adjoining classes.",
    browsers: "IE6",

    //initialization
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                classCount,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type == parser.SELECTOR_PART_TYPE){
                        classCount = 0;
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type == "class"){
                                classCount++;
                            }
                            if (classCount > 1){
                                reporter.report("Don't use adjoining classes.", part.line, part.col, rule);
                            }
                        }
                    }
                }
            }
        });
    }

});
/*global CSSLint*/

/*
 * Rule: Don't use width or height when using padding or border. 
 */
CSSLint.addRule({

    //rule information
    id: "box-model",
    name: "Beware of broken box size",
    desc: "Don't use width or height when using padding or border.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            widthProperties = {
                border: 1,
                "border-left": 1,
                "border-right": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1
            },
            heightProperties = {
                border: 1,
                "border-bottom": 1,
                "border-top": 1,
                padding: 1,
                "padding-bottom": 1,
                "padding-top": 1
            },
            properties,
            boxSizing = false;

        function startRule(){
            properties = {};
            boxSizing = false;
        }

        function endRule(){
            var prop, value;
            
            if (!boxSizing) {
                if (properties.height){
                    for (prop in heightProperties){
                        if (heightProperties.hasOwnProperty(prop) && properties[prop]){
                            value = properties[prop].value;
                            //special case for padding
                            if (!(prop == "padding" && value.parts.length === 2 && value.parts[0].value === 0)){
                                reporter.report("Using height with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }

                if (properties.width){
                    for (prop in widthProperties){
                        if (widthProperties.hasOwnProperty(prop) && properties[prop]){
                            value = properties[prop].value;
                            
                            if (!(prop == "padding" && value.parts.length === 2 && value.parts[1].value === 0)){
                                reporter.report("Using width with " + prop + " can sometimes make elements larger than you expect.", properties[prop].line, properties[prop].col, rule);
                            }
                        }
                    }
                }   
            }     
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule); 

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();
            
            if (heightProperties[name] || widthProperties[name]){
                if (!/^0\S*$/.test(event.value) && !(name == "border" && event.value == "none")){
                    properties[name] = { line: event.property.line, col: event.property.col, value: event.value };
                }
            } else {
                if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)){
                    properties[name] = 1;
                } else if (name == "box-sizing") {
                    boxSizing = true;
                }
            }
            
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);         
    }

});
/*global CSSLint*/

/*
 * Rule: box-sizing doesn't work in IE6 and IE7.
 */
CSSLint.addRule({

    //rule information
    id: "box-sizing",
    name: "Disallow use of box-sizing",
    desc: "The box-sizing properties isn't supported in IE6 and IE7.",
    browsers: "IE6, IE7",
    tags: ["Compatibility"],

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();
   
            if (name == "box-sizing"){
                reporter.report("The box-sizing property isn't supported in IE6 and IE7.", event.line, event.col, rule);
            }
        });       
    }

});
/*
 * Rule: Use the bulletproof @font-face syntax to avoid 404's in old IE
 * (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "bulletproof-font-face",
    name: "Use the bulletproof @font-face syntax",
    desc: "Use the bulletproof @font-face syntax to avoid 404's in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            count = 0,
            fontFaceRule = false,
            firstSrc     = true,
            ruleFailed    = false,
            line, col;

        // Mark the start of a @font-face declaration so we only test properties inside it
        parser.addListener("startfontface", function(event){
            fontFaceRule = true;
        });

        parser.addListener("property", function(event){
            // If we aren't inside an @font-face declaration then just return
            if (!fontFaceRule) {
                return;
            }

            var propertyName = event.property.toString().toLowerCase(),
                value        = event.value.toString();

            // Set the line and col numbers for use in the endfontface listener
            line = event.line;
            col  = event.col;

            // This is the property that we care about, we can ignore the rest
            if (propertyName === 'src') {
                var regex = /^\s?url\(['"].+\.eot\?.*['"]\)\s*format\(['"]embedded-opentype['"]\).*$/i;

                // We need to handle the advanced syntax with two src properties
                if (!value.match(regex) && firstSrc) {
                    ruleFailed = true;
                    firstSrc = false;
                } else if (value.match(regex) && !firstSrc) {
                    ruleFailed = false;
                }
            }


        });

        // Back to normal rules that we don't need to test
        parser.addListener("endfontface", function(event){
            fontFaceRule = false;

            if (ruleFailed) {
                reporter.report("@font-face declaration doesn't follow the fontspring bulletproof syntax.", line, col, rule);
            }
        });
    }
});
/*
 * Rule: Include all compatible vendor prefixes to reach a wider
 * range of users.
 */
/*global CSSLint*/ 
CSSLint.addRule({

    //rule information
    id: "compatible-vendor-prefixes",
    name: "Require compatible vendor prefixes",
    desc: "Include all compatible vendor prefixes to reach a wider range of users.",
    browsers: "All",

    //initialization
    init: function (parser, reporter) {
        var rule = this,
            compatiblePrefixes,
            properties,
            prop,
            variations,
            prefixed,
            i,
            len,
            inKeyFrame = false,
            arrayPush = Array.prototype.push,
            applyTo = [];

        // See http://peter.sh/experiments/vendor-prefixed-css-property-overview/ for details
        compatiblePrefixes = {
            "animation"                  : "webkit moz",
            "animation-delay"            : "webkit moz",
            "animation-direction"        : "webkit moz",
            "animation-duration"         : "webkit moz",
            "animation-fill-mode"        : "webkit moz",
            "animation-iteration-count"  : "webkit moz",
            "animation-name"             : "webkit moz",
            "animation-play-state"       : "webkit moz",
            "animation-timing-function"  : "webkit moz",
            "appearance"                 : "webkit moz",
            "border-end"                 : "webkit moz",
            "border-end-color"           : "webkit moz",
            "border-end-style"           : "webkit moz",
            "border-end-width"           : "webkit moz",
            "border-image"               : "webkit moz o",
            "border-radius"              : "webkit",
            "border-start"               : "webkit moz",
            "border-start-color"         : "webkit moz",
            "border-start-style"         : "webkit moz",
            "border-start-width"         : "webkit moz",
            "box-align"                  : "webkit moz ms",
            "box-direction"              : "webkit moz ms",
            "box-flex"                   : "webkit moz ms",
            "box-lines"                  : "webkit ms",
            "box-ordinal-group"          : "webkit moz ms",
            "box-orient"                 : "webkit moz ms",
            "box-pack"                   : "webkit moz ms",
            "box-sizing"                 : "webkit moz",
            "box-shadow"                 : "webkit moz",
            "column-count"               : "webkit moz ms",
            "column-gap"                 : "webkit moz ms",
            "column-rule"                : "webkit moz ms",
            "column-rule-color"          : "webkit moz ms",
            "column-rule-style"          : "webkit moz ms",
            "column-rule-width"          : "webkit moz ms",
            "column-width"               : "webkit moz ms",
            "hyphens"                    : "epub moz",
            "line-break"                 : "webkit ms",
            "margin-end"                 : "webkit moz",
            "margin-start"               : "webkit moz",
            "marquee-speed"              : "webkit wap",
            "marquee-style"              : "webkit wap",
            "padding-end"                : "webkit moz",
            "padding-start"              : "webkit moz",
            "tab-size"                   : "moz o",
            "text-size-adjust"           : "webkit ms",
            "transform"                  : "webkit moz ms o",
            "transform-origin"           : "webkit moz ms o",
            "transition"                 : "webkit moz o",
            "transition-delay"           : "webkit moz o",
            "transition-duration"        : "webkit moz o",
            "transition-property"        : "webkit moz o",
            "transition-timing-function" : "webkit moz o",
            "user-modify"                : "webkit moz",
            "user-select"                : "webkit moz ms",
            "word-break"                 : "epub ms",
            "writing-mode"               : "epub ms"
        };


        for (prop in compatiblePrefixes) {
            if (compatiblePrefixes.hasOwnProperty(prop)) {
                variations = [];
                prefixed = compatiblePrefixes[prop].split(' ');
                for (i = 0, len = prefixed.length; i < len; i++) {
                    variations.push('-' + prefixed[i] + '-' + prop);
                }
                compatiblePrefixes[prop] = variations;
                arrayPush.apply(applyTo, variations);
            }
        }
                
        parser.addListener("startrule", function () {
            properties = [];
        });

        parser.addListener("startkeyframes", function (event) {
            inKeyFrame = event.prefix || true;
        });

        parser.addListener("endkeyframes", function (event) {
            inKeyFrame = false;
        });

        parser.addListener("property", function (event) {
            var name = event.property;
            if (CSSLint.Util.indexOf(applyTo, name.text) > -1) {
            
                // e.g., -moz-transform is okay to be alone in @-moz-keyframes
                if (!inKeyFrame || typeof inKeyFrame != "string" || 
                        name.text.indexOf("-" + inKeyFrame + "-") !== 0) {
                    properties.push(name);
                }
            }
        });

        parser.addListener("endrule", function (event) {
            if (!properties.length) {
                return;
            }

            var propertyGroups = {},
                i,
                len,
                name,
                prop,
                variations,
                value,
                full,
                actual,
                item,
                propertiesSpecified;

            for (i = 0, len = properties.length; i < len; i++) {
                name = properties[i];

                for (prop in compatiblePrefixes) {
                    if (compatiblePrefixes.hasOwnProperty(prop)) {
                        variations = compatiblePrefixes[prop];
                        if (CSSLint.Util.indexOf(variations, name.text) > -1) {
                            if (!propertyGroups[prop]) {
                                propertyGroups[prop] = {
                                    full : variations.slice(0),
                                    actual : [],
                                    actualNodes: []
                                };
                            }
                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {
                                propertyGroups[prop].actual.push(name.text);
                                propertyGroups[prop].actualNodes.push(name);
                            }
                        }
                    }
                }
            }

            for (prop in propertyGroups) {
                if (propertyGroups.hasOwnProperty(prop)) {
                    value = propertyGroups[prop];
                    full = value.full;
                    actual = value.actual;

                    if (full.length > actual.length) {
                        for (i = 0, len = full.length; i < len; i++) {
                            item = full[i];
                            if (CSSLint.Util.indexOf(actual, item) === -1) {
                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length == 2) ? actual.join(" and ") : actual.join(", ");
                                reporter.report("The property " + item + " is compatible with " + propertiesSpecified + " and should be included as well.", value.actualNodes[0].line, value.actualNodes[0].col, rule); 
                            }
                        }

                    }
                }
            }
        });
    }
});
/*
 * Rule: Certain properties don't play well with certain display values. 
 * - float should not be used with inline-block
 * - height, width, margin-top, margin-bottom, float should not be used with inline
 * - vertical-align should not be used with block
 * - margin, float should not be used with table-*
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "display-property-grouping",
    name: "Require properties appropriate for display",
    desc: "Certain properties shouldn't be used with certain display property values.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        var propertiesToCheck = {
                display: 1,
                "float": "none",
                height: 1,
                width: 1,
                margin: 1,
                "margin-left": 1,
                "margin-right": 1,
                "margin-bottom": 1,
                "margin-top": 1,
                padding: 1,
                "padding-left": 1,
                "padding-right": 1,
                "padding-bottom": 1,
                "padding-top": 1,
                "vertical-align": 1
            },
            properties;

        function reportProperty(name, display, msg){
            if (properties[name]){
                if (typeof propertiesToCheck[name] != "string" || properties[name].value.toLowerCase() != propertiesToCheck[name]){
                    reporter.report(msg || name + " can't be used with display: " + display + ".", properties[name].line, properties[name].col, rule);
                }
            }
        }
        
        function startRule(){
            properties = {};
        }

        function endRule(){

            var display = properties.display ? properties.display.value : null;
            if (display){
                switch(display){

                    case "inline":
                        //height, width, margin-top, margin-bottom, float should not be used with inline
                        reportProperty("height", display);
                        reportProperty("width", display);
                        reportProperty("margin", display);
                        reportProperty("margin-top", display);
                        reportProperty("margin-bottom", display);              
                        reportProperty("float", display, "display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).");
                        break;

                    case "block":
                        //vertical-align should not be used with block
                        reportProperty("vertical-align", display);
                        break;

                    case "inline-block":
                        //float should not be used with inline-block
                        reportProperty("float", display);
                        break;

                    default:
                        //margin, float should not be used with table
                        if (display.indexOf("table-") === 0){
                            reportProperty("margin", display);
                            reportProperty("margin-left", display);
                            reportProperty("margin-right", display);
                            reportProperty("margin-top", display);
                            reportProperty("margin-bottom", display);
                            reportProperty("float", display);
                        }

                        //otherwise do nothing
                }
            }
          
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startkeyframerule", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startpage", startRule);

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (propertiesToCheck[name]){
                properties[name] = { value: event.value.text, line: event.property.line, col: event.property.col };                    
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endkeyframerule", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endpage", endRule);

    }

});
/*
 * Rule: Disallow duplicate background-images (using url).
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "duplicate-background-images",
    name: "Disallow duplicate background images",
    desc: "Every background-image should be unique. Use a common class for e.g. sprites.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            stack = {};

        parser.addListener("property", function(event){
            var name = event.property.text,
                value = event.value,
                i, len;

            if (name.match(/background/i)) {
                for (i=0, len=value.parts.length; i < len; i++) {
                    if (value.parts[i].type == 'uri') {
                        if (typeof stack[value.parts[i].uri] === 'undefined') {
                            stack[value.parts[i].uri] = event;
                        }
                        else {
                            reporter.report("Background image '" + value.parts[i].uri + "' was used multiple times, first declared at line " + stack[value.parts[i].uri].line + ", col " + stack[value.parts[i].uri].col + ".", event.line, event.col, rule);
                        }
                    }
                }
            }
        });
    }
});
/*
 * Rule: Duplicate properties must appear one after the other. If an already-defined
 * property appears somewhere else in the rule, then it's likely an error.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "duplicate-properties",
    name: "Disallow duplicate properties",
    desc: "Duplicate properties must appear one after the other.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            properties,
            lastProperty;            
            
        function startRule(event){
            properties = {};        
        }
        
        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);        
        
        parser.addListener("property", function(event){
            var property = event.property,
                name = property.text.toLowerCase();
            
            if (properties[name] && (lastProperty != name || properties[name] == event.value.text)){
                reporter.report("Duplicate property '" + event.property + "' found.", event.line, event.col, rule);
            }
            
            properties[name] = event.value.text;
            lastProperty = name;
                        
        });
            
        
    }

});
/*
 * Rule: Style rules without any properties defined should be removed.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "empty-rules",
    name: "Disallow empty rules",
    desc: "Rules without any properties specified should be removed.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            count = 0;

        parser.addListener("startrule", function(){
            count=0;
        });

        parser.addListener("property", function(){
            count++;
        });

        parser.addListener("endrule", function(event){
            var selectors = event.selectors;
            if (count === 0){
                reporter.report("Rule is empty.", selectors[0].line, selectors[0].col, rule);
            }
        });
    }

});
/*
 * Rule: There should be no syntax errors. (Duh.)
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "errors",
    name: "Parsing Errors",
    desc: "This rule looks for recoverable syntax errors.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("error", function(event){
            reporter.error(event.message, event.line, event.col, rule);
        });

    }

});

/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "fallback-colors",
    name: "Require fallback colors",
    desc: "For older browsers that don't support RGBA, HSL, or HSLA, provide a fallback color.",
    browsers: "IE6,IE7,IE8",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            lastProperty,
            propertiesToCheck = {
                color: 1,
                background: 1,
                "border-color": 1,
                "border-top-color": 1,
                "border-right-color": 1,
                "border-bottom-color": 1,
                "border-left-color": 1,
                border: 1,
                "border-top": 1,
                "border-right": 1,
                "border-bottom": 1,
                "border-left": 1,
                "background-color": 1
            },
            properties;
        
        function startRule(event){
            properties = {};    
            lastProperty = null;    
        }
        
        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);        
        
        parser.addListener("property", function(event){
            var property = event.property,
                name = property.text.toLowerCase(),
                parts = event.value.parts,
                i = 0, 
                colorType = "",
                len = parts.length;                
                        
            if(propertiesToCheck[name]){
                while(i < len){
                    if (parts[i].type == "color"){
                        if ("alpha" in parts[i] || "hue" in parts[i]){
                            
                            if (/([^\)]+)\(/.test(parts[i])){
                                colorType = RegExp.$1.toUpperCase();
                            }
                            
                            if (!lastProperty || (lastProperty.property.text.toLowerCase() != name || lastProperty.colorType != "compat")){
                                reporter.report("Fallback " + name + " (hex or RGB) should precede " + colorType + " " + name + ".", event.line, event.col, rule);
                            }
                        } else {
                            event.colorType = "compat";
                        }
                    }
                    
                    i++;
                }
            }

            lastProperty = event;
        });        
         
    }

});
/*
 * Rule: You shouldn't use more than 10 floats. If you do, there's probably
 * room for some abstraction.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "floats",
    name: "Disallow too many floats",
    desc: "This rule tests if the float property is used too many times",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;
        var count = 0;

        //count how many times "float" is used
        parser.addListener("property", function(event){
            if (event.property.text.toLowerCase() == "float" &&
                    event.value.text.toLowerCase() != "none"){
                count++;
            }
        });

        //report the results
        parser.addListener("endstylesheet", function(){
            reporter.stat("floats", count);
            if (count >= 10){
                reporter.rollupWarn("Too many floats (" + count + "), you're probably using them for layout. Consider using a grid system instead.", rule);
            }
        });
    }

});
/*
 * Rule: Avoid too many @font-face declarations in the same stylesheet.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "font-faces",
    name: "Don't use too many web fonts",
    desc: "Too many different web fonts in the same stylesheet.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            count = 0;


        parser.addListener("startfontface", function(){
            count++;
        });

        parser.addListener("endstylesheet", function(){
            if (count > 5){
                reporter.rollupWarn("Too many @font-face declarations (" + count + ").", rule);
            }
        });
    }

});
/*
 * Rule: You shouldn't need more than 9 font-size declarations.
 */

/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "font-sizes",
    name: "Disallow too many font sizes",
    desc: "Checks the number of font-size declarations.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            count = 0;

        //check for use of "font-size"
        parser.addListener("property", function(event){
            if (event.property == "font-size"){
                count++;
            }
        });

        //report the results
        parser.addListener("endstylesheet", function(){
            reporter.stat("font-sizes", count);
            if (count >= 10){
                reporter.rollupWarn("Too many font-size declarations (" + count + "), abstraction needed.", rule);
            }
        });
    }

});
/*
 * Rule: When using a vendor-prefixed gradient, make sure to use them all.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "gradients",
    name: "Require all gradient definitions",
    desc: "When using a vendor-prefixed gradient, make sure to use them all.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            gradients;

        parser.addListener("startrule", function(){
            gradients = {
                moz: 0,
                webkit: 0,
                oldWebkit: 0,
                o: 0
            };
        });

        parser.addListener("property", function(event){

            if (/\-(moz|o|webkit)(?:\-(?:linear|radial))\-gradient/i.test(event.value)){
                gradients[RegExp.$1] = 1;
            } else if (/\-webkit\-gradient/i.test(event.value)){
                gradients.oldWebkit = 1;
            }

        });

        parser.addListener("endrule", function(event){
            var missing = [];

            if (!gradients.moz){
                missing.push("Firefox 3.6+");
            }

            if (!gradients.webkit){
                missing.push("Webkit (Safari 5+, Chrome)");
            }
            
            if (!gradients.oldWebkit){
                missing.push("Old Webkit (Safari 4+, Chrome)");
            }

            if (!gradients.o){
                missing.push("Opera 11.1+");
            }

            if (missing.length && missing.length < 4){            
                reporter.report("Missing vendor-prefixed CSS gradients for " + missing.join(", ") + ".", event.selectors[0].line, event.selectors[0].col, rule); 
            }

        });

    }

});
/*
 * Rule: Don't use IDs for selectors.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "ids",
    name: "Disallow IDs in selectors",
    desc: "Selectors should not contain IDs.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                idCount,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                idCount = 0;

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type == parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type == "id"){
                                idCount++;
                            }
                        }
                    }
                }

                if (idCount == 1){
                    reporter.report("Don't use IDs in selectors.", selector.line, selector.col, rule);
                } else if (idCount > 1){
                    reporter.report(idCount + " IDs in the selector, really?", selector.line, selector.col, rule);
                }
            }

        });
    }

});
/*
 * Rule: Don't use @import, use <link> instead.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "import",
    name: "Disallow @import",
    desc: "Don't use @import, use <link> instead.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;
        
        parser.addListener("import", function(event){        
            reporter.report("@import prevents parallel downloads, use <link> instead.", event.line, event.col, rule);
        });

    }

});
/*
 * Rule: Make sure !important is not overused, this could lead to specificity
 * war. Display a warning on !important declarations, an error if it's
 * used more at least 10 times.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "important",
    name: "Disallow !important",
    desc: "Be careful when using !important declaration",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            count = 0;

        //warn that important is used and increment the declaration counter
        parser.addListener("property", function(event){
            if (event.important === true){
                count++;
                reporter.report("Use of !important", event.line, event.col, rule);
            }
        });

        //if there are more than 10, show an error
        parser.addListener("endstylesheet", function(){
            reporter.stat("important", count);
            if (count >= 10){
                reporter.rollupWarn("Too many !important declarations (" + count + "), try to use less than 10 to avoid specificity issues.", rule);
            }
        });
    }

});
/*
 * Rule: Properties should be known (listed in CSS3 specification) or
 * be a vendor-prefixed property.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "known-properties",
    name: "Require use of known properties",
    desc: "Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            // the check is handled entirely by the parser-lib (https://github.com/nzakas/parser-lib)
            if (event.invalid) {
                reporter.report(event.invalid.message, event.line, event.col, rule);
            }

        });
    }

});
/*
 * Rule: outline: none or outline: 0 should only be used in a :focus rule
 *       and only if there are other properties in the same rule.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "outline-none",
    name: "Disallow outline: none",
    desc: "Use of outline: none or outline: 0 should be limited to :focus rules.",
    browsers: "All",
    tags: ["Accessibility"],

    //initialization
    init: function(parser, reporter){
        var rule = this,
            lastRule;

        function startRule(event){
            if (event.selectors){
                lastRule = {
                    line: event.line,
                    col: event.col,
                    selectors: event.selectors,
                    propCount: 0,
                    outline: false
                };
            } else {
                lastRule = null;
            }
        }
        
        function endRule(event){
            if (lastRule){
                if (lastRule.outline){
                    if (lastRule.selectors.toString().toLowerCase().indexOf(":focus") == -1){
                        reporter.report("Outlines should only be modified using :focus.", lastRule.line, lastRule.col, rule);
                    } else if (lastRule.propCount == 1) {
                        reporter.report("Outlines shouldn't be hidden unless other visual changes are made.", lastRule.line, lastRule.col, rule);                        
                    }
                }
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule); 

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase(),
                value = event.value;                
                
            if (lastRule){
                lastRule.propCount++;
                if (name == "outline" && (value == "none" || value == "0")){
                    lastRule.outline = true;
                }            
            }
            
        });
        
        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule); 

    }

});
/*
 * Rule: Don't use classes or IDs with elements (a.foo or a#foo).
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "overqualified-elements",
    name: "Disallow overqualified elements",
    desc: "Don't use classes or IDs with elements (a.foo or a#foo).",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            classes = {};
            
        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type == parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (part.elementName && modifier.type == "id"){
                                reporter.report("Element (" + part + ") is overqualified, just use " + modifier + " without element name.", part.line, part.col, rule);
                            } else if (modifier.type == "class"){
                                
                                if (!classes[modifier]){
                                    classes[modifier] = [];
                                }
                                classes[modifier].push({ modifier: modifier, part: part });
                            }
                        }
                    }
                }
            }
        });
        
        parser.addListener("endstylesheet", function(){
        
            var prop;
            for (prop in classes){
                if (classes.hasOwnProperty(prop)){
                
                    //one use means that this is overqualified
                    if (classes[prop].length == 1 && classes[prop][0].part.elementName){
                        reporter.report("Element (" + classes[prop][0].part + ") is overqualified, just use " + classes[prop][0].modifier + " without element name.", classes[prop][0].part.line, classes[prop][0].part.col, rule);
                    }
                }
            }        
        });
    }

});
/*
 * Rule: Headings (h1-h6) should not be qualified (namespaced).
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "qualified-headings",
    name: "Disallow qualified headings",
    desc: "Headings should not be qualified (namespaced).",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                i, j;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];

                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type == parser.SELECTOR_PART_TYPE){
                        if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j > 0){
                            reporter.report("Heading (" + part.elementName + ") should not be qualified.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });
    }

});
/*
 * Rule: Selectors that look like regular expressions are slow and should be avoided.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "regex-selectors",
    name: "Disallow selectors that look like regexs",
    desc: "Selectors that look like regular expressions are slow and should be avoided.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                for (j=0; j < selector.parts.length; j++){
                    part = selector.parts[j];
                    if (part.type == parser.SELECTOR_PART_TYPE){
                        for (k=0; k < part.modifiers.length; k++){
                            modifier = part.modifiers[k];
                            if (modifier.type == "attribute"){
                                if (/([\~\|\^\$\*]=)/.test(modifier)){
                                    reporter.report("Attribute selectors with " + RegExp.$1 + " are slow!", modifier.line, modifier.col, rule);
                                }
                            }

                        }
                    }
                }
            }
        });
    }

});
/*
 * Rule: Total number of rules should not exceed x.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "rules-count",
    name: "Rules Count",
    desc: "Track how many rules there are.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            count = 0;

        //count each rule
        parser.addListener("startrule", function(){
            count++;
        });

        parser.addListener("endstylesheet", function(){
            reporter.stat("rule-count", count);
        });
    }

});
/*
 * Rule: Warn people with approaching the IE 4095 limit 
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "selector-max-approaching",
    name: "Warn when approaching the 4095 selector limit for IE",
    desc: "Will warn when selector count is >= 3800 selectors.",
    browsers: "IE",

    //initialization
    init: function(parser, reporter) {
        var rule = this, count = 0;

        parser.addListener('startrule', function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count >= 3800) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule); 
            }
        });
    }

});
/*
 * Rule: Warn people past the IE 4095 limit 
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "selector-max",
    name: "Error when past the 4095 selector limit for IE",
    desc: "Will error when selector count is > 4095.",
    browsers: "IE",

    //initialization
    init: function(parser, reporter){
        var rule = this, count = 0;

        parser.addListener('startrule',function(event) {
            count += event.selectors.length;
        });

        parser.addListener("endstylesheet", function() {
            if (count > 4095) {
                reporter.report("You have " + count + " selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.",0,0,rule); 
            }
        });
    }

});
/*
 * Rule: Use shorthand properties where possible.
 * 
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "shorthand",
    name: "Require shorthand properties",
    desc: "Use shorthand properties where possible.",
    browsers: "All",
    
    //initialization
    init: function(parser, reporter){
        var rule = this,
            prop, i, len,
            propertiesToCheck = {},
            properties,
            mapping = {
                "margin": [
                    "margin-top",
                    "margin-bottom",
                    "margin-left",
                    "margin-right"
                ],
                "padding": [
                    "padding-top",
                    "padding-bottom",
                    "padding-left",
                    "padding-right"
                ]              
            };
            
        //initialize propertiesToCheck 
        for (prop in mapping){
            if (mapping.hasOwnProperty(prop)){
                for (i=0, len=mapping[prop].length; i < len; i++){
                    propertiesToCheck[mapping[prop][i]] = prop;
                }
            }
        }
            
        function startRule(event){
            properties = {};
        }
        
        //event handler for end of rules
        function endRule(event){
            
            var prop, i, len, total;
            
            //check which properties this rule has
            for (prop in mapping){
                if (mapping.hasOwnProperty(prop)){
                    total=0;
                    
                    for (i=0, len=mapping[prop].length; i < len; i++){
                        total += properties[mapping[prop][i]] ? 1 : 0;
                    }
                    
                    if (total == mapping[prop].length){
                        reporter.report("The properties " + mapping[prop].join(", ") + " can be replaced by " + prop + ".", event.line, event.col, rule);
                    }
                }
            }
        }        
        
        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
    
        //check for use of "font-size"
        parser.addListener("property", function(event){
            var name = event.property.toString().toLowerCase(),
                value = event.value.parts[0].value;

            if (propertiesToCheck[name]){
                properties[name] = 1;
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);     

    }

});
/*
 * Rule: Don't use properties with a star prefix.
 *
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "star-property-hack",
    name: "Disallow properties with a star prefix",
    desc: "Checks for the star property hack (targets IE6/7)",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        //check if property name starts with "*"
        parser.addListener("property", function(event){
            var property = event.property;

            if (property.hack == "*") {
                reporter.report("Property with star prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});
/*
 * Rule: Don't use text-indent for image replacement if you need to support rtl.
 *
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "text-indent",
    name: "Disallow negative text-indent",
    desc: "Checks for text indent less than -99px",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            textIndent,
            direction;


        function startRule(event){
            textIndent = false;
            direction = "inherit";
        }

        //event handler for end of rules
        function endRule(event){
            if (textIndent && direction != "ltr"){
                reporter.report("Negative text-indent doesn't work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.", textIndent.line, textIndent.col, rule);
            }
        }

        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);

        //check for use of "font-size"
        parser.addListener("property", function(event){
            var name = event.property.toString().toLowerCase(),
                value = event.value;

            if (name == "text-indent" && value.parts[0].value < -99){
                textIndent = event.property;
            } else if (name == "direction" && value == "ltr"){
                direction = "ltr";
            }
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);

    }

});
/*
 * Rule: Don't use properties with a underscore prefix.
 *
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "underscore-property-hack",
    name: "Disallow properties with an underscore prefix",
    desc: "Checks for the underscore property hack (targets IE6)",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        //check if property name starts with "_"
        parser.addListener("property", function(event){
            var property = event.property;

            if (property.hack == "_") {
                reporter.report("Property with underscore prefix found.", event.property.line, event.property.col, rule);
            }
        });
    }
});
/*
 * Rule: Headings (h1-h6) should be defined only once.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "unique-headings",
    name: "Headings should only be defined once",
    desc: "Headings should be defined only once.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        var headings =  {
                h1: 0,
                h2: 0,
                h3: 0,
                h4: 0,
                h5: 0,
                h6: 0
            };

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                pseudo,
                i, j;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                part = selector.parts[selector.parts.length-1];

                if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())){
                    
                    for (j=0; j < part.modifiers.length; j++){
                        if (part.modifiers[j].type == "pseudo"){
                            pseudo = true;
                            break;
                        }
                    }
                
                    if (!pseudo){
                        headings[RegExp.$1]++;
                        if (headings[RegExp.$1] > 1) {
                            reporter.report("Heading (" + part.elementName + ") has already been defined.", part.line, part.col, rule);
                        }
                    }
                }
            }
        });
        
        parser.addListener("endstylesheet", function(event){
            var prop,
                messages = [];
                
            for (prop in headings){
                if (headings.hasOwnProperty(prop)){
                    if (headings[prop] > 1){
                        messages.push(headings[prop] + " " + prop + "s");
                    }
                }
            }
            
            if (messages.length){
                reporter.rollupWarn("You have " + messages.join(", ") + " defined in this stylesheet.", rule);
            }
        });        
    }

});
/*
 * Rule: Don't use universal selector because it's slow.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "universal-selector",
    name: "Disallow universal selector",
    desc: "The universal selector (*) is known to be slow.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                
                part = selector.parts[selector.parts.length-1];
                if (part.elementName == "*"){
                    reporter.report(rule.desc, part.line, part.col, rule);
                }
            }
        });
    }

});
/*
 * Rule: Don't use unqualified attribute selectors because they're just like universal selectors.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "unqualified-attributes",
    name: "Disallow unqualified attribute selectors",
    desc: "Unqualified attribute selectors are known to be slow.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        parser.addListener("startrule", function(event){
            
            var selectors = event.selectors,
                selector,
                part,
                modifier,
                i, j, k;

            for (i=0; i < selectors.length; i++){
                selector = selectors[i];
                
                part = selector.parts[selector.parts.length-1];
                if (part.type == parser.SELECTOR_PART_TYPE){
                    for (k=0; k < part.modifiers.length; k++){
                        modifier = part.modifiers[k];
                        if (modifier.type == "attribute" && (!part.elementName || part.elementName == "*")){
                            reporter.report(rule.desc, part.line, part.col, rule);                               
                        }
                    }
                }
                
            }            
        });
    }

});
/*
 * Rule: When using a vendor-prefixed property, make sure to
 * include the standard one.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "vendor-prefix",
    name: "Require standard property with vendor prefix",
    desc: "When using a vendor-prefixed property, make sure to include the standard one.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this,
            properties,
            num,
            propertiesToCheck = {
                "-webkit-border-radius": "border-radius",
                "-webkit-border-top-left-radius": "border-top-left-radius",
                "-webkit-border-top-right-radius": "border-top-right-radius",
                "-webkit-border-bottom-left-radius": "border-bottom-left-radius",
                "-webkit-border-bottom-right-radius": "border-bottom-right-radius",
                
                "-o-border-radius": "border-radius",
                "-o-border-top-left-radius": "border-top-left-radius",
                "-o-border-top-right-radius": "border-top-right-radius",
                "-o-border-bottom-left-radius": "border-bottom-left-radius",
                "-o-border-bottom-right-radius": "border-bottom-right-radius",
                
                "-moz-border-radius": "border-radius",
                "-moz-border-radius-topleft": "border-top-left-radius",
                "-moz-border-radius-topright": "border-top-right-radius",
                "-moz-border-radius-bottomleft": "border-bottom-left-radius",
                "-moz-border-radius-bottomright": "border-bottom-right-radius",                
                
                "-moz-column-count": "column-count",
                "-webkit-column-count": "column-count",
                
                "-moz-column-gap": "column-gap",
                "-webkit-column-gap": "column-gap",
                
                "-moz-column-rule": "column-rule",
                "-webkit-column-rule": "column-rule",
                
                "-moz-column-rule-style": "column-rule-style",
                "-webkit-column-rule-style": "column-rule-style",
                
                "-moz-column-rule-color": "column-rule-color",
                "-webkit-column-rule-color": "column-rule-color",
                
                "-moz-column-rule-width": "column-rule-width",
                "-webkit-column-rule-width": "column-rule-width",
                
                "-moz-column-width": "column-width",
                "-webkit-column-width": "column-width",
                
                "-webkit-column-span": "column-span",
                "-webkit-columns": "columns",
                
                "-moz-box-shadow": "box-shadow",
                "-webkit-box-shadow": "box-shadow",
                
                "-moz-transform" : "transform",
                "-webkit-transform" : "transform",
                "-o-transform" : "transform",
                "-ms-transform" : "transform",
                
                "-moz-transform-origin" : "transform-origin",
                "-webkit-transform-origin" : "transform-origin",
                "-o-transform-origin" : "transform-origin",
                "-ms-transform-origin" : "transform-origin",
                
                "-moz-box-sizing" : "box-sizing",
                "-webkit-box-sizing" : "box-sizing",
                
                "-moz-user-select" : "user-select",
                "-khtml-user-select" : "user-select",
                "-webkit-user-select" : "user-select"                
            };

        //event handler for beginning of rules
        function startRule(){
            properties = {};
            num=1;        
        }
        
        //event handler for end of rules
        function endRule(event){
            var prop,
                i, len,
                standard,
                needed,
                actual,
                needsStandard = [];

            for (prop in properties){
                if (propertiesToCheck[prop]){
                    needsStandard.push({ actual: prop, needed: propertiesToCheck[prop]});
                }
            }

            for (i=0, len=needsStandard.length; i < len; i++){
                needed = needsStandard[i].needed;
                actual = needsStandard[i].actual;

                if (!properties[needed]){               
                    reporter.report("Missing standard property '" + needed + "' to go along with '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                } else {
                    //make sure standard property is last
                    if (properties[needed][0].pos < properties[actual][0].pos){
                        reporter.report("Standard property '" + needed + "' should come after vendor-prefixed property '" + actual + "'.", properties[actual][0].name.line, properties[actual][0].name.col, rule);
                    }
                }
            }

        }        
        
        parser.addListener("startrule", startRule);
        parser.addListener("startfontface", startRule);
        parser.addListener("startpage", startRule);
        parser.addListener("startpagemargin", startRule);
        parser.addListener("startkeyframerule", startRule);         

        parser.addListener("property", function(event){
            var name = event.property.text.toLowerCase();

            if (!properties[name]){
                properties[name] = [];
            }

            properties[name].push({ name: event.property, value : event.value, pos:num++ });
        });

        parser.addListener("endrule", endRule);
        parser.addListener("endfontface", endRule);
        parser.addListener("endpage", endRule);
        parser.addListener("endpagemargin", endRule);
        parser.addListener("endkeyframerule", endRule);         
    }

});
/*
 * Rule: You don't need to specify units when a value is 0.
 */
/*global CSSLint*/
CSSLint.addRule({

    //rule information
    id: "zero-units",
    name: "Disallow units for 0 values",
    desc: "You don't need to specify units when a value is 0.",
    browsers: "All",

    //initialization
    init: function(parser, reporter){
        var rule = this;

        //count how many times "float" is used
        parser.addListener("property", function(event){
            var parts = event.value.parts,
                i = 0, 
                len = parts.length;

            while(i < len){
                if ((parts[i].units || parts[i].type == "percentage") && parts[i].value === 0 && parts[i].type != "time"){
                    reporter.report("Values of 0 shouldn't have units specified.", parts[i].line, parts[i].col, rule);
                }
                i++;
            }

        });

    }

});
/*global CSSLint*/
(function() {

    /**
     * Replace special characters before write to output.
     *
     * Rules:
     *  - single quotes is the escape sequence for double-quotes
     *  - &amp; is the escape sequence for &
     *  - &lt; is the escape sequence for <
     *  - &gt; is the escape sequence for >
     *
     * @param {String} message to escape
     * @return escaped message as {String}
     */
    var xmlEscape = function(str) {
        if (!str || str.constructor !== String) {
            return "";
        }
        
        return str.replace(/[\"&><]/g, function(match) {
            switch (match) {
                case "\"":
                    return "&quot;";
                case "&":
                    return "&amp;";
                case "<":
                    return "&lt;";
                case ">":
                    return "&gt;";            
            }
        });
    };

    CSSLint.addFormatter({
        //format information
        id: "checkstyle-xml",
        name: "Checkstyle XML format",

        /**
         * Return opening root XML tag.
         * @return {String} to prepend before all results
         */
        startFormat: function(){
            return "<?xml version=\"1.0\" encoding=\"utf-8\"?><checkstyle>";
        },

        /**
         * Return closing root XML tag.
         * @return {String} to append after all results
         */
        endFormat: function(){
            return "</checkstyle>";
        },
        
        /**
         * Returns message when there is a file read error.
         * @param {String} filename The name of the file that caused the error.
         * @param {String} message The error message
         * @return {String} The error message.
         */
        readError: function(filename, message) {
            return "<file name=\"" + xmlEscape(filename) + "\"><error line=\"0\" column=\"0\" severty=\"error\" message=\"" + xmlEscape(message) + "\"></error></file>";
        },

        /**
         * Given CSS Lint results for a file, return output for this format.
         * @param results {Object} with error and warning messages
         * @param filename {String} relative file path
         * @param options {Object} (UNUSED for now) specifies special handling of output
         * @return {String} output for results
         */
        formatResults: function(results, filename, options) {
            var messages = results.messages,
                output = [];

            /**
             * Generate a source string for a rule.
             * Checkstyle source strings usually resemble Java class names e.g
             * net.csslint.SomeRuleName
             * @param {Object} rule
             * @return rule source as {String}
             */
            var generateSource = function(rule) {
                if (!rule || !('name' in rule)) {
                    return "";
                }
                return 'net.csslint.' + rule.name.replace(/\s/g,'');
            };



            if (messages.length > 0) {
                output.push("<file name=\""+filename+"\">");
                CSSLint.Util.forEach(messages, function (message, i) {
                    //ignore rollups for now
                    if (!message.rollup) {
                      output.push("<error line=\"" + message.line + "\" column=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                          " message=\"" + xmlEscape(message.message) + "\" source=\"" + generateSource(message.rule) +"\"/>");
                    }
                });
                output.push("</file>");
            }

            return output.join("");
        }
    });

}());
/*global CSSLint*/
CSSLint.addFormatter({
    //format information
    id: "compact",
    name: "Compact, 'porcelain' format",

    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        return "";
    },

    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function() {
        return "";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (Optional) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = "";
        options = options || {};

        /**
         * Capitalize and return given string.
         * @param str {String} to capitalize
         * @return {String} capitalized
         */
        var capitalize = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        };

        if (messages.length === 0) {
            return options.quiet ? "" : filename + ": Lint Free!";
        }

        CSSLint.Util.forEach(messages, function(message, i) {
            if (message.rollup) {
                output += filename + ": " + capitalize(message.type) + " - " + message.message + "\n";
            } else {
                output += filename + ": " + "line " + message.line + 
                    ", col " + message.col + ", " + capitalize(message.type) + " - " + message.message + "\n";
            }
        });
    
        return output;
    }
});
/*global CSSLint*/
CSSLint.addFormatter({
    //format information
    id: "csslint-xml",
    name: "CSSLint XML format",

    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><csslint>";
    },

    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function(){
        return "</csslint>";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = [];

        /**
         * Replace special characters before write to output.
         *
         * Rules:
         *  - single quotes is the escape sequence for double-quotes
         *  - &amp; is the escape sequence for &
         *  - &lt; is the escape sequence for <
         *  - &gt; is the escape sequence for >
         * 
         * @param {String} message to escape
         * @return escaped message as {String}
         */
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/\"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {
            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message, i) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});
/*global CSSLint*/
CSSLint.addFormatter({
    //format information
    id: "junit-xml",
    name: "JUNIT XML format",

    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><testsuites>";
    },

    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function() {
        return "</testsuites>";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {

        var messages = results.messages,
            output = [],
            tests = {
                'error': 0,
                'failure': 0
            };

        /**
         * Generate a source string for a rule.
         * JUNIT source strings usually resemble Java class names e.g
         * net.csslint.SomeRuleName
         * @param {Object} rule
         * @return rule source as {String}
         */
        var generateSource = function(rule) {
            if (!rule || !('name' in rule)) {
                return "";
            }
            return 'net.csslint.' + rule.name.replace(/\s/g,'');
        };

        /**
         * Replace special characters before write to output.
         *
         * Rules:
         *  - single quotes is the escape sequence for double-quotes
         *  - &lt; is the escape sequence for <
         *  - &gt; is the escape sequence for >
         *
         * @param {String} message to escape
         * @return escaped message as {String}
         */
        var escapeSpecialCharacters = function(str) {

            if (!str || str.constructor !== String) {
                return "";
            }

            return str.replace(/\"/g, "'").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        };

        if (messages.length > 0) {

            messages.forEach(function (message, i) {

                // since junit has no warning class
                // all issues as errors
                var type = message.type === 'warning' ? 'error' : message.type;

                //ignore rollups for now
                if (!message.rollup) {

                    // build the test case seperately, once joined
                    // we'll add it to a custom array filtered by type
                    output.push("<testcase time=\"0\" name=\"" + generateSource(message.rule) + "\">");
                    output.push("<" + type + " message=\"" + escapeSpecialCharacters(message.message) + "\"><![CDATA[" + message.line + ':' + message.col + ':' + escapeSpecialCharacters(message.evidence)  + "]]></" + type + ">");
                    output.push("</testcase>");

                    tests[type] += 1;

                }

            });

            output.unshift("<testsuite time=\"0\" tests=\"" + messages.length + "\" skipped=\"0\" errors=\"" + tests.error + "\" failures=\"" + tests.failure + "\" package=\"net.csslint\" name=\"" + filename + "\">");
            output.push("</testsuite>");

        }

        return output.join("");

    }
});
/*global CSSLint*/
CSSLint.addFormatter({
    //format information
    id: "lint-xml",
    name: "Lint XML format",

    /**
     * Return opening root XML tag.
     * @return {String} to prepend before all results
     */
    startFormat: function(){
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?><lint>";
    },

    /**
     * Return closing root XML tag.
     * @return {String} to append after all results
     */
    endFormat: function(){
        return "</lint>";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (UNUSED for now) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = [];

        /**
         * Replace special characters before write to output.
         *
         * Rules:
         *  - single quotes is the escape sequence for double-quotes
         *  - &amp; is the escape sequence for &
         *  - &lt; is the escape sequence for <
         *  - &gt; is the escape sequence for >
         * 
         * @param {String} message to escape
         * @return escaped message as {String}
         */
        var escapeSpecialCharacters = function(str) {
            if (!str || str.constructor !== String) {
                return "";
            }
            return str.replace(/\"/g, "'").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        };

        if (messages.length > 0) {
        
            output.push("<file name=\""+filename+"\">");
            CSSLint.Util.forEach(messages, function (message, i) {
                if (message.rollup) {
                    output.push("<issue severity=\"" + message.type + "\" reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                } else {
                    output.push("<issue line=\"" + message.line + "\" char=\"" + message.col + "\" severity=\"" + message.type + "\"" +
                        " reason=\"" + escapeSpecialCharacters(message.message) + "\" evidence=\"" + escapeSpecialCharacters(message.evidence) + "\"/>");
                }
            });
            output.push("</file>");
        }

        return output.join("");
    }
});
/*global CSSLint*/
CSSLint.addFormatter({
    //format information
    id: "text",
    name: "Plain Text",

    /**
     * Return content to be printed before all file results.
     * @return {String} to prepend before all results
     */
    startFormat: function() {
        return "";
    },

    /**
     * Return content to be printed after all file results.
     * @return {String} to append after all results
     */
    endFormat: function() {
        return "";
    },

    /**
     * Given CSS Lint results for a file, return output for this format.
     * @param results {Object} with error and warning messages
     * @param filename {String} relative file path
     * @param options {Object} (Optional) specifies special handling of output
     * @return {String} output for results
     */
    formatResults: function(results, filename, options) {
        var messages = results.messages,
            output = "";
        options = options || {};

        if (messages.length === 0) {
            return options.quiet ? "" : "\n\ncsslint: No errors in " + filename + ".";
        }

        output = "\n\ncsslint: There are " + messages.length  +  " problems in " + filename + ".";
        var pos = filename.lastIndexOf("/"),
            shortFilename = filename;

        if (pos === -1){
            pos = filename.lastIndexOf("\\");       
        }
        if (pos > -1){
            shortFilename = filename.substring(pos+1);
        }

        CSSLint.Util.forEach(messages, function (message, i) {
            output = output + "\n\n" + shortFilename;
            if (message.rollup) {
                output += "\n" + (i+1) + ": " + message.type;
                output += "\n" + message.message;
            } else {
                output += "\n" + (i+1) + ": " + message.type + " at line " + message.line + ", col " + message.col;
                output += "\n" + message.message;
                output += "\n" + message.evidence;
            }
        });
    
        return output;
    }
});

return CSSLint;
})();


/* **********************************************
     Begin jshint-1.1.0.js
********************************************** */

// 1.1.0
var JSHINT;
(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/underscore/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"underscore.js\"}\n//@ sourceURL=/node_modules/underscore/package.json"
));

require.define("/node_modules/underscore/underscore.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n//@ sourceURL=/node_modules/underscore/underscore.js"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("/src/shared/vars.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// jshint -W001\n\n\"use strict\";\n\n// Identifiers provided by the ECMAScript standard.\n\nexports.reservedVars = {\n\targuments : false,\n\tNaN       : false\n};\n\nexports.ecmaIdentifiers = {\n\tArray              : false,\n\tBoolean            : false,\n\tDate               : false,\n\tdecodeURI          : false,\n\tdecodeURIComponent : false,\n\tencodeURI          : false,\n\tencodeURIComponent : false,\n\tError              : false,\n\t\"eval\"             : false,\n\tEvalError          : false,\n\tFunction           : false,\n\thasOwnProperty     : false,\n\tisFinite           : false,\n\tisNaN              : false,\n\tJSON               : false,\n\tMath               : false,\n\tMap                : false,\n\tNumber             : false,\n\tObject             : false,\n\tparseInt           : false,\n\tparseFloat         : false,\n\tRangeError         : false,\n\tReferenceError     : false,\n\tRegExp             : false,\n\tSet                : false,\n\tString             : false,\n\tSyntaxError        : false,\n\tTypeError          : false,\n\tURIError           : false,\n\tWeakMap            : false\n};\n\n// Global variables commonly provided by a web browser environment.\n\nexports.browser = {\n\tArrayBuffer          : false,\n\tArrayBufferView      : false,\n\tAudio                : false,\n\tBlob                 : false,\n\taddEventListener     : false,\n\tapplicationCache     : false,\n\tatob                 : false,\n\tblur                 : false,\n\tbtoa                 : false,\n\tclearInterval        : false,\n\tclearTimeout         : false,\n\tclose                : false,\n\tclosed               : false,\n\tDataView             : false,\n\tDOMParser            : false,\n\tdefaultStatus        : false,\n\tdocument             : false,\n\tElement              : false,\n\tevent                : false,\n\tFileReader           : false,\n\tFloat32Array         : false,\n\tFloat64Array         : false,\n\tFormData             : false,\n\tfocus                : false,\n\tframes               : false,\n\tgetComputedStyle     : false,\n\tHTMLElement          : false,\n\tHTMLAnchorElement    : false,\n\tHTMLBaseElement      : false,\n\tHTMLBlockquoteElement: false,\n\tHTMLBodyElement      : false,\n\tHTMLBRElement        : false,\n\tHTMLButtonElement    : false,\n\tHTMLCanvasElement    : false,\n\tHTMLDirectoryElement : false,\n\tHTMLDivElement       : false,\n\tHTMLDListElement     : false,\n\tHTMLFieldSetElement  : false,\n\tHTMLFontElement      : false,\n\tHTMLFormElement      : false,\n\tHTMLFrameElement     : false,\n\tHTMLFrameSetElement  : false,\n\tHTMLHeadElement      : false,\n\tHTMLHeadingElement   : false,\n\tHTMLHRElement        : false,\n\tHTMLHtmlElement      : false,\n\tHTMLIFrameElement    : false,\n\tHTMLImageElement     : false,\n\tHTMLInputElement     : false,\n\tHTMLIsIndexElement   : false,\n\tHTMLLabelElement     : false,\n\tHTMLLayerElement     : false,\n\tHTMLLegendElement    : false,\n\tHTMLLIElement        : false,\n\tHTMLLinkElement      : false,\n\tHTMLMapElement       : false,\n\tHTMLMenuElement      : false,\n\tHTMLMetaElement      : false,\n\tHTMLModElement       : false,\n\tHTMLObjectElement    : false,\n\tHTMLOListElement     : false,\n\tHTMLOptGroupElement  : false,\n\tHTMLOptionElement    : false,\n\tHTMLParagraphElement : false,\n\tHTMLParamElement     : false,\n\tHTMLPreElement       : false,\n\tHTMLQuoteElement     : false,\n\tHTMLScriptElement    : false,\n\tHTMLSelectElement    : false,\n\tHTMLStyleElement     : false,\n\tHTMLTableCaptionElement: false,\n\tHTMLTableCellElement : false,\n\tHTMLTableColElement  : false,\n\tHTMLTableElement     : false,\n\tHTMLTableRowElement  : false,\n\tHTMLTableSectionElement: false,\n\tHTMLTextAreaElement  : false,\n\tHTMLTitleElement     : false,\n\tHTMLUListElement     : false,\n\tHTMLVideoElement     : false,\n\thistory              : false,\n\tInt16Array           : false,\n\tInt32Array           : false,\n\tInt8Array            : false,\n\tImage                : false,\n\tlength               : false,\n\tlocalStorage         : false,\n\tlocation             : false,\n\tMessageChannel       : false,\n\tMessageEvent         : false,\n\tMessagePort          : false,\n\tmoveBy               : false,\n\tmoveTo               : false,\n\tMutationObserver     : false,\n\tname                 : false,\n\tNode                 : false,\n\tNodeFilter           : false,\n\tnavigator            : false,\n\tonbeforeunload       : true,\n\tonblur               : true,\n\tonerror              : true,\n\tonfocus              : true,\n\tonload               : true,\n\tonresize             : true,\n\tonunload             : true,\n\topen                 : false,\n\topenDatabase         : false,\n\topener               : false,\n\tOption               : false,\n\tparent               : false,\n\tprint                : false,\n\tremoveEventListener  : false,\n\tresizeBy             : false,\n\tresizeTo             : false,\n\tscreen               : false,\n\tscroll               : false,\n\tscrollBy             : false,\n\tscrollTo             : false,\n\tsessionStorage       : false,\n\tsetInterval          : false,\n\tsetTimeout           : false,\n\tSharedWorker         : false,\n\tstatus               : false,\n\ttop                  : false,\n\tUint16Array          : false,\n\tUint32Array          : false,\n\tUint8Array           : false,\n\tUint8ClampedArray    : false,\n\tWebSocket            : false,\n\twindow               : false,\n\tWorker               : false,\n\tXMLHttpRequest       : false,\n\tXMLSerializer        : false,\n\tXPathEvaluator       : false,\n\tXPathException       : false,\n\tXPathExpression      : false,\n\tXPathNamespace       : false,\n\tXPathNSResolver      : false,\n\tXPathResult          : false\n};\n\nexports.devel = {\n\talert  : false,\n\tconfirm: false,\n\tconsole: false,\n\tDebug  : false,\n\topera  : false,\n\tprompt : false\n};\n\nexports.worker = {\n\timportScripts: true,\n\tpostMessage  : true,\n\tself         : true\n};\n\n// Widely adopted global names that are not part of ECMAScript standard\nexports.nonstandard = {\n\tescape  : false,\n\tunescape: false\n};\n\n// Globals provided by popular JavaScript environments.\n\nexports.couch = {\n\t\"require\" : false,\n\trespond   : false,\n\tgetRow    : false,\n\temit      : false,\n\tsend      : false,\n\tstart     : false,\n\tsum       : false,\n\tlog       : false,\n\texports   : false,\n\tmodule    : false,\n\tprovides  : false\n};\n\nexports.node = {\n\t__filename   : false,\n\t__dirname    : false,\n\tBuffer       : false,\n\tDataView     : false,\n\tconsole      : false,\n\texports      : true,  // In Node it is ok to exports = module.exports = foo();\n\tGLOBAL       : false,\n\tglobal       : false,\n\tmodule       : false,\n\tprocess      : false,\n\trequire      : false,\n\tsetTimeout   : false,\n\tclearTimeout : false,\n\tsetInterval  : false,\n\tclearInterval: false\n};\n\nexports.phantom = {\n\tphantom      : true,\n\trequire      : true,\n\tWebPage      : true\n};\n\nexports.rhino = {\n\tdefineClass  : false,\n\tdeserialize  : false,\n\tgc           : false,\n\thelp         : false,\n\timportPackage: false,\n\t\"java\"       : false,\n\tload         : false,\n\tloadClass    : false,\n\tprint        : false,\n\tquit         : false,\n\treadFile     : false,\n\treadUrl      : false,\n\trunCommand   : false,\n\tseal         : false,\n\tserialize    : false,\n\tspawn        : false,\n\tsync         : false,\n\ttoint32      : false,\n\tversion      : false\n};\n\nexports.wsh = {\n\tActiveXObject            : true,\n\tEnumerator               : true,\n\tGetObject                : true,\n\tScriptEngine             : true,\n\tScriptEngineBuildVersion : true,\n\tScriptEngineMajorVersion : true,\n\tScriptEngineMinorVersion : true,\n\tVBArray                  : true,\n\tWSH                      : true,\n\tWScript                  : true,\n\tXDomainRequest           : true\n};\n\n// Globals provided by popular JavaScript libraries.\n\nexports.dojo = {\n\tdojo     : false,\n\tdijit    : false,\n\tdojox    : false,\n\tdefine\t : false,\n\t\"require\": false\n};\n\nexports.jquery = {\n\t\"$\"    : false,\n\tjQuery : false\n};\n\nexports.mootools = {\n\t\"$\"           : false,\n\t\"$$\"          : false,\n\tAsset         : false,\n\tBrowser       : false,\n\tChain         : false,\n\tClass         : false,\n\tColor         : false,\n\tCookie        : false,\n\tCore          : false,\n\tDocument      : false,\n\tDomReady      : false,\n\tDOMEvent      : false,\n\tDOMReady      : false,\n\tDrag          : false,\n\tElement       : false,\n\tElements      : false,\n\tEvent         : false,\n\tEvents        : false,\n\tFx            : false,\n\tGroup         : false,\n\tHash          : false,\n\tHtmlTable     : false,\n\tIframe        : false,\n\tIframeShim    : false,\n\tInputValidator: false,\n\tinstanceOf    : false,\n\tKeyboard      : false,\n\tLocale        : false,\n\tMask          : false,\n\tMooTools      : false,\n\tNative        : false,\n\tOptions       : false,\n\tOverText      : false,\n\tRequest       : false,\n\tScroller      : false,\n\tSlick         : false,\n\tSlider        : false,\n\tSortables     : false,\n\tSpinner       : false,\n\tSwiff         : false,\n\tTips          : false,\n\tType          : false,\n\ttypeOf        : false,\n\tURI           : false,\n\tWindow        : false\n};\n\nexports.prototypejs = {\n\t\"$\"               : false,\n\t\"$$\"              : false,\n\t\"$A\"              : false,\n\t\"$F\"              : false,\n\t\"$H\"              : false,\n\t\"$R\"              : false,\n\t\"$break\"          : false,\n\t\"$continue\"       : false,\n\t\"$w\"              : false,\n\tAbstract          : false,\n\tAjax              : false,\n\tClass             : false,\n\tEnumerable        : false,\n\tElement           : false,\n\tEvent             : false,\n\tField             : false,\n\tForm              : false,\n\tHash              : false,\n\tInsertion         : false,\n\tObjectRange       : false,\n\tPeriodicalExecuter: false,\n\tPosition          : false,\n\tPrototype         : false,\n\tSelector          : false,\n\tTemplate          : false,\n\tToggle            : false,\n\tTry               : false,\n\tAutocompleter     : false,\n\tBuilder           : false,\n\tControl           : false,\n\tDraggable         : false,\n\tDraggables        : false,\n\tDroppables        : false,\n\tEffect            : false,\n\tSortable          : false,\n\tSortableObserver  : false,\n\tSound             : false,\n\tScriptaculous     : false\n};\n\nexports.yui = {\n\tYUI       : false,\n\tY         : false,\n\tYUI_config: false\n};\n\n\n//@ sourceURL=/src/shared/vars.js"
));

require.define("/src/shared/messages.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar _ = require(\"underscore\");\n\nvar errors = {\n\t// JSHint options\n\tE001: \"Bad option: '{a}'.\",\n\tE002: \"Bad option value.\",\n\n\t// JSHint input\n\tE003: \"Expected a JSON value.\",\n\tE004: \"Input is neither a string nor an array of strings.\",\n\tE005: \"Input is empty.\",\n\tE006: \"Unexpected early end of program.\",\n\n\t// Strict mode\n\tE007: \"Missing \\\"use strict\\\" statement.\",\n\tE008: \"Strict violation.\",\n\tE009: \"Option 'validthis' can't be used in a global scope.\",\n\tE010: \"'with' is not allowed in strict mode.\",\n\n\t// Constants\n\tE011: \"const '{a}' has already been declared.\",\n\tE012: \"const '{a}' is initialized to 'undefined'.\",\n\tE013: \"Attempting to override '{a}' which is a constant.\",\n\n\t// Regular expressions\n\tE014: \"A regular expression literal can be confused with '/='.\",\n\tE015: \"Unclosed regular expression.\",\n\tE016: \"Invalid regular expression.\",\n\n\t// Tokens\n\tE017: \"Unclosed comment.\",\n\tE018: \"Unbegun comment.\",\n\tE019: \"Unmatched '{a}'.\",\n\tE020: \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n\tE021: \"Expected '{a}' and instead saw '{b}'.\",\n\tE022: \"Line breaking error '{a}'.\",\n\tE023: \"Missing '{a}'.\",\n\tE024: \"Unexpected '{a}'.\",\n\tE025: \"Missing ':' on a case clause.\",\n\tE026: \"Missing '}' to match '{' from line {a}.\",\n\tE027: \"Missing ']' to match '[' form line {a}.\",\n\tE028: \"Illegal comma.\",\n\tE029: \"Unclosed string.\",\n\n\t// Everything else\n\tE030: \"Expected an identifier and instead saw '{a}'.\",\n\tE031: \"Bad assignment.\", // FIXME: Rephrase\n\tE032: \"Expected a small integer and instead saw '{a}'.\",\n\tE033: \"Expected an operator and instead saw '{a}'.\",\n\tE034: \"get/set are ES5 features.\",\n\tE035: \"Missing property name.\",\n\tE036: \"Expected to see a statement and instead saw a block.\",\n\tE037: \"Constant {a} was not declared correctly.\",\n\tE038: \"Variable {a} was not declared correctly.\",\n\tE039: \"Function declarations are not invocable. Wrap the whole function invocation in parens.\",\n\tE040: \"Each value should have its own case label.\",\n\tE041: \"Unrecoverable syntax error.\",\n\tE042: \"Stopping.\",\n\tE043: \"Too many errors.\"\n};\n\nvar warnings = {\n\tW001: \"'hasOwnProperty' is a really bad name.\",\n\tW002: \"Value of '{a}' may be overwritten in IE.\",\n\tW003: \"'{a}' was used before it was defined.\",\n\tW004: \"'{a}' is already defined.\",\n\tW005: \"A dot following a number can be confused with a decimal point.\",\n\tW006: \"Confusing minuses.\",\n\tW007: \"Confusing pluses.\",\n\tW008: \"A leading decimal point can be confused with a dot: '{a}'.\",\n\tW009: \"The array literal notation [] is preferrable.\",\n\tW010: \"The object literal notation {} is preferrable.\",\n\tW011: \"Unexpected space after '{a}'.\",\n\tW012: \"Unexpected space before '{a}'.\",\n\tW013: \"Missing space after '{a}'.\",\n\tW014: \"Bad line breaking before '{a}'.\",\n\tW015: \"Expected '{a}' to have an indentation at {b} instead at {c}.\",\n\tW016: \"Unexpected use of '{a}'.\",\n\tW017: \"Bad operand.\",\n\tW018: \"Confusing use of '{a}'.\",\n\tW019: \"Use the isNaN function to compare with NaN.\",\n\tW020: \"Read only.\",\n\tW021: \"'{a}' is a function.\",\n\tW022: \"Do not assign to the exception parameter.\",\n\tW023: \"Expected an identifier in an assignment and instead saw a function invocation.\",\n\tW024: \"Expected an identifier and instead saw '{a}' (a reserved word).\",\n\tW025: \"Missing name in function declaration.\",\n\tW026: \"Inner functions should be listed at the top of the outer function.\",\n\tW027: \"Unreachable '{a}' after '{b}'.\",\n\tW028: \"Label '{a}' on {b} statement.\",\n\tW029: \"Label '{a}' looks like a javascript url.\",\n\tW030: \"Expected an assignment or function call and instead saw an expression.\",\n\tW031: \"Do not use 'new' for side effects.\",\n\tW032: \"Unnecessary semicolon.\",\n\tW033: \"Missing semicolon.\",\n\tW034: \"Unnecessary directive \\\"{a}\\\".\",\n\tW035: \"Empty block.\",\n\tW036: \"Unexpected /*member '{a}'.\",\n\tW037: \"'{a}' is a statement label.\",\n\tW038: \"'{a}' used out of scope.\",\n\tW039: \"'{a}' is not allowed.\",\n\tW040: \"Possible strict violation.\",\n\tW041: \"Use '{a}' to compare with '{b}'.\",\n\tW042: \"Avoid EOL escaping.\",\n\tW043: \"Bad escaping of EOL. Use option multistr if needed.\",\n\tW044: \"Bad escaping.\",\n\tW045: \"Bad number '{a}'.\",\n\tW046: \"Don't use extra leading zeros '{a}'.\",\n\tW047: \"A trailing decimal point can be confused with a dot: '{a}'.\",\n\tW048: \"Unexpected control character in regular expression.\",\n\tW049: \"Unexpected escaped character '{a}' in regular expression.\",\n\tW050: \"JavaScript URL.\",\n\tW051: \"Variables should not be deleted.\",\n\tW052: \"Unexpected '{a}'.\",\n\tW053: \"Do not use {a} as a constructor.\",\n\tW054: \"The Function constructor is a form of eval.\",\n\tW055: \"A constructor name should start with an uppercase letter.\",\n\tW056: \"Bad constructor.\",\n\tW057: \"Weird construction. Is 'new' unnecessary?\",\n\tW058: \"Missing '()' invoking a constructor.\",\n\tW059: \"Avoid arguments.{a}.\",\n\tW060: \"document.write can be a form of eval.\",\n\tW061: \"eval can be harmful.\",\n\tW062: \"Wrap an immediate function invocation in parens \" +\n\t\t\"to assist the reader in understanding that the expression \" +\n\t\t\"is the result of a function, and not the function itself.\",\n\tW063: \"Math is not a function.\",\n\tW064: \"Missing 'new' prefix when invoking a constructor.\",\n\tW065: \"Missing radix parameter.\",\n\tW066: \"Implied eval. Consider passing a function instead of a string.\",\n\tW067: \"Bad invocation.\",\n\tW068: \"Wrapping non-IIFE function literals in parens is unnecessary.\",\n\tW069: \"['{a}'] is better written in dot notation.\",\n\tW070: \"Extra comma. (it breaks older versions of IE)\",\n\tW071: \"This function has too many statements. ({a})\",\n\tW072: \"This function has too many parameters. ({a})\",\n\tW073: \"Blocks are nested too deeply. ({a})\",\n\tW074: \"This function's cyclomatic complexity is too high. ({a})\",\n\tW075: \"Duplicate key '{a}'.\",\n\tW076: \"Unexpected parameter '{a}' in get {b} function.\",\n\tW077: \"Expected a single parameter in set {a} function.\",\n\tW078: \"Setter is defined without getter.\",\n\tW079: \"Redefinition of '{a}'.\",\n\tW080: \"It's not necessary to initialize '{a}' to 'undefined'.\",\n\tW081: \"Too many var statements.\",\n\tW082: \"Function declarations should not be placed in blocks. \" +\n\t\t\"Use a function expression or move the statement to the top of \" +\n\t\t\"the outer function.\",\n\tW083: \"Don't make functions within a loop.\",\n\tW084: \"Expected a conditional expression and instead saw an assignment.\",\n\tW085: \"Don't use 'with'.\",\n\tW086: \"Expected a 'break' statement before '{a}'.\",\n\tW087: \"Forgotten 'debugger' statement?\",\n\tW088: \"Creating global 'for' variable. Should be 'for (var {a} ...'.\",\n\tW089: \"The body of a for in should be wrapped in an if statement to filter \" +\n\t\t\"unwanted properties from the prototype.\",\n\tW090: \"'{a}' is not a statement label.\",\n\tW091: \"'{a}' is out of scope.\",\n\tW092: \"Wrap the /regexp/ literal in parens to disambiguate the slash operator.\",\n\tW093: \"Did you mean to return a conditional instead of an assignment?\",\n\tW094: \"Unexpected comma.\",\n\tW095: \"Expected a string and instead saw {a}.\",\n\tW096: \"The '{a}' key may produce unexpected results.\",\n\tW097: \"Use the function form of \\\"use strict\\\".\",\n\tW098: \"'{a}' is defined but never used.\",\n\tW099: \"Mixed spaces and tabs.\",\n\tW100: \"This character may get silently deleted by one or more browsers.\",\n\tW101: \"Line is too long.\",\n\tW102: \"Trailing whitespace.\",\n\tW103: \"The '{a}' property is deprecated.\",\n\tW104: \"'{a}' is only available in JavaScript 1.7.\",\n\tW105: \"Unexpected {a} in '{b}'.\",\n\tW106: \"Identifier '{a}' is not in camel case.\",\n\tW107: \"Script URL.\",\n\tW108: \"Strings must use doublequote.\",\n\tW109: \"Strings must use singlequote.\",\n\tW110: \"Mixed double and single quotes.\",\n\tW112: \"Unclosed string.\",\n\tW113: \"Control character in string: {a}.\",\n\tW114: \"Avoid {a}.\",\n\tW115: \"Octal literals are not allowed in strict mode.\",\n\tW116: \"Expected '{a}' and instead saw '{b}'.\",\n\tW117: \"'{a}' is not defined.\",\n};\n\nvar info = {\n\tI001: \"Comma warnings can be turned off with 'laxcomma'.\"\n};\n\nexports.errors = {};\nexports.warnings = {};\nexports.info = {};\n\n_.each(errors, function (desc, code) {\n\texports.errors[code] = { code: code, desc: desc };\n});\n\n_.each(warnings, function (desc, code) {\n\texports.warnings[code] = { code: code, desc: desc };\n});\n\n_.each(info, function (desc, code) {\n\texports.info[code] = { code: code, desc: desc };\n});\n\n//@ sourceURL=/src/shared/messages.js"
));

require.define("/src/stable/lex.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Lexical analysis and token construction.\n */\n\n\"use strict\";\n\nvar _      = require(\"underscore\");\nvar events = require(\"events\");\nvar reg    = require(\"./reg.js\");\nvar state  = require(\"./state.js\").state;\n\n// Some of these token types are from JavaScript Parser API\n// while others are specific to JSHint parser.\n// JS Parser API: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nvar Token = {\n\tIdentifier: 1,\n\tPunctuator: 2,\n\tNumericLiteral: 3,\n\tStringLiteral: 4,\n\tComment: 5,\n\tKeyword: 6,\n\tNullLiteral: 7,\n\tBooleanLiteral: 8,\n\tRegExp: 9\n};\n\n// This is auto generated from the unicode tables.\n// The tables are at:\n// http://www.fileformat.info/info/unicode/category/Lu/list.htm\n// http://www.fileformat.info/info/unicode/category/Ll/list.htm\n// http://www.fileformat.info/info/unicode/category/Lt/list.htm\n// http://www.fileformat.info/info/unicode/category/Lm/list.htm\n// http://www.fileformat.info/info/unicode/category/Lo/list.htm\n// http://www.fileformat.info/info/unicode/category/Nl/list.htm\n\nvar unicodeLetterTable = [\n\t170, 170, 181, 181, 186, 186, 192, 214,\n\t216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750,\n\t880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908,\n\t910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366,\n\t1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610,\n\t1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,\n\t1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957,\n\t1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069,\n\t2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2308, 2361,\n\t2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431,\n\t2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482,\n\t2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n\t2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608,\n\t2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654,\n\t2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736,\n\t2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785,\n\t2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867,\n\t2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929,\n\t2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,\n\t2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001,\n\t3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123,\n\t3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212,\n\t3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261,\n\t3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344,\n\t3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n\t3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526,\n\t3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716,\n\t3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,\n\t3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760,\n\t3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805,\n\t3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138,\n\t4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198,\n\t4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4304, 4346,\n\t4348, 4348, 4352, 4680, 4682, 4685, 4688, 4694, 4696, 4696,\n\t4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789,\n\t4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880,\n\t4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740,\n\t5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900,\n\t5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,\n\t6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312,\n\t6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516,\n\t6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823,\n\t6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7104, 7141,\n\t7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409,\n\t7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013,\n\t8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061,\n\t8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140,\n\t8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n\t8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455,\n\t8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,\n\t8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521,\n\t8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358,\n\t11360, 11492, 11499, 11502, 11520, 11557, 11568, 11621,\n\t11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694,\n\t11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,\n\t11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295,\n\t12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438,\n\t12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589,\n\t12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312,\n\t19893, 19893, 19968, 19968, 40907, 40907, 40960, 42124,\n\t42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539,\n\t42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783,\n\t42786, 42888, 42891, 42894, 42896, 42897, 42912, 42921,\n\t43002, 43009, 43011, 43013, 43015, 43018, 43020, 43042,\n\t43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n\t43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442,\n\t43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,\n\t43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697,\n\t43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714,\n\t43739, 43741, 43777, 43782, 43785, 43790, 43793, 43798,\n\t43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032,\n\t55203, 55203, 55216, 55238, 55243, 55291, 63744, 64045,\n\t64048, 64109, 64112, 64217, 64256, 64262, 64275, 64279,\n\t64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316,\n\t64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,\n\t64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n\t65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370,\n\t65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495,\n\t65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594,\n\t65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786,\n\t65856, 65908, 66176, 66204, 66208, 66256, 66304, 66334,\n\t66352, 66378, 66432, 66461, 66464, 66499, 66504, 66511,\n\t66513, 66517, 66560, 66717, 67584, 67589, 67592, 67592,\n\t67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669,\n\t67840, 67861, 67872, 67897, 68096, 68096, 68112, 68115,\n\t68117, 68119, 68121, 68147, 68192, 68220, 68352, 68405,\n\t68416, 68437, 68448, 68466, 68608, 68680, 69635, 69687,\n\t69763, 69807, 73728, 74606, 74752, 74850, 77824, 78894,\n\t92160, 92728, 110592, 110593, 119808, 119892, 119894, 119964,\n\t119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980,\n\t119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069,\n\t120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121,\n\t120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144,\n\t120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570,\n\t120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686,\n\t120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779,\n\t131072, 131072, 173782, 173782, 173824, 173824, 177972, 177972,\n\t177984, 177984, 178205, 178205, 194560, 195101\n];\n\nvar identifierStartTable = [];\n\nfor (var i = 0; i < 128; i++) {\n\tidentifierStartTable[i] =\n\t\ti === 36 ||           // $\n\t\ti >= 65 && i <= 90 || // A-Z\n\t\ti === 95 ||           // _\n\t\ti >= 97 && i <= 122;  // a-z\n}\n\nvar identifierPartTable = [];\n\nfor (var i = 0; i < 128; i++) {\n\tidentifierPartTable[i] =\n\t\tidentifierStartTable[i] || // $, _, A-Z, a-z\n\t\ti >= 48 && i <= 57;        // 0-9\n}\n\n/*\n * Lexer for JSHint.\n *\n * This object does a char-by-char scan of the provided source code\n * and produces a sequence of tokens.\n *\n *   var lex = new Lexer(\"var i = 0;\");\n *   lex.start();\n *   lex.token(); // returns the next token\n *\n * You have to use the token() method to move the lexer forward\n * but you don't have to use its return value to get tokens. In addition\n * to token() method returning the next token, the Lexer object also\n * emits events.\n *\n *   lex.on(\"Identifier\", function (data) {\n *     if (data.name.indexOf(\"_\") >= 0) {\n *       // Produce a warning.\n *     }\n *   });\n *\n * Note that the token() method returns tokens in a JSLint-compatible\n * format while the event emitter uses a slightly modified version of\n * Mozilla's JavaScript Parser API. Eventually, we will move away from\n * JSLint format.\n */\nfunction Lexer(source) {\n\tvar lines = source;\n\n\tif (typeof lines === \"string\") {\n\t\tlines = lines\n\t\t\t.replace(/\\r\\n/g, \"\\n\")\n\t\t\t.replace(/\\r/g, \"\\n\")\n\t\t\t.split(\"\\n\");\n\t}\n\n\t// If the first line is a shebang (#!), make it a blank and move on.\n\t// Shebangs are used by Node scripts.\n\n\tif (lines[0] && lines[0].substr(0, 2) === \"#!\") {\n\t\tlines[0] = \"\";\n\t}\n\n\tthis.emitter = new events.EventEmitter();\n\tthis.source = source;\n\tthis.lines = lines;\n\tthis.prereg = true;\n\n\tthis.line = 0;\n\tthis.char = 1;\n\tthis.from = 1;\n\tthis.input = \"\";\n\n\tfor (var i = 0; i < state.option.indent; i += 1) {\n\t\tstate.tab += \" \";\n\t}\n}\n\nLexer.prototype = {\n\t_lines: [],\n\n\tget lines() {\n\t\tthis._lines = state.lines;\n\t\treturn this._lines;\n\t},\n\n\tset lines(val) {\n\t\tthis._lines = val;\n\t\tstate.lines = this._lines;\n\t},\n\n\t/*\n\t * Return the next i character without actually moving the\n\t * char pointer.\n\t */\n\tpeek: function (i) {\n\t\treturn this.input.charAt(i || 0);\n\t},\n\n\t/*\n\t * Move the char pointer forward i times.\n\t */\n\tskip: function (i) {\n\t\ti = i || 1;\n\t\tthis.char += i;\n\t\tthis.input = this.input.slice(i);\n\t},\n\n\t/*\n\t * Subscribe to a token event. The API for this method is similar\n\t * Underscore.js i.e. you can subscribe to multiple events with\n\t * one call:\n\t *\n\t *   lex.on(\"Identifier Number\", function (data) {\n\t *     // ...\n\t *   });\n\t */\n\ton: function (names, listener) {\n\t\tnames.split(\" \").forEach(function (name) {\n\t\t\tthis.emitter.on(name, listener);\n\t\t}.bind(this));\n\t},\n\n\t/*\n\t * Trigger a token event. All arguments will be passed to each\n\t * listener.\n\t */\n\ttrigger: function () {\n\t\tthis.emitter.emit.apply(this.emitter, Array.prototype.slice.call(arguments));\n\t},\n\n\t/*\n\t * Extract a punctuator out of the next sequence of characters\n\t * or return 'null' if its not possible.\n\t *\n\t * This method's implementation was heavily influenced by the\n\t * scanPunctuator function in the Esprima parser's source code.\n\t */\n\tscanPunctuator: function () {\n\t\tvar ch1 = this.peek();\n\t\tvar ch2, ch3, ch4;\n\n\t\tswitch (ch1) {\n\t\t// Most common single-character punctuators\n\t\tcase \".\":\n\t\t\tif ((/^[0-9]$/).test(this.peek(1))) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t/* falls through */\n\t\tcase \"(\":\n\t\tcase \")\":\n\t\tcase \";\":\n\t\tcase \",\":\n\t\tcase \"{\":\n\t\tcase \"}\":\n\t\tcase \"[\":\n\t\tcase \"]\":\n\t\tcase \":\":\n\t\tcase \"~\":\n\t\tcase \"?\":\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: ch1\n\t\t\t};\n\n\t\t// A pound sign (for Node shebangs)\n\t\tcase \"#\":\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: ch1\n\t\t\t};\n\n\t\t// We're at the end of input\n\t\tcase \"\":\n\t\t\treturn null;\n\t\t}\n\n\t\t// Peek more characters\n\n\t\tch2 = this.peek(1);\n\t\tch3 = this.peek(2);\n\t\tch4 = this.peek(3);\n\n\t\t// 4-character punctuator: >>>=\n\n\t\tif (ch1 === \">\" && ch2 === \">\" && ch3 === \">\" && ch4 === \"=\") {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \">>>=\"\n\t\t\t};\n\t\t}\n\n\t\t// 3-character punctuators: === !== >>> <<= >>=\n\n\t\tif (ch1 === \"=\" && ch2 === \"=\" && ch3 === \"=\") {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \"===\"\n\t\t\t};\n\t\t}\n\n\t\tif (ch1 === \"!\" && ch2 === \"=\" && ch3 === \"=\") {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \"!==\"\n\t\t\t};\n\t\t}\n\n\t\tif (ch1 === \">\" && ch2 === \">\" && ch3 === \">\") {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \">>>\"\n\t\t\t};\n\t\t}\n\n\t\tif (ch1 === \"<\" && ch2 === \"<\" && ch3 === \"=\") {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \"<<=\"\n\t\t\t};\n\t\t}\n\n\t\tif (ch1 === \">\" && ch2 === \">\" && ch3 === \"=\") {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \"<<=\"\n\t\t\t};\n\t\t}\n\n\t\t// 2-character punctuators: <= >= == != ++ -- << >> && ||\n\t\t// += -= *= %= &= |= ^= (but not /=, see below)\n\t\tif (ch1 === ch2 && (\"+-<>&|\".indexOf(ch1) >= 0)) {\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: ch1 + ch2\n\t\t\t};\n\t\t}\n\n\t\tif (\"<>=!+-*%&|^\".indexOf(ch1) >= 0) {\n\t\t\tif (ch2 === \"=\") {\n\t\t\t\treturn {\n\t\t\t\t\ttype: Token.Punctuator,\n\t\t\t\t\tvalue: ch1 + ch2\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: ch1\n\t\t\t};\n\t\t}\n\n\t\t// Special case: /=. We need to make sure that this is an\n\t\t// operator and not a regular expression.\n\n\t\tif (ch1 === \"/\") {\n\t\t\tif (ch2 === \"=\" && /\\/=(?!(\\S*\\/[gim]?))/.test(this.input)) {\n\t\t\t\t// /= is not a part of a regular expression, return it as a\n\t\t\t\t// punctuator.\n\t\t\t\treturn {\n\t\t\t\t\ttype: Token.Punctuator,\n\t\t\t\t\tvalue: \"/=\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: Token.Punctuator,\n\t\t\t\tvalue: \"/\"\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/*\n\t * Extract a comment out of the next sequence of characters and/or\n\t * lines or return 'null' if its not possible. Since comments can\n\t * span across multiple lines this method has to move the char\n\t * pointer.\n\t *\n\t * In addition to normal JavaScript comments (// and /*) this method\n\t * also recognizes JSHint- and JSLint-specific comments such as\n\t * /*jshint, /*jslint, /*globals and so on.\n\t */\n\tscanComments: function () {\n\t\tvar ch1 = this.peek();\n\t\tvar ch2 = this.peek(1);\n\t\tvar rest = this.input.substr(2);\n\t\tvar startLine = this.line;\n\t\tvar startChar = this.char;\n\n\t\t// Create a comment token object and make sure it\n\t\t// has all the data JSHint needs to work with special\n\t\t// comments.\n\n\t\tfunction commentToken(label, body, opt) {\n\t\t\tvar special = [\"jshint\", \"jslint\", \"members\", \"member\", \"globals\", \"global\", \"exported\"];\n\t\t\tvar isSpecial = false;\n\t\t\tvar value = label + body;\n\t\t\tvar commentType = \"plain\";\n\t\t\topt = opt || {};\n\n\t\t\tif (opt.isMultiline) {\n\t\t\t\tvalue += \"*/\";\n\t\t\t}\n\n\t\t\tspecial.forEach(function (str) {\n\t\t\t\tif (isSpecial) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Don't recognize any special comments other than jshint for single-line\n\t\t\t\t// comments. This introduced many problems with legit comments.\n\t\t\t\tif (label === \"//\" && str !== \"jshint\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (body.substr(0, str.length) === str) {\n\t\t\t\t\tisSpecial = true;\n\t\t\t\t\tlabel = label + str;\n\t\t\t\t\tbody = body.substr(str.length);\n\t\t\t\t}\n\n\t\t\t\tif (!isSpecial && body.charAt(0) === \" \" && body.substr(1, str.length) === str) {\n\t\t\t\t\tisSpecial = true;\n\t\t\t\t\tlabel = label + \" \" + str;\n\t\t\t\t\tbody = body.substr(str.length + 1);\n\t\t\t\t}\n\n\t\t\t\tif (!isSpecial) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch (str) {\n\t\t\t\tcase \"member\":\n\t\t\t\t\tcommentType = \"members\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"global\":\n\t\t\t\t\tcommentType = \"globals\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcommentType = str;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: Token.Comment,\n\t\t\t\tcommentType: commentType,\n\t\t\t\tvalue: value,\n\t\t\t\tbody: body,\n\t\t\t\tisSpecial: isSpecial,\n\t\t\t\tisMultiline: opt.isMultiline || false,\n\t\t\t\tisMalformed: opt.isMalformed || false\n\t\t\t};\n\t\t}\n\n\t\t// End of unbegun comment. Raise an error and skip that input.\n\t\tif (ch1 === \"*\" && ch2 === \"/\") {\n\t\t\tthis.trigger(\"error\", {\n\t\t\t\tcode: \"E018\",\n\t\t\t\tline: startLine,\n\t\t\t\tcharacter: startChar\n\t\t\t});\n\n\t\t\tthis.skip(2);\n\t\t\treturn null;\n\t\t}\n\n\t\t// Comments must start either with // or /*\n\t\tif (ch1 !== \"/\" || (ch2 !== \"*\" && ch2 !== \"/\")) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// One-line comment\n\t\tif (ch2 === \"/\") {\n\t\t\tthis.skip(this.input.length); // Skip to the EOL.\n\t\t\treturn commentToken(\"//\", rest);\n\t\t}\n\n\t\tvar body = \"\";\n\n\t\t/* Multi-line comment */\n\t\tif (ch2 === \"*\") {\n\t\t\tthis.skip(2);\n\n\t\t\twhile (this.peek() !== \"*\" || this.peek(1) !== \"/\") {\n\t\t\t\tif (this.peek() === \"\") { // End of Line\n\t\t\t\t\tbody += \"\\n\";\n\n\t\t\t\t\t// If we hit EOF and our comment is still unclosed,\n\t\t\t\t\t// trigger an error and end the comment implicitly.\n\t\t\t\t\tif (!this.nextLine()) {\n\t\t\t\t\t\tthis.trigger(\"error\", {\n\t\t\t\t\t\t\tcode: \"E017\",\n\t\t\t\t\t\t\tline: startLine,\n\t\t\t\t\t\t\tcharacter: startChar\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn commentToken(\"/*\", body, {\n\t\t\t\t\t\t\tisMultiline: true,\n\t\t\t\t\t\t\tisMalformed: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbody += this.peek();\n\t\t\t\t\tthis.skip();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.skip(2);\n\t\t\treturn commentToken(\"/*\", body, { isMultiline: true });\n\t\t}\n\t},\n\n\t/*\n\t * Extract a keyword out of the next sequence of characters or\n\t * return 'null' if its not possible.\n\t */\n\tscanKeyword: function () {\n\t\tvar result = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input);\n\t\tvar keywords = [\n\t\t\t\"if\", \"in\", \"do\", \"var\", \"for\", \"new\",\n\t\t\t\"try\", \"let\", \"this\", \"else\", \"case\",\n\t\t\t\"void\", \"with\", \"enum\", \"while\", \"break\",\n\t\t\t\"catch\", \"throw\", \"const\", \"yield\", \"class\",\n\t\t\t\"super\", \"return\", \"typeof\", \"delete\",\n\t\t\t\"switch\", \"export\", \"import\", \"default\",\n\t\t\t\"finally\", \"extends\", \"function\", \"continue\",\n\t\t\t\"debugger\", \"instanceof\"\n\t\t];\n\n\t\tif (result && keywords.indexOf(result[0]) >= 0) {\n\t\t\treturn {\n\t\t\t\ttype: Token.Keyword,\n\t\t\t\tvalue: result[0]\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/*\n\t * Extract a JavaScript identifier out of the next sequence of\n\t * characters or return 'null' if its not possible. In addition,\n\t * to Identifier this method can also produce BooleanLiteral\n\t * (true/false) and NullLiteral (null).\n\t */\n\tscanIdentifier: function () {\n\t\tvar id = \"\";\n\t\tvar index = 0;\n\t\tvar type, char;\n\n\t\t// Detects any character in the Unicode categories \"Uppercase\n\t\t// letter (Lu)\", \"Lowercase letter (Ll)\", \"Titlecase letter\n\t\t// (Lt)\", \"Modifier letter (Lm)\", \"Other letter (Lo)\", or\n\t\t// \"Letter number (Nl)\".\n\t\t//\n\t\t// Both approach and unicodeLetterTable were borrowed from\n\t\t// Google's Traceur.\n\n\t\tfunction isUnicodeLetter(code) {\n\t\t\tfor (var i = 0; i < unicodeLetterTable.length;) {\n\t\t\t\tif (code < unicodeLetterTable[i++]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (code <= unicodeLetterTable[i++]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction isHexDigit(str) {\n\t\t\treturn (/^[0-9a-fA-F]$/).test(str);\n\t\t}\n\n\t\tvar readUnicodeEscapeSequence = function () {\n\t\t\t/*jshint validthis:true */\n\t\t\tindex += 1;\n\n\t\t\tif (this.peek(index) !== \"u\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar ch1 = this.peek(index + 1);\n\t\t\tvar ch2 = this.peek(index + 2);\n\t\t\tvar ch3 = this.peek(index + 3);\n\t\t\tvar ch4 = this.peek(index + 4);\n\t\t\tvar code;\n\n\t\t\tif (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {\n\t\t\t\tcode = parseInt(ch1 + ch2 + ch3 + ch4, 16);\n\n\t\t\t\tif (isUnicodeLetter(code)) {\n\t\t\t\t\tindex += 5;\n\t\t\t\t\treturn \"\\\\u\" + ch1 + ch2 + ch3 + ch4;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}.bind(this);\n\n\t\tvar getIdentifierStart = function () {\n\t\t\t/*jshint validthis:true */\n\t\t\tvar chr = this.peek(index);\n\t\t\tvar code = chr.charCodeAt(0);\n\n\t\t\tif (code === 92) {\n\t\t\t\treturn readUnicodeEscapeSequence();\n\t\t\t}\n\n\t\t\tif (code < 128) {\n\t\t\t\tif (identifierStartTable[code]) {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\treturn chr;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isUnicodeLetter(code)) {\n\t\t\t\tindex += 1;\n\t\t\t\treturn chr;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}.bind(this);\n\n\t\tvar getIdentifierPart = function () {\n\t\t\t/*jshint validthis:true */\n\t\t\tvar chr = this.peek(index);\n\t\t\tvar code = chr.charCodeAt(0);\n\n\t\t\tif (code === 92) {\n\t\t\t\treturn readUnicodeEscapeSequence();\n\t\t\t}\n\n\t\t\tif (code < 128) {\n\t\t\t\tif (identifierPartTable[code]) {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\treturn chr;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (isUnicodeLetter(code)) {\n\t\t\t\tindex += 1;\n\t\t\t\treturn chr;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}.bind(this);\n\n\t\tchar = getIdentifierStart();\n\t\tif (char === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tid = char;\n\t\tfor (;;) {\n\t\t\tchar = getIdentifierPart();\n\n\t\t\tif (char === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tid += char;\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase \"true\":\n\t\tcase \"false\":\n\t\t\ttype = Token.BooleanLiteral;\n\t\t\tbreak;\n\t\tcase \"null\":\n\t\t\ttype = Token.NullLiteral;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = Token.Identifier;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: type,\n\t\t\tvalue: id\n\t\t};\n\t},\n\n\t/*\n\t * Extract a numeric literal out of the next sequence of\n\t * characters or return 'null' if its not possible. This method\n\t * supports all numeric literals described in section 7.8.3\n\t * of the EcmaScript 5 specification.\n\t *\n\t * This method's implementation was heavily influenced by the\n\t * scanNumericLiteral function in the Esprima parser's source code.\n\t */\n\tscanNumericLiteral: function () {\n\t\tvar index = 0;\n\t\tvar value = \"\";\n\t\tvar length = this.input.length;\n\t\tvar char = this.peek(index);\n\t\tvar bad;\n\n\t\tfunction isDecimalDigit(str) {\n\t\t\treturn (/^[0-9]$/).test(str);\n\t\t}\n\n\t\tfunction isOctalDigit(str) {\n\t\t\treturn (/^[0-7]$/).test(str);\n\t\t}\n\n\t\tfunction isHexDigit(str) {\n\t\t\treturn (/^[0-9a-fA-F]$/).test(str);\n\t\t}\n\n\t\tfunction isIdentifierStart(ch) {\n\t\t\treturn (ch === \"$\") || (ch === \"_\") || (ch === \"\\\\\") ||\n\t\t\t\t(ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\");\n\t\t}\n\n\t\t// Numbers must start either with a decimal digit or a point.\n\n\t\tif (char !== \".\" && !isDecimalDigit(char)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (char !== \".\") {\n\t\t\tvalue = this.peek(index);\n\t\t\tindex += 1;\n\t\t\tchar = this.peek(index);\n\n\t\t\tif (value === \"0\") {\n\t\t\t\t// Base-16 numbers.\n\t\t\t\tif (char === \"x\" || char === \"X\") {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tvalue += char;\n\n\t\t\t\t\twhile (index < length) {\n\t\t\t\t\t\tchar = this.peek(index);\n\t\t\t\t\t\tif (!isHexDigit(char)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue += char;\n\t\t\t\t\t\tindex += 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (value.length <= 2) { // 0x\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: Token.NumericLiteral,\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tisMalformed: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < length) {\n\t\t\t\t\t\tchar = this.peek(index);\n\t\t\t\t\t\tif (isIdentifierStart(char)) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: Token.NumericLiteral,\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tbase: 16,\n\t\t\t\t\t\tisMalformed: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Base-8 numbers.\n\t\t\t\tif (isOctalDigit(char)) {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tvalue += char;\n\t\t\t\t\tbad = false;\n\n\t\t\t\t\twhile (index < length) {\n\t\t\t\t\t\tchar = this.peek(index);\n\n\t\t\t\t\t\t// Numbers like '019' (note the 9) are not valid octals\n\t\t\t\t\t\t// but we still parse them and mark as malformed.\n\n\t\t\t\t\t\tif (isDecimalDigit(char)) {\n\t\t\t\t\t\t\tbad = true;\n\t\t\t\t\t\t} else if (!isOctalDigit(char)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue += char;\n\t\t\t\t\t\tindex += 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < length) {\n\t\t\t\t\t\tchar = this.peek(index);\n\t\t\t\t\t\tif (isIdentifierStart(char)) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: Token.NumericLiteral,\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tbase: 8,\n\t\t\t\t\t\tisMalformed: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Decimal numbers that start with '0' such as '09' are illegal\n\t\t\t\t// but we still parse them and return as malformed.\n\n\t\t\t\tif (isDecimalDigit(char)) {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tvalue += char;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (index < length) {\n\t\t\t\tchar = this.peek(index);\n\t\t\t\tif (!isDecimalDigit(char)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvalue += char;\n\t\t\t\tindex += 1;\n\t\t\t}\n\t\t}\n\n\t\t// Decimal digits.\n\n\t\tif (char === \".\") {\n\t\t\tvalue += char;\n\t\t\tindex += 1;\n\n\t\t\twhile (index < length) {\n\t\t\t\tchar = this.peek(index);\n\t\t\t\tif (!isDecimalDigit(char)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvalue += char;\n\t\t\t\tindex += 1;\n\t\t\t}\n\t\t}\n\n\t\t// Exponent part.\n\n\t\tif (char === \"e\" || char === \"E\") {\n\t\t\tvalue += char;\n\t\t\tindex += 1;\n\t\t\tchar = this.peek(index);\n\n\t\t\tif (char === \"+\" || char === \"-\") {\n\t\t\t\tvalue += this.peek(index);\n\t\t\t\tindex += 1;\n\t\t\t}\n\n\t\t\tchar = this.peek(index);\n\t\t\tif (isDecimalDigit(char)) {\n\t\t\t\tvalue += char;\n\t\t\t\tindex += 1;\n\n\t\t\t\twhile (index < length) {\n\t\t\t\t\tchar = this.peek(index);\n\t\t\t\t\tif (!isDecimalDigit(char)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvalue += char;\n\t\t\t\t\tindex += 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (index < length) {\n\t\t\tchar = this.peek(index);\n\t\t\tif (isIdentifierStart(char)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Token.NumericLiteral,\n\t\t\tvalue: value,\n\t\t\tbase: 10,\n\t\t\tisMalformed: !isFinite(value)\n\t\t};\n\t},\n\n\t/*\n\t * Extract a string out of the next sequence of characters and/or\n\t * lines or return 'null' if its not possible. Since strings can\n\t * span across multiple lines this method has to move the char\n\t * pointer.\n\t *\n\t * This method recognizes pseudo-multiline JavaScript strings:\n\t *\n\t *   var str = \"hello\\\n\t *   world\";\n   */\n\tscanStringLiteral: function () {\n\t\tvar quote = this.peek();\n\n\t\t// String must start with a quote.\n\t\tif (quote !== \"\\\"\" && quote !== \"'\") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// In JSON strings must always use double quotes.\n\t\tif (state.jsonMode && quote !== \"\\\"\") {\n\t\t\tthis.trigger(\"warning\", {\n\t\t\t\tcode: \"W108\",\n\t\t\t\tline: this.line,\n\t\t\t\tcharacter: this.char // +1?\n\t\t\t});\n\t\t}\n\n\t\tvar value = \"\";\n\t\tvar startLine = this.line;\n\t\tvar startChar = this.char;\n\t\tvar allowNewLine = false;\n\n\t\tthis.skip();\n\n\t\twhile (this.peek() !== quote) {\n\t\t\twhile (this.peek() === \"\") { // End Of Line\n\n\t\t\t\t// If an EOL is not preceded by a backslash, show a warning\n\t\t\t\t// and proceed like it was a legit multi-line string where\n\t\t\t\t// author simply forgot to escape the newline symbol.\n\t\t\t\t//\n\t\t\t\t// Another approach is to implicitly close a string on EOL\n\t\t\t\t// but it generates too many false positives.\n\n\t\t\t\tif (!allowNewLine) {\n\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\tcode: \"W112\",\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tallowNewLine = false;\n\n\t\t\t\t\t// Otherwise show a warning if multistr option was not set.\n\t\t\t\t\t// For JSON, show warning no matter what.\n\n\t\t\t\t\tif (!state.option.multistr) {\n\t\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\t\tcode: \"W043\",\n\t\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\t\tcharacter: this.char\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (state.jsonMode) {\n\t\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\t\tcode: \"W042\",\n\t\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\t\tcharacter: this.char\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we get an EOF inside of an unclosed string, show an\n\t\t\t\t// error and implicitly close it at the EOF point.\n\n\t\t\t\tif (!this.nextLine()) {\n\t\t\t\t\tthis.trigger(\"error\", {\n\t\t\t\t\t\tcode: \"E029\",\n\t\t\t\t\t\tline: startLine,\n\t\t\t\t\t\tcharacter: startChar\n\t\t\t\t\t});\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: Token.StringLiteral,\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tisUnclosed: true,\n\t\t\t\t\t\tquote: quote\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tallowNewLine = false;\n\t\t\tvar char = this.peek();\n\t\t\tvar jump = 1; // A length of a jump, after we're done\n\t\t\t              // parsing this character.\n\n\t\t\tif (char < \" \") {\n\t\t\t\t// Warn about a control character in a string.\n\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\tcode: \"W113\",\n\t\t\t\t\tline: this.line,\n\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\tdata: [ \"<non-printable>\" ]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Special treatment for some escaped characters.\n\n\t\t\tif (char === \"\\\\\") {\n\t\t\t\tthis.skip();\n\t\t\t\tchar = this.peek();\n\n\t\t\t\tswitch (char) {\n\t\t\t\tcase \"'\":\n\t\t\t\t\tif (state.jsonMode) {\n\t\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\t\tcode: \"W114\",\n\t\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\t\tdata: [ \"\\\\'\" ]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"b\":\n\t\t\t\t\tchar = \"\\b\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"f\":\n\t\t\t\t\tchar = \"\\f\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"n\":\n\t\t\t\t\tchar = \"\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"r\":\n\t\t\t\t\tchar = \"\\r\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"t\":\n\t\t\t\t\tchar = \"\\t\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"0\":\n\t\t\t\t\tchar = \"\\0\";\n\n\t\t\t\t\t// Octal literals fail in strict mode.\n\t\t\t\t\t// Check if the number is between 00 and 07.\n\t\t\t\t\tvar n = parseInt(this.peek(1), 10);\n\t\t\t\t\tif (n >= 0 && n <= 7 && state.directive[\"use strict\"]) {\n\t\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\t\tcode: \"W115\",\n\t\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\t\tcharacter: this.char\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"u\":\n\t\t\t\t\tchar = String.fromCharCode(parseInt(this.input.substr(1, 4), 16));\n\t\t\t\t\tjump = 5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"v\":\n\t\t\t\t\tif (state.jsonMode) {\n\t\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\t\tcode: \"W114\",\n\t\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\t\tdata: [ \"\\\\v\" ]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tchar = \"\\v\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"x\":\n\t\t\t\t\tvar\tx = parseInt(this.input.substr(1, 2), 16);\n\n\t\t\t\t\tif (state.jsonMode) {\n\t\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\t\tcode: \"W114\",\n\t\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\t\tdata: [ \"\\\\x-\" ]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tchar = String.fromCharCode(x);\n\t\t\t\t\tjump = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\\\\\":\n\t\t\t\tcase \"\\\"\":\n\t\t\t\tcase \"/\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\":\n\t\t\t\t\tallowNewLine = true;\n\t\t\t\t\tchar = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"!\":\n\t\t\t\t\tif (value.slice(value.length - 2) === \"<\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*falls through */\n\t\t\t\tdefault:\n\t\t\t\t\t// Weird escaping.\n\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\tcode: \"W044\",\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\tthis.skip(jump);\n\t\t}\n\n\t\tthis.skip();\n\t\treturn {\n\t\t\ttype: Token.StringLiteral,\n\t\t\tvalue: value,\n\t\t\tisUnclosed: false,\n\t\t\tquote: quote\n\t\t};\n\t},\n\n\t/*\n\t * Extract a regular expression out of the next sequence of\n\t * characters and/or lines or return 'null' if its not possible.\n\t *\n\t * This method is platform dependent: it accepts almost any\n\t * regular expression values but then tries to compile and run\n\t * them using system's RegExp object. This means that there are\n\t * rare edge cases where one JavaScript engine complains about\n\t * your regular expression while others don't.\n\t */\n\tscanRegExp: function () {\n\t\tvar index = 0;\n\t\tvar length = this.input.length;\n\t\tvar char = this.peek();\n\t\tvar value = char;\n\t\tvar body = \"\";\n\t\tvar flags = [];\n\t\tvar malformed = false;\n\t\tvar isCharSet = false;\n\t\tvar terminated;\n\n\t\tvar scanUnexpectedChars = function () {\n\t\t\t// Unexpected control character\n\t\t\tif (char < \" \") {\n\t\t\t\tmalformed = true;\n\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\tcode: \"W048\",\n\t\t\t\t\tline: this.line,\n\t\t\t\t\tcharacter: this.char\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Unexpected escaped character\n\t\t\tif (char === \"<\") {\n\t\t\t\tmalformed = true;\n\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\tcode: \"W049\",\n\t\t\t\t\tline: this.line,\n\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\tdata: [ char ]\n\t\t\t\t});\n\t\t\t}\n\t\t}.bind(this);\n\n\t\t// Regular expressions must start with '/'\n\t\tif (!this.prereg || char !== \"/\") {\n\t\t\treturn null;\n\t\t}\n\n\t\tindex += 1;\n\t\tterminated = false;\n\n\t\t// Try to get everything in between slashes. A couple of\n\t\t// cases aside (see scanUnexpectedChars) we don't really\n\t\t// care whether the resulting expression is valid or not.\n\t\t// We will check that later using the RegExp object.\n\n\t\twhile (index < length) {\n\t\t\tchar = this.peek(index);\n\t\t\tvalue += char;\n\t\t\tbody += char;\n\n\t\t\tif (isCharSet) {\n\t\t\t\tif (char === \"]\") {\n\t\t\t\t\tif (this.peek(index - 1) !== \"\\\\\" || this.peek(index - 2) === \"\\\\\") {\n\t\t\t\t\t\tisCharSet = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (char === \"\\\\\") {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tchar = this.peek(index);\n\t\t\t\t\tbody += char;\n\t\t\t\t\tvalue += char;\n\n\t\t\t\t\tscanUnexpectedChars();\n\t\t\t\t}\n\n\t\t\t\tindex += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (char === \"\\\\\") {\n\t\t\t\tindex += 1;\n\t\t\t\tchar = this.peek(index);\n\t\t\t\tbody += char;\n\t\t\t\tvalue += char;\n\n\t\t\t\tscanUnexpectedChars();\n\n\t\t\t\tif (char === \"/\") {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (char === \"[\") {\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (char === \"[\") {\n\t\t\t\tisCharSet = true;\n\t\t\t\tindex += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (char === \"/\") {\n\t\t\t\tbody = body.substr(0, body.length - 1);\n\t\t\t\tterminated = true;\n\t\t\t\tindex += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex += 1;\n\t\t}\n\n\t\t// A regular expression that was never closed is an\n\t\t// error from which we cannot recover.\n\n\t\tif (!terminated) {\n\t\t\tthis.trigger(\"error\", {\n\t\t\t\tcode: \"E015\",\n\t\t\t\tline: this.line,\n\t\t\t\tcharacter: this.from\n\t\t\t});\n\n\t\t\treturn void this.trigger(\"fatal\", {\n\t\t\t\tline: this.line,\n\t\t\t\tfrom: this.from\n\t\t\t});\n\t\t}\n\n\t\t// Parse flags (if any).\n\n\t\twhile (index < length) {\n\t\t\tchar = this.peek(index);\n\t\t\tif (!/[gim]/.test(char)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflags.push(char);\n\t\t\tvalue += char;\n\t\t\tindex += 1;\n\t\t}\n\n\t\t// Check regular expression for correctness.\n\n\t\ttry {\n\t\t\tnew RegExp(body, flags.join(\"\"));\n\t\t} catch (err) {\n\t\t\tmalformed = true;\n\t\t\tthis.trigger(\"error\", {\n\t\t\t\tcode: \"E016\",\n\t\t\t\tline: this.line,\n\t\t\t\tcharacter: this.char,\n\t\t\t\tdata: [ err.message ] // Platform dependent!\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\ttype: Token.RegExp,\n\t\t\tvalue: value,\n\t\t\tflags: flags,\n\t\t\tisMalformed: malformed\n\t\t};\n\t},\n\n\t/*\n\t * Scan for any occurence of mixed tabs and spaces. If smarttabs option\n\t * is on, ignore tabs followed by spaces.\n\t *\n\t * Tabs followed by one space followed by a block comment are allowed.\n\t */\n\tscanMixedSpacesAndTabs: function () {\n\t\tvar at, match;\n\n\t\tif (state.option.smarttabs) {\n\t\t\t// Negative look-behind for \"//\"\n\t\t\tmatch = this.input.match(/(\\/\\/)? \\t/);\n\t\t\tat = match && !match[1] ? 0 : -1;\n\t\t} else {\n\t\t\tat = this.input.search(/ \\t|\\t [^\\*]/);\n\t\t}\n\n\t\treturn at;\n\t},\n\n\t/*\n\t * Scan for characters that get silently deleted by one or more browsers.\n\t */\n\tscanUnsafeChars: function () {\n\t\treturn this.input.search(reg.unsafeChars);\n\t},\n\n\t/*\n\t * Produce the next raw token or return 'null' if no tokens can be matched.\n\t * This method skips over all space characters.\n\t */\n\tnext: function () {\n\t\tthis.from = this.char;\n\n\t\t// Move to the next non-space character.\n\t\tvar start;\n\t\tif (/\\s/.test(this.peek())) {\n\t\t\tstart = this.char;\n\n\t\t\twhile (/\\s/.test(this.peek())) {\n\t\t\t\tthis.from += 1;\n\t\t\t\tthis.skip();\n\t\t\t}\n\n\t\t\tif (this.peek() === \"\") { // EOL\n\t\t\t\tif (state.option.trailing) {\n\t\t\t\t\tthis.trigger(\"warning\", { code: \"W102\", line: this.line, character: start });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Methods that work with multi-line structures and move the\n\t\t// character pointer.\n\n\t\tvar match = this.scanComments() ||\n\t\t\tthis.scanStringLiteral();\n\n\t\tif (match) {\n\t\t\treturn match;\n\t\t}\n\n\t\t// Methods that don't move the character pointer.\n\n\t\tmatch =\n\t\t\tthis.scanRegExp() ||\n\t\t\tthis.scanPunctuator() ||\n\t\t\tthis.scanKeyword() ||\n\t\t\tthis.scanIdentifier() ||\n\t\t\tthis.scanNumericLiteral();\n\n\t\tif (match) {\n\t\t\tthis.skip(match.value.length);\n\t\t\treturn match;\n\t\t}\n\n\t\t// No token could be matched, give up.\n\n\t\treturn null;\n\t},\n\n\t/*\n\t * Switch to the next line and reset all char pointers. Once\n\t * switched, this method also checks for mixed spaces and tabs\n\t * and other minor warnings.\n\t */\n\tnextLine: function () {\n\t\tvar char;\n\n\t\tif (this.line >= this.lines.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.input = this.lines[this.line];\n\t\tthis.line += 1;\n\t\tthis.char = 1;\n\t\tthis.from = 1;\n\n\t\tchar = this.scanMixedSpacesAndTabs();\n\t\tif (char >= 0) {\n\t\t\tthis.trigger(\"warning\", { code: \"W099\", line: this.line, character: char + 1 });\n\t\t}\n\n\t\tthis.input = this.input.replace(/\\t/g, state.tab);\n\t\tchar = this.scanUnsafeChars();\n\n\t\tif (char >= 0) {\n\t\t\tthis.trigger(\"warning\", { code: \"W100\", line: this.line, character: char });\n\t\t}\n\n\t\t// If there is a limit on line length, warn when lines get too\n\t\t// long.\n\n\t\tif (state.option.maxlen && state.option.maxlen < this.input.length) {\n\t\t\tthis.trigger(\"warning\", { code: \"W101\", line: this.line, character: this.input.length });\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/*\n\t * This is simply a synonym for nextLine() method with a friendlier\n\t * public name.\n\t */\n\tstart: function () {\n\t\tthis.nextLine();\n\t},\n\n\t/*\n\t * Produce the next token. This function is called by advance() to get\n\t * the next token. It retuns a token in a JSLint-compatible format.\n\t */\n\ttoken: function () {\n\t\tvar token;\n\n\t\tfunction isReserved(token, isProperty) {\n\t\t\tif (!token.reserved) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (token.meta && token.meta.isFutureReservedWord) {\n\t\t\t\t// ES3 FutureReservedWord in an ES5 environment.\n\t\t\t\tif (state.option.es5 && !token.meta.es5) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Some ES5 FutureReservedWord identifiers are active only\n\t\t\t\t// within a strict mode environment.\n\t\t\t\tif (token.meta.strictOnly) {\n\t\t\t\t\tif (!state.option.strict && !state.directive[\"use strict\"]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isProperty) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Produce a token object.\n\t\tvar create = function (type, value, isProperty) {\n\t\t\t/*jshint validthis:true */\n\t\t\tvar obj;\n\n\t\t\tif (type !== \"(endline)\" && type !== \"(end)\") {\n\t\t\t\tthis.prereg = false;\n\t\t\t}\n\n\t\t\tif (type === \"(punctuator)\") {\n\t\t\t\tswitch (value) {\n\t\t\t\tcase \".\":\n\t\t\t\tcase \")\":\n\t\t\t\tcase \"~\":\n\t\t\t\tcase \"#\":\n\t\t\t\tcase \"]\":\n\t\t\t\t\tthis.prereg = false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.prereg = true;\n\t\t\t\t}\n\n\t\t\t\tobj = Object.create(state.syntax[value] || state.syntax[\"(error)\"]);\n\t\t\t}\n\n\t\t\tif (type === \"(identifier)\") {\n\t\t\t\tif (value === \"return\" || value === \"case\" || value === \"typeof\") {\n\t\t\t\t\tthis.prereg = true;\n\t\t\t\t}\n\n\t\t\t\tif (_.has(state.syntax, value)) {\n\t\t\t\t\tobj = Object.create(state.syntax[value] || state.syntax[\"(error)\"]);\n\n\t\t\t\t\t// If this can't be a reserved keyword, reset the object.\n\t\t\t\t\tif (!isReserved(obj, isProperty && type === \"(identifier)\")) {\n\t\t\t\t\t\tobj = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!obj) {\n\t\t\t\tobj = Object.create(state.syntax[type]);\n\t\t\t}\n\n\t\t\tobj.identifier = (type === \"(identifier)\");\n\t\t\tobj.type = obj.type || type;\n\t\t\tobj.value = value;\n\t\t\tobj.line = this.line;\n\t\t\tobj.character = this.char;\n\t\t\tobj.from = this.from;\n\n\t\t\tif (isProperty && obj.identifier) {\n\t\t\t\tobj.isProperty = isProperty;\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}.bind(this);\n\n\t\tfor (;;) {\n\t\t\tif (!this.input.length) {\n\t\t\t\treturn create(this.nextLine() ? \"(endline)\" : \"(end)\", \"\");\n\t\t\t}\n\n\t\t\ttoken = this.next();\n\n\t\t\tif (!token) {\n\t\t\t\tif (this.input.length) {\n\t\t\t\t\t// Unexpected character.\n\t\t\t\t\tthis.trigger(\"error\", {\n\t\t\t\t\t\tcode: \"E024\",\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\tdata: [ this.peek() ]\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.input = \"\";\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (token.type) {\n\t\t\tcase Token.StringLiteral:\n\t\t\t\tthis.trigger(\"String\", {\n\t\t\t\t\tline: this.line,\n\t\t\t\t\tchar: this.char,\n\t\t\t\t\tfrom: this.from,\n\t\t\t\t\tvalue: token.value,\n\t\t\t\t\tquote: token.quote\n\t\t\t\t});\n\n\t\t\t\treturn create(\"(string)\", token.value);\n\t\t\tcase Token.Identifier:\n\t\t\t\tthis.trigger(\"Identifier\", {\n\t\t\t\t\tline: this.line,\n\t\t\t\t\tchar: this.char,\n\t\t\t\t\tfrom: this.form,\n\t\t\t\t\tname: token.value,\n\t\t\t\t\tisProperty: state.tokens.curr.id === \".\"\n\t\t\t\t});\n\n\t\t\t\t/* falls through */\n\t\t\tcase Token.Keyword:\n\t\t\tcase Token.NullLiteral:\n\t\t\tcase Token.BooleanLiteral:\n\t\t\t\treturn create(\"(identifier)\", token.value, state.tokens.curr.id === \".\");\n\n\t\t\tcase Token.NumericLiteral:\n\t\t\t\tif (token.isMalformed) {\n\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\tcode: \"W045\",\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\tdata: [ token.value ]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (state.jsonMode && token.base === 16) {\n\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\tcode: \"W114\",\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\tdata: [ \"0x-\" ]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (state.directive[\"use strict\"] && token.base === 8) {\n\t\t\t\t\tthis.trigger(\"warning\", {\n\t\t\t\t\t\tcode: \"W115\",\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.trigger(\"Number\", {\n\t\t\t\t\tline: this.line,\n\t\t\t\t\tchar: this.char,\n\t\t\t\t\tfrom: this.from,\n\t\t\t\t\tvalue: token.value,\n\t\t\t\t\tbase: token.base,\n\t\t\t\t\tisMalformed: token.malformed\n\t\t\t\t});\n\n\t\t\t\treturn create(\"(number)\", token.value);\n\n\t\t\tcase Token.RegExp:\n\t\t\t\treturn create(\"(regexp)\", token.value);\n\n\t\t\tcase Token.Comment:\n\t\t\t\tstate.tokens.curr.comment = true;\n\n\t\t\t\tif (token.isSpecial) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: token.value,\n\t\t\t\t\t\tbody: token.body,\n\t\t\t\t\t\ttype: token.commentType,\n\t\t\t\t\t\tisSpecial: token.isSpecial,\n\t\t\t\t\t\tline: this.line,\n\t\t\t\t\t\tcharacter: this.char,\n\t\t\t\t\t\tfrom: this.from\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"\":\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn create(\"(punctuator)\", token.value);\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.Lexer = Lexer;\n//@ sourceURL=/src/stable/lex.js"
));

require.define("/src/stable/reg.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Regular expressions. Some of these are stupidly long.\n */\n\n/*jshint maxlen:1000 */\n\n\"use string\";\n\n// Unsafe comment or string (ax)\nexports.unsafeString =\n\t/@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i;\n\n// Unsafe characters that are silently deleted by one or more browsers (cx)\nexports.unsafeChars =\n\t/[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n\n// Characters in strings that need escaping (nx and nxg)\nexports.needEsc =\n\t/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n\nexports.needEscGlobal =\n\t/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n// Star slash (lx)\nexports.starSlash = /\\*\\//;\n\n// Identifier (ix)\nexports.identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;\n\n// JavaScript URL (jx)\nexports.javascriptURL = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i;\n\n// Catches /* falls through */ comments (ft)\nexports.fallsThrough = /^\\s*\\/\\*\\s*falls\\sthrough\\s*\\*\\/\\s*$/;\n//@ sourceURL=/src/stable/reg.js"
));

require.define("/src/stable/state.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nvar state = {\n\tsyntax: {},\n\n\treset: function () {\n\t\tthis.tokens = {\n\t\t\tprev: null,\n\t\t\tnext: null,\n\t\t\tcurr: null\n\t\t},\n\n\t\tthis.option = {};\n\t\tthis.directive = {};\n\t\tthis.jsonMode = false;\n\t\tthis.lines = [];\n\t\tthis.tab = \"\";\n\t\tthis.cache = {}; // Node.JS doesn't have Map. Sniff.\n\t}\n};\n\nexports.state = state;\n//@ sourceURL=/src/stable/state.js"
));

require.define("/src/stable/style.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\";\n\nexports.register = function (linter) {\n\t// Check for properties named __proto__. This special property was\n\t// deprecated and then re-introduced for ES6.\n\n\tlinter.on(\"Identifier\", function style_scanProto(data) {\n\t\tif (linter.getOption(\"proto\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (data.name === \"__proto__\") {\n\t\t\tlinter.warn(\"W103\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char,\n\t\t\t\tdata: [ data.name ]\n\t\t\t});\n\t\t}\n\t});\n\n\t// Check for properties named __iterator__. This is a special property\n\t// available only in browsers with JavaScript 1.7 implementation.\n\n\tlinter.on(\"Identifier\", function style_scanIterator(data) {\n\t\tif (linter.getOption(\"iterator\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (data.name === \"__iterator__\") {\n\t\t\tlinter.warn(\"W104\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char,\n\t\t\t\tdata: [ data.name ]\n\t\t\t});\n\t\t}\n\t});\n\n\t// Check for dangling underscores.\n\n\tlinter.on(\"Identifier\", function style_scanDangling(data) {\n\t\tif (!linter.getOption(\"nomen\")) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Underscore.js\n\t\tif (data.name === \"_\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// In Node, __dirname and __filename should be ignored.\n\t\tif (linter.getOption(\"node\")) {\n\t\t\tif (/^(__dirname|__filename)$/.test(data.name) && !data.isProperty) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (/^(_+.*|.*_+)$/.test(data.name)) {\n\t\t\tlinter.warn(\"W105\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.from,\n\t\t\t\tdata: [ \"dangling '_'\", data.name ]\n\t\t\t});\n\t\t}\n\t});\n\n\t// Check that all identifiers are using camelCase notation.\n\t// Exceptions: names like MY_VAR and _myVar.\n\n\tlinter.on(\"Identifier\", function style_scanCamelCase(data) {\n\t\tif (!linter.getOption(\"camelcase\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (data.name.replace(/^_+/, \"\").indexOf(\"_\") > -1 && !data.name.match(/^[A-Z0-9_]*$/)) {\n\t\t\tlinter.warn(\"W106\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.from,\n\t\t\t\tdata: [ data.name ]\n\t\t\t});\n\t\t}\n\t});\n\n\t// Enforce consistency in style of quoting.\n\n\tlinter.on(\"String\", function style_scanQuotes(data) {\n\t\tvar quotmark = linter.getOption(\"quotmark\");\n\t\tvar code;\n\n\t\tif (!quotmark) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If quotmark is set to 'single' warn about all double-quotes.\n\n\t\tif (quotmark === \"single\" && data.quote !== \"'\") {\n\t\t\tcode = \"W109\";\n\t\t}\n\n\t\t// If quotmark is set to 'double' warn about all single-quotes.\n\n\t\tif (quotmark === \"double\" && data.quote !== \"\\\"\") {\n\t\t\tcode = \"W108\";\n\t\t}\n\n\t\t// If quotmark is set to true, remember the first quotation style\n\t\t// and then warn about all others.\n\n\t\tif (quotmark === true) {\n\t\t\tif (!linter.getCache(\"quotmark\")) {\n\t\t\t\tlinter.setCache(\"quotmark\", data.quote);\n\t\t\t}\n\n\t\t\tif (linter.getCache(\"quotmark\") !== data.quote) {\n\t\t\t\tcode = \"W110\";\n\t\t\t}\n\t\t}\n\n\t\tif (code) {\n\t\t\tlinter.warn(code, {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char,\n\t\t\t});\n\t\t}\n\t});\n\n\tlinter.on(\"Number\", function style_scanNumbers(data) {\n\t\tif (data.value.charAt(0) === \".\") {\n\t\t\t// Warn about a leading decimal point.\n\t\t\tlinter.warn(\"W008\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char,\n\t\t\t\tdata: [ data.value ]\n\t\t\t});\n\t\t}\n\n\t\tif (data.value.substr(data.value.length - 1) === \".\") {\n\t\t\t// Warn about a trailing decimal point.\n\t\t\tlinter.warn(\"W047\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char,\n\t\t\t\tdata: [ data.value ]\n\t\t\t});\n\t\t}\n\n\t\tif (/^00+/.test(data.value)) {\n\t\t\t// Multiple leading zeroes.\n\t\t\tlinter.warn(\"W046\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char,\n\t\t\t\tdata: [ data.value ]\n\t\t\t});\n\t\t}\n\t});\n\n\t// Warn about script URLs.\n\n\tlinter.on(\"String\", function style_scanJavaScriptURLs(data) {\n\t\tvar re = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i;\n\n\t\tif (linter.getOption(\"scripturl\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (re.test(data.value)) {\n\t\t\tlinter.warn(\"W107\", {\n\t\t\t\tline: data.line,\n\t\t\t\tchar: data.char\n\t\t\t});\n\t\t}\n\t});\n};\n//@ sourceURL=/src/stable/style.js"
));

require.define("/src/stable/jshint.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n * JSHint, by JSHint Community.\n *\n * This file (and this file only) is licensed under the same slightly modified\n * MIT license that JSLint is. It stops evil-doers everywhere:\n *\n *\t Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n *\n *\t Permission is hereby granted, free of charge, to any person obtaining\n *\t a copy of this software and associated documentation files (the \"Software\"),\n *\t to deal in the Software without restriction, including without limitation\n *\t the rights to use, copy, modify, merge, publish, distribute, sublicense,\n *\t and/or sell copies of the Software, and to permit persons to whom\n *\t the Software is furnished to do so, subject to the following conditions:\n *\n *\t The above copyright notice and this permission notice shall be included\n *\t in all copies or substantial portions of the Software.\n *\n *\t The Software shall be used for Good, not Evil.\n *\n *\t THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *\t IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *\t FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *\t AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *\t LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n *\t FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n *\t DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*jshint quotmark:double */\n\nvar _        = require(\"underscore\");\nvar events   = require(\"events\");\nvar vars     = require(\"../shared/vars.js\");\nvar messages = require(\"../shared/messages.js\");\nvar Lexer    = require(\"./lex.js\").Lexer;\nvar reg      = require(\"./reg.js\");\nvar state    = require(\"./state.js\").state;\nvar style    = require(\"./style.js\");\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSHINT function itself.\n\nvar JSHINT = (function () {\n\t\"use strict\";\n\n\tvar anonname,\t\t// The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n\t\tbang = {\n\t\t\t\"<\"  : true,\n\t\t\t\"<=\" : true,\n\t\t\t\"==\" : true,\n\t\t\t\"===\": true,\n\t\t\t\"!==\": true,\n\t\t\t\"!=\" : true,\n\t\t\t\">\"  : true,\n\t\t\t\">=\" : true,\n\t\t\t\"+\"  : true,\n\t\t\t\"-\"  : true,\n\t\t\t\"*\"  : true,\n\t\t\t\"/\"  : true,\n\t\t\t\"%\"  : true\n\t\t},\n\n\t\t// These are the JSHint boolean options.\n\t\tboolOptions = {\n\t\t\tasi         : true, // if automatic semicolon insertion should be tolerated\n\t\t\tbitwise     : true, // if bitwise operators should not be allowed\n\t\t\tboss        : true, // if advanced usage of assignments should be allowed\n\t\t\tbrowser     : true, // if the standard browser globals should be predefined\n\t\t\tcamelcase   : true, // if identifiers should be required in camel case\n\t\t\tcouch       : true, // if CouchDB globals should be predefined\n\t\t\tcurly       : true, // if curly braces around all blocks should be required\n\t\t\tdebug       : true, // if debugger statements should be allowed\n\t\t\tdevel       : true, // if logging globals should be predefined (console, alert, etc.)\n\t\t\tdojo        : true, // if Dojo Toolkit globals should be predefined\n\t\t\teqeqeq      : true, // if === should be required\n\t\t\teqnull      : true, // if == null comparisons should be tolerated\n\t\t\tes5         : true, // if ES5 syntax should be allowed\n\t\t\tesnext      : true, // if es.next specific syntax should be allowed\n\t\t\tevil        : true, // if eval should be allowed\n\t\t\texpr        : true, // if ExpressionStatement should be allowed as Programs\n\t\t\tforin       : true, // if for in statements must filter\n\t\t\tfuncscope   : true, // if only function scope should be used for scope tests\n\t\t\tgcl         : true, // if JSHint should be compatible with Google Closure Linter\n\t\t\tglobalstrict: true, // if global \"use strict\"; should be allowed (also enables 'strict')\n\t\t\timmed       : true, // if immediate invocations must be wrapped in parens\n\t\t\titerator    : true, // if the `__iterator__` property should be allowed\n\t\t\tjquery      : true, // if jQuery globals should be predefined\n\t\t\tlastsemic   : true, // if semicolons may be ommitted for the trailing\n\t\t\t                    // statements inside of a one-line blocks.\n\t\t\tlatedef     : true, // if the use before definition should not be tolerated\n\t\t\tlaxbreak    : true, // if line breaks should not be checked\n\t\t\tlaxcomma    : true, // if line breaks should not be checked around commas\n\t\t\tloopfunc    : true, // if functions should be allowed to be defined within\n\t\t\t                    // loops\n\t\t\tmootools    : true, // if MooTools globals should be predefined\n\t\t\tmultistr    : true, // allow multiline strings\n\t\t\tnewcap      : true, // if constructor names must be capitalized\n\t\t\tnoarg       : true, // if arguments.caller and arguments.callee should be\n\t\t\t                    // disallowed\n\t\t\tnode        : true, // if the Node.js environment globals should be\n\t\t\t                    // predefined\n\t\t\tnoempty     : true, // if empty blocks should be disallowed\n\t\t\tnonew       : true, // if using `new` for side-effects should be disallowed\n\t\t\tnonstandard : true, // if non-standard (but widely adopted) globals should\n\t\t\t                    // be predefined\n\t\t\tnomen       : true, // if names should be checked\n\t\t\tonevar      : true, // if only one var statement per function should be\n\t\t\t                    // allowed\n\t\t\tpassfail    : true, // if the scan should stop on first error\n\t\t\tphantom     : true, // if PhantomJS symbols should be allowed\n\t\t\tplusplus    : true, // if increment/decrement should not be allowed\n\t\t\tproto       : true, // if the `__proto__` property should be allowed\n\t\t\tprototypejs : true, // if Prototype and Scriptaculous globals should be\n\t\t\t                    // predefined\n\t\t\trhino       : true, // if the Rhino environment globals should be predefined\n\t\t\tundef       : true, // if variables should be declared before used\n\t\t\tscripturl   : true, // if script-targeted URLs should be tolerated\n\t\t\tshadow      : true, // if variable shadowing should be tolerated\n\t\t\tsmarttabs   : true, // if smarttabs should be tolerated\n\t\t\t                    // (http://www.emacswiki.org/emacs/SmartTabs)\n\t\t\tstrict      : true, // require the \"use strict\"; pragma\n\t\t\tsub         : true, // if all forms of subscript notation are tolerated\n\t\t\tsupernew    : true, // if `new function () { ... };` and `new Object;`\n\t\t\t                    // should be tolerated\n\t\t\ttrailing    : true, // if trailing whitespace rules apply\n\t\t\tvalidthis   : true, // if 'this' inside a non-constructor function is valid.\n\t\t\t                    // This is a function scoped option only.\n\t\t\twithstmt    : true, // if with statements should be allowed\n\t\t\twhite       : true, // if strict whitespace rules apply\n\t\t\tworker      : true, // if Web Worker script symbols should be allowed\n\t\t\twsh         : true, // if the Windows Scripting Host environment globals\n\t\t\t                    // should be predefined\n\t\t\tyui         : true, // YUI variables should be predefined\n\n\t\t\t// Obsolete options\n\t\t\tonecase     : true, // if one case switch statements should be allowed\n\t\t\tregexp      : true, // if the . should not be allowed in regexp literals\n\t\t\tregexdash   : true  // if unescaped first/last dash (-) inside brackets\n\t\t\t                    // should be tolerated\n\t\t},\n\n\t\t// These are the JSHint options that can take any value\n\t\t// (we use this object to detect invalid options)\n\t\tvalOptions = {\n\t\t\tmaxlen       : false,\n\t\t\tindent       : false,\n\t\t\tmaxerr       : false,\n\t\t\tpredef       : false,\n\t\t\tquotmark     : false, //'single'|'double'|true\n\t\t\tscope        : false,\n\t\t\tmaxstatements: false, // {int} max statements per function\n\t\t\tmaxdepth     : false, // {int} max nested block depth per function\n\t\t\tmaxparams    : false, // {int} max params per function\n\t\t\tmaxcomplexity: false, // {int} max cyclomatic complexity per function\n\t\t\tunused       : true  // warn if variables are unused. Available options:\n\t\t\t                     //   false    - don't check for unused variables\n\t\t\t                     //   true     - \"vars\" + check last function param\n\t\t\t                     //   \"vars\"   - skip checking unused function params\n\t\t\t                     //   \"strict\" - \"vars\" + check all function params\n\t\t},\n\n\t\t// These are JSHint boolean options which are shared with JSLint\n\t\t// where the definition in JSHint is opposite JSLint\n\t\tinvertedOptions = {\n\t\t\tbitwise : true,\n\t\t\tforin   : true,\n\t\t\tnewcap  : true,\n\t\t\tnomen   : true,\n\t\t\tplusplus: true,\n\t\t\tregexp  : true,\n\t\t\tundef   : true,\n\t\t\twhite   : true,\n\n\t\t\t// Inverted and renamed, use JSHint name here\n\t\t\teqeqeq  : true,\n\t\t\tonevar  : true\n\t\t},\n\n\t\t// These are JSHint boolean options which are shared with JSLint\n\t\t// where the name has been changed but the effect is unchanged\n\t\trenamedOptions = {\n\t\t\teqeq   : \"eqeqeq\",\n\t\t\tvars   : \"onevar\",\n\t\t\twindows: \"wsh\"\n\t\t},\n\n\t\tdeclared, // Globals that were declared using /*global ... */ syntax.\n\t\texported, // Variables that are used outside of the current file.\n\n\t\tfunctionicity = [\n\t\t\t\"closure\", \"exception\", \"global\", \"label\",\n\t\t\t\"outer\", \"unused\", \"var\"\n\t\t],\n\n\t\tfunct, // The current function\n\t\tfunctions, // All of the functions\n\n\t\tglobal, // The global scope\n\t\tignored, // Ignored warnings\n\t\timplied, // Implied globals\n\t\tinblock,\n\t\tindent,\n\t\tlookahead,\n\t\tlex,\n\t\tmember,\n\t\tmembersOnly,\n\t\tnoreach,\n\t\tpredefined,\t\t// Global variables defined by option\n\n\t\tscope,  // The current scope\n\t\tstack,\n\t\tunuseds,\n\t\turls,\n\t\tuseESNextSyntax,\n\t\twarnings,\n\n\t\textraModules = [],\n\t\temitter = new events.EventEmitter();\n\n\tfunction checkOption(name, t) {\n\t\tname = name.trim();\n\n\t\tif (/^-W\\d{3}$/g.test(name)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (valOptions[name] === undefined && boolOptions[name] === undefined) {\n\t\t\tif (t.type !== \"jslint\" || renamedOptions[name] === undefined) {\n\t\t\t\terror(\"E001\", t, name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction isString(obj) {\n\t\treturn Object.prototype.toString.call(obj) === \"[object String]\";\n\t}\n\n\tfunction isIdentifier(tkn, value) {\n\t\tif (!tkn)\n\t\t\treturn false;\n\n\t\tif (!tkn.identifier || tkn.value !== value)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\tfunction isReserved(token) {\n\t\tif (!token.reserved) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (token.meta && token.meta.isFutureReservedWord) {\n\t\t\t// ES3 FutureReservedWord in an ES5 environment.\n\t\t\tif (state.option.es5 && !token.meta.es5) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Some ES5 FutureReservedWord identifiers are active only\n\t\t\t// within a strict mode environment.\n\t\t\tif (token.meta.strictOnly) {\n\t\t\t\tif (!state.option.strict && !state.directive[\"use strict\"]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token.isProperty) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction supplant(str, data) {\n\t\treturn str.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n\t\t\tvar r = data[b];\n\t\t\treturn typeof r === \"string\" || typeof r === \"number\" ? r : a;\n\t\t});\n\t}\n\n\tfunction combine(t, o) {\n\t\tvar n;\n\t\tfor (n in o) {\n\t\t\tif (_.has(o, n) && !_.has(JSHINT.blacklist, n)) {\n\t\t\t\tt[n] = o[n];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updatePredefined() {\n\t\tObject.keys(JSHINT.blacklist).forEach(function (key) {\n\t\t\tdelete predefined[key];\n\t\t});\n\t}\n\n\tfunction assume() {\n\t\tif (state.option.couch) {\n\t\t\tcombine(predefined, vars.couch);\n\t\t}\n\n\t\tif (state.option.rhino) {\n\t\t\tcombine(predefined, vars.rhino);\n\t\t}\n\n\t\tif (state.option.phantom) {\n\t\t\tcombine(predefined, vars.phantom);\n\t\t}\n\n\t\tif (state.option.prototypejs) {\n\t\t\tcombine(predefined, vars.prototypejs);\n\t\t}\n\n\t\tif (state.option.node) {\n\t\t\tcombine(predefined, vars.node);\n\t\t}\n\n\t\tif (state.option.devel) {\n\t\t\tcombine(predefined, vars.devel);\n\t\t}\n\n\t\tif (state.option.dojo) {\n\t\t\tcombine(predefined, vars.dojo);\n\t\t}\n\n\t\tif (state.option.browser) {\n\t\t\tcombine(predefined, vars.browser);\n\t\t}\n\n\t\tif (state.option.nonstandard) {\n\t\t\tcombine(predefined, vars.nonstandard);\n\t\t}\n\n\t\tif (state.option.jquery) {\n\t\t\tcombine(predefined, vars.jquery);\n\t\t}\n\n\t\tif (state.option.mootools) {\n\t\t\tcombine(predefined, vars.mootools);\n\t\t}\n\n\t\tif (state.option.worker) {\n\t\t\tcombine(predefined, vars.worker);\n\t\t}\n\n\t\tif (state.option.wsh) {\n\t\t\tcombine(predefined, vars.wsh);\n\t\t}\n\n\t\tif (state.option.esnext) {\n\t\t\tuseESNextSyntax();\n\t\t}\n\n\t\tif (state.option.globalstrict && state.option.strict !== false) {\n\t\t\tstate.option.strict = true;\n\t\t}\n\n\t\tif (state.option.yui) {\n\t\t\tcombine(predefined, vars.yui);\n\t\t}\n\t}\n\n\n\t// Produce an error warning.\n\tfunction quit(code, line, chr) {\n\t\tvar percentage = Math.floor((line / state.lines.length) * 100);\n\t\tvar message = messages.errors[code].desc;\n\n\t\tthrow {\n\t\t\tname: \"JSHintError\",\n\t\t\tline: line,\n\t\t\tcharacter: chr,\n\t\t\tmessage: message + \" (\" + percentage + \"% scanned).\",\n\t\t\traw: message\n\t\t};\n\t}\n\n\tfunction isundef(scope, code, token, a) {\n\t\treturn JSHINT.undefs.push([scope, code, token, a]);\n\t}\n\n\tfunction warning(code, t, a, b, c, d) {\n\t\tvar ch, l, w, msg;\n\n\t\tif (/^W\\d{3}$/.test(code)) {\n\t\t\tif (ignored[code]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmsg = messages.warnings[code];\n\t\t} else if (/E\\d{3}/.test(code)) {\n\t\t\tmsg = messages.errors[code];\n\t\t} else if (/I\\d{3}/.test(code)) {\n\t\t\tmsg = messages.info[code];\n\t\t}\n\n\t\tt = t || state.tokens.next;\n\t\tif (t.id === \"(end)\") {  // `~\n\t\t\tt = state.tokens.curr;\n\t\t}\n\n\t\tl = t.line || 0;\n\t\tch = t.from || 0;\n\n\t\tw = {\n\t\t\tid: \"(error)\",\n\t\t\traw: msg.desc,\n\t\t\tcode: msg.code,\n\t\t\tevidence: state.lines[l - 1] || \"\",\n\t\t\tline: l,\n\t\t\tcharacter: ch,\n\t\t\tscope: JSHINT.scope,\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\td: d\n\t\t};\n\n\t\tw.reason = supplant(msg.desc, w);\n\t\tJSHINT.errors.push(w);\n\n\t\tif (state.option.passfail) {\n\t\t\tquit(\"E042\", l, ch);\n\t\t}\n\n\t\twarnings += 1;\n\t\tif (warnings >= state.option.maxerr) {\n\t\t\tquit(\"E043\", l, ch);\n\t\t}\n\n\t\treturn w;\n\t}\n\n\tfunction warningAt(m, l, ch, a, b, c, d) {\n\t\treturn warning(m, {\n\t\t\tline: l,\n\t\t\tfrom: ch\n\t\t}, a, b, c, d);\n\t}\n\n\tfunction error(m, t, a, b, c, d) {\n\t\twarning(m, t, a, b, c, d);\n\t}\n\n\tfunction errorAt(m, l, ch, a, b, c, d) {\n\t\treturn error(m, {\n\t\t\tline: l,\n\t\t\tfrom: ch\n\t\t}, a, b, c, d);\n\t}\n\n\t// Tracking of \"internal\" scripts, like eval containing a static string\n\tfunction addInternalSrc(elem, src) {\n\t\tvar i;\n\t\ti = {\n\t\t\tid: \"(internal)\",\n\t\t\telem: elem,\n\t\t\tvalue: src\n\t\t};\n\t\tJSHINT.internals.push(i);\n\t\treturn i;\n\t}\n\n\tfunction addlabel(t, type, tkn) {\n\t\t// Define t in the current function in the current scope.\n\t\tif (type === \"exception\") {\n\t\t\tif (_.has(funct[\"(context)\"], t)) {\n\t\t\t\tif (funct[t] !== true && !state.option.node) {\n\t\t\t\t\twarning(\"W002\", state.tokens.next, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_.has(funct, t) && !funct[\"(global)\"]) {\n\t\t\tif (funct[t] === true) {\n\t\t\t\tif (state.option.latedef)\n\t\t\t\t\twarning(\"W003\", state.tokens.next, t);\n\t\t\t} else {\n\t\t\t\tif (!state.option.shadow && type !== \"exception\") {\n\t\t\t\t\twarning(\"W004\", state.tokens.next, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunct[t] = type;\n\n\t\tif (tkn) {\n\t\t\tfunct[\"(tokens)\"][t] = tkn;\n\t\t}\n\n\t\tif (funct[\"(global)\"]) {\n\t\t\tglobal[t] = funct;\n\t\t\tif (_.has(implied, t)) {\n\t\t\t\tif (state.option.latedef) {\n\t\t\t\t\twarning(\"W003\", state.tokens.next, t);\n\t\t\t\t}\n\n\t\t\t\tdelete implied[t];\n\t\t\t}\n\t\t} else {\n\t\t\tscope[t] = funct;\n\t\t}\n\t}\n\n\tfunction doOption() {\n\t\tvar nt = state.tokens.next;\n\t\tvar body = nt.body.split(\",\").map(function (s) { return s.trim(); });\n\t\tvar predef = {};\n\n\t\tif (nt.type === \"globals\") {\n\t\t\tbody.forEach(function (g) {\n\t\t\t\tg = g.split(\":\");\n\t\t\t\tvar key = g[0];\n\t\t\t\tvar val = g[1];\n\n\t\t\t\tif (key.charAt(0) === \"-\") {\n\t\t\t\t\tkey = key.slice(1);\n\t\t\t\t\tval = false;\n\n\t\t\t\t\tJSHINT.blacklist[key] = key;\n\t\t\t\t\tupdatePredefined();\n\t\t\t\t} else {\n\t\t\t\t\tpredef[key] = (val === \"true\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcombine(predefined, predef);\n\n\t\t\tfor (var key in predef) {\n\t\t\t\tif (_.has(predef, key)) {\n\t\t\t\t\tdeclared[key] = nt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (nt.type === \"exported\") {\n\t\t\tbody.forEach(function (e) {\n\t\t\t\texported[e] = true;\n\t\t\t});\n\t\t}\n\n\t\tif (nt.type === \"members\") {\n\t\t\tmembersOnly = membersOnly || {};\n\n\t\t\tbody.forEach(function (m) {\n\t\t\t\tvar ch1 = m.charAt(0);\n\t\t\t\tvar ch2 = m.charAt(m.length - 1);\n\n\t\t\t\tif (ch1 === ch2 && (ch1 === \"\\\"\" || ch1 === \"'\")) {\n\t\t\t\t\tm = m\n\t\t\t\t\t\t.substr(1, m.length - 2)\n\t\t\t\t\t\t.replace(\"\\\\b\", \"\\b\")\n\t\t\t\t\t\t.replace(\"\\\\t\", \"\\t\")\n\t\t\t\t\t\t.replace(\"\\\\n\", \"\\n\")\n\t\t\t\t\t\t.replace(\"\\\\v\", \"\\v\")\n\t\t\t\t\t\t.replace(\"\\\\f\", \"\\f\")\n\t\t\t\t\t\t.replace(\"\\\\r\", \"\\r\")\n\t\t\t\t\t\t.replace(\"\\\\\\\\\", \"\\\\\")\n\t\t\t\t\t\t.replace(\"\\\\\\\"\", \"\\\"\");\n\t\t\t\t}\n\n\t\t\t\tmembersOnly[m] = false;\n\t\t\t});\n\t\t}\n\n\t\tvar numvals = [\n\t\t\t\"maxstatements\",\n\t\t\t\"maxparams\",\n\t\t\t\"maxdepth\",\n\t\t\t\"maxcomplexity\",\n\t\t\t\"maxerr\",\n\t\t\t\"maxlen\",\n\t\t\t\"indent\"\n\t\t];\n\n\t\tif (nt.type === \"jshint\" || nt.type === \"jslint\") {\n\t\t\tbody.forEach(function (g) {\n\t\t\t\tg = g.split(\":\");\n\t\t\t\tvar key = (g[0] || \"\").trim();\n\t\t\t\tvar val = (g[1] || \"\").trim();\n\n\t\t\t\tif (!checkOption(key, nt)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (numvals.indexOf(key) >= 0) {\n\t\t\t\t\tval = +val;\n\n\t\t\t\t\tif (typeof val !== \"number\" || !isFinite(val) || val <= 0 || Math.floor(val) !== val) {\n\t\t\t\t\t\terror(\"E032\", nt, g[1].trim());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key === \"indent\") {\n\t\t\t\t\t\tstate.option[\"(explicitIndent)\"] = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.option[key] = val;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key === \"validthis\") {\n\t\t\t\t\t// `validthis` is valid only within a function scope.\n\t\t\t\t\tif (funct[\"(global)\"]) {\n\t\t\t\t\t\terror(\"E009\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (val === \"true\" || val === \"false\") {\n\t\t\t\t\t\t\tstate.option.validthis = (val === \"true\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\terror(\"E002\", nt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key === \"quotmark\") {\n\t\t\t\t\tswitch (val) {\n\t\t\t\t\tcase \"true\":\n\t\t\t\t\tcase \"false\":\n\t\t\t\t\t\tstate.option.quotmark = (val === \"true\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"double\":\n\t\t\t\t\tcase \"single\":\n\t\t\t\t\t\tstate.option.quotmark = val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror(\"E002\", nt);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key === \"unused\") {\n\t\t\t\t\tswitch (val) {\n\t\t\t\t\tcase \"true\":\n\t\t\t\t\t\tstate.option.unused = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"false\":\n\t\t\t\t\t\tstate.option.unused = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"vars\":\n\t\t\t\t\tcase \"strict\":\n\t\t\t\t\t\tstate.option.unused = val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror(\"E002\", nt);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (/^-W\\d{3}$/g.test(key)) {\n\t\t\t\t\tignored[key.slice(1)] = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tn;\n\t\t\t\tif (val === \"true\" || val === \"false\") {\n\t\t\t\t\tif (nt.type === \"jslint\") {\n\t\t\t\t\t\ttn = renamedOptions[key] || key;\n\t\t\t\t\t\tstate.option[tn] = (val === \"true\");\n\n\t\t\t\t\t\tif (invertedOptions[tn] !== undefined) {\n\t\t\t\t\t\t\tstate.option[tn] = !state.option[tn];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.option[key] = (val === \"true\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key === \"newcap\") {\n\t\t\t\t\t\tstate.option[\"(explicitNewcap)\"] = true;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terror(\"E002\", nt);\n\t\t\t});\n\n\t\t\tassume();\n\t\t}\n\t}\n\n\t// We need a peek function. If it has an argument, it peeks that much farther\n\t// ahead. It is used to distinguish\n\t//\t   for ( var i in ...\n\t// from\n\t//\t   for ( var i = ...\n\n\tfunction peek(p) {\n\t\tvar i = p || 0, j = 0, t;\n\n\t\twhile (j <= i) {\n\t\t\tt = lookahead[j];\n\t\t\tif (!t) {\n\t\t\t\tt = lookahead[j] = lex.token();\n\t\t\t}\n\t\t\tj += 1;\n\t\t}\n\t\treturn t;\n\t}\n\n\t// Produce the next token. It looks for programming errors.\n\n\tfunction advance(id, t) {\n\t\tswitch (state.tokens.curr.id) {\n\t\tcase \"(number)\":\n\t\t\tif (state.tokens.next.id === \".\") {\n\t\t\t\twarning(\"W005\", state.tokens.curr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"-\":\n\t\t\tif (state.tokens.next.id === \"-\" || state.tokens.next.id === \"--\") {\n\t\t\t\twarning(\"W006\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"+\":\n\t\t\tif (state.tokens.next.id === \"+\" || state.tokens.next.id === \"++\") {\n\t\t\t\twarning(\"W007\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state.tokens.curr.type === \"(string)\" || state.tokens.curr.identifier) {\n\t\t\tanonname = state.tokens.curr.value;\n\t\t}\n\n\t\tif (id && state.tokens.next.id !== id) {\n\t\t\tif (t) {\n\t\t\t\tif (state.tokens.next.id === \"(end)\") {\n\t\t\t\t\terror(\"E019\", t, t.id);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"E020\", state.tokens.next, id, t.id, t.line, state.tokens.next.value);\n\t\t\t\t}\n\t\t\t} else if (state.tokens.next.type !== \"(identifier)\" || state.tokens.next.value !== id) {\n\t\t\t\twarning(\"W116\", state.tokens.next, id, state.tokens.next.value);\n\t\t\t}\n\t\t}\n\n\t\tstate.tokens.prev = state.tokens.curr;\n\t\tstate.tokens.curr = state.tokens.next;\n\t\tfor (;;) {\n\t\t\tstate.tokens.next = lookahead.shift() || lex.token();\n\n\t\t\tif (!state.tokens.next) { // No more tokens left, give up\n\t\t\t\tquit(\"E041\", state.tokens.curr.line);\n\t\t\t}\n\n\t\t\tif (state.tokens.next.id === \"(end)\" || state.tokens.next.id === \"(error)\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (state.tokens.next.isSpecial) {\n\t\t\t\tdoOption();\n\t\t\t} else {\n\t\t\t\tif (state.tokens.next.id !== \"(endline)\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// This is the heart of JSHINT, the Pratt parser. In addition to parsing, it\n\t// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n\t// like .nud except that it is only used on the first token of a statement.\n\t// Having .fud makes it much easier to define statement-oriented languages like\n\t// JavaScript. I retained Pratt's nomenclature.\n\n\t// .nud  Null denotation\n\t// .fud  First null denotation\n\t// .led  Left denotation\n\t//  lbp  Left binding power\n\t//  rbp  Right binding power\n\n\t// They are elements of the parsing method called Top Down Operator Precedence.\n\n\tfunction expression(rbp, initial) {\n\t\tvar left, isArray = false, isObject = false;\n\n\t\tif (state.tokens.next.id === \"(end)\")\n\t\t\terror(\"E006\", state.tokens.curr);\n\n\t\tadvance();\n\n\t\tif (initial) {\n\t\t\tanonname = \"anonymous\";\n\t\t\tfunct[\"(verb)\"] = state.tokens.curr.value;\n\t\t}\n\n\t\tif (initial === true && state.tokens.curr.fud) {\n\t\t\tleft = state.tokens.curr.fud();\n\t\t} else {\n\t\t\tif (state.tokens.curr.nud) {\n\t\t\t\tleft = state.tokens.curr.nud();\n\t\t\t} else {\n\t\t\t\terror(\"E030\", state.tokens.curr, state.tokens.curr.id);\n\t\t\t}\n\n\t\t\twhile (rbp < state.tokens.next.lbp) {\n\t\t\t\tisArray = state.tokens.curr.value === \"Array\";\n\t\t\t\tisObject = state.tokens.curr.value === \"Object\";\n\n\t\t\t\t// #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()\n\t\t\t\t// Line breaks in IfStatement heads exist to satisfy the checkJSHint\n\t\t\t\t// \"Line too long.\" error.\n\t\t\t\tif (left && (left.value || (left.first && left.first.value))) {\n\t\t\t\t\t// If the left.value is not \"new\", or the left.first.value is a \".\"\n\t\t\t\t\t// then safely assume that this is not \"new Array()\" and possibly\n\t\t\t\t\t// not \"new Object()\"...\n\t\t\t\t\tif (left.value !== \"new\" ||\n\t\t\t\t\t  (left.first && left.first.value && left.first.value === \".\")) {\n\t\t\t\t\t\tisArray = false;\n\t\t\t\t\t\t// ...In the case of Object, if the left.value and state.tokens.curr.value\n\t\t\t\t\t\t// are not equal, then safely assume that this not \"new Object()\"\n\t\t\t\t\t\tif (left.value !== state.tokens.curr.value) {\n\t\t\t\t\t\t\tisObject = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tadvance();\n\n\t\t\t\tif (isArray && state.tokens.curr.id === \"(\" && state.tokens.next.id === \")\") {\n\t\t\t\t\twarning(\"W009\", state.tokens.curr);\n\t\t\t\t}\n\n\t\t\t\tif (isObject && state.tokens.curr.id === \"(\" && state.tokens.next.id === \")\") {\n\t\t\t\t\twarning(\"W010\", state.tokens.curr);\n\t\t\t\t}\n\n\t\t\t\tif (state.tokens.curr.led) {\n\t\t\t\t\tleft = state.tokens.curr.led(left);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"E033\", state.tokens.curr, state.tokens.curr.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\n// Functions for conformance of style.\n\n\tfunction adjacent(left, right) {\n\t\tleft = left || state.tokens.curr;\n\t\tright = right || state.tokens.next;\n\t\tif (state.option.white) {\n\t\t\tif (left.character !== right.from && left.line === right.line) {\n\t\t\t\tleft.from += (left.character - left.from);\n\t\t\t\twarning(\"W011\", left, left.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction nobreak(left, right) {\n\t\tleft = left || state.tokens.curr;\n\t\tright = right || state.tokens.next;\n\t\tif (state.option.white && (left.character !== right.from || left.line !== right.line)) {\n\t\t\twarning(\"W012\", right, right.value);\n\t\t}\n\t}\n\n\tfunction nospace(left, right) {\n\t\tleft = left || state.tokens.curr;\n\t\tright = right || state.tokens.next;\n\t\tif (state.option.white && !left.comment) {\n\t\t\tif (left.line === right.line) {\n\t\t\t\tadjacent(left, right);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction nonadjacent(left, right) {\n\t\tif (state.option.white) {\n\t\t\tleft = left || state.tokens.curr;\n\t\t\tright = right || state.tokens.next;\n\n\t\t\tif (left.value === \";\" && right.value === \";\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (left.line === right.line && left.character === right.from) {\n\t\t\t\tleft.from += (left.character - left.from);\n\t\t\t\twarning(\"W013\", left, left.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction nobreaknonadjacent(left, right) {\n\t\tleft = left || state.tokens.curr;\n\t\tright = right || state.tokens.next;\n\t\tif (!state.option.laxbreak && left.line !== right.line) {\n\t\t\twarning(\"W014\", right, right.id);\n\t\t} else if (state.option.white) {\n\t\t\tleft = left || state.tokens.curr;\n\t\t\tright = right || state.tokens.next;\n\t\t\tif (left.character === right.from) {\n\t\t\t\tleft.from += (left.character - left.from);\n\t\t\t\twarning(\"W013\", left, left.value);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction indentation(bias) {\n\t\tif (!state.option.white && !state.option[\"(explicitIndent)\"]) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (state.tokens.next.id === \"(end)\") {\n\t\t\treturn;\n\t\t}\n\n\t\tvar i = indent + (bias || 0);\n\t\tif (state.tokens.next.from !== i) {\n\t\t\twarning(\"W015\", state.tokens.next, state.tokens.next.value, i, state.tokens.next.from);\n\t\t}\n\t}\n\n\tfunction nolinebreak(t) {\n\t\tt = t || state.tokens.curr;\n\t\tif (t.line !== state.tokens.next.line) {\n\t\t\twarning(\"E022\", t, t.value);\n\t\t}\n\t}\n\n\n\tfunction comma(opts) {\n\t\topts = opts || {};\n\n\t\tif (state.tokens.curr.line !== state.tokens.next.line) {\n\t\t\tif (!state.option.laxcomma) {\n\t\t\t\tif (comma.first) {\n\t\t\t\t\twarning(\"I001\");\n\t\t\t\t\tcomma.first = false;\n\t\t\t\t}\n\t\t\t\twarning(\"W014\", state.tokens.curr, state.tokens.next.id);\n\t\t\t}\n\t\t} else if (!state.tokens.curr.comment &&\n\t\t\t\tstate.tokens.curr.character !== state.tokens.next.from && state.option.white) {\n\t\t\tstate.tokens.curr.from += (state.tokens.curr.character - state.tokens.curr.from);\n\t\t\twarning(\"W011\", state.tokens.curr, state.tokens.curr.value);\n\t\t}\n\n\t\tadvance(\",\");\n\n\t\t// TODO: This is a temporary solution to fight against false-positives in\n\t\t// arrays and objects with trailing commas (see GH-363). The best solution\n\t\t// would be to extract all whitespace rules out of parser.\n\n\t\tif (state.tokens.next.value !== \"]\" && state.tokens.next.value !== \"}\") {\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t}\n\n\t\tif (state.tokens.next.identifier) {\n\t\t\t// Keywords that cannot follow a comma operator.\n\t\t\tswitch (state.tokens.next.value) {\n\t\t\tcase \"break\":\n\t\t\tcase \"case\":\n\t\t\tcase \"catch\":\n\t\t\tcase \"continue\":\n\t\t\tcase \"default\":\n\t\t\tcase \"do\":\n\t\t\tcase \"else\":\n\t\t\tcase \"finally\":\n\t\t\tcase \"for\":\n\t\t\tcase \"if\":\n\t\t\tcase \"in\":\n\t\t\tcase \"instanceof\":\n\t\t\tcase \"return\":\n\t\t\tcase \"switch\":\n\t\t\tcase \"throw\":\n\t\t\tcase \"try\":\n\t\t\tcase \"var\":\n\t\t\tcase \"while\":\n\t\t\tcase \"with\":\n\t\t\t\terror(\"E024\", state.tokens.next, state.tokens.next.value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (state.tokens.next.type === \"(punctuator)\") {\n\t\t\tswitch (state.tokens.next.value) {\n\t\t\tcase \"}\":\n\t\t\tcase \"]\":\n\t\t\tcase \",\":\n\t\t\t\tif (opts.allowTrailing) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/* falls through */\n\t\t\tcase \")\":\n\t\t\t\terror(\"E024\", state.tokens.next, state.tokens.next.value);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Functional constructors for making the symbols that will be inherited by\n\t// tokens.\n\n\tfunction symbol(s, p) {\n\t\tvar x = state.syntax[s];\n\t\tif (!x || typeof x !== \"object\") {\n\t\t\tstate.syntax[s] = x = {\n\t\t\t\tid: s,\n\t\t\t\tlbp: p,\n\t\t\t\tvalue: s\n\t\t\t};\n\t\t}\n\t\treturn x;\n\t}\n\n\tfunction delim(s) {\n\t\treturn symbol(s, 0);\n\t}\n\n\tfunction stmt(s, f) {\n\t\tvar x = delim(s);\n\t\tx.identifier = x.reserved = true;\n\t\tx.fud = f;\n\t\treturn x;\n\t}\n\n\tfunction blockstmt(s, f) {\n\t\tvar x = stmt(s, f);\n\t\tx.block = true;\n\t\treturn x;\n\t}\n\n\tfunction reserveName(x) {\n\t\tvar c = x.id.charAt(0);\n\t\tif ((c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\")) {\n\t\t\tx.identifier = x.reserved = true;\n\t\t}\n\t\treturn x;\n\t}\n\n\tfunction prefix(s, f) {\n\t\tvar x = symbol(s, 150);\n\t\treserveName(x);\n\t\tx.nud = (typeof f === \"function\") ? f : function () {\n\t\t\tthis.right = expression(150);\n\t\t\tthis.arity = \"unary\";\n\t\t\tif (this.id === \"++\" || this.id === \"--\") {\n\t\t\t\tif (state.option.plusplus) {\n\t\t\t\t\twarning(\"W016\", this, this.id);\n\t\t\t\t} else if ((!this.right.identifier || isReserved(this.right)) &&\n\t\t\t\t\t\tthis.right.id !== \".\" && this.right.id !== \"[\") {\n\t\t\t\t\twarning(\"W017\", this);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t\treturn x;\n\t}\n\n\tfunction type(s, f) {\n\t\tvar x = delim(s);\n\t\tx.type = s;\n\t\tx.nud = f;\n\t\treturn x;\n\t}\n\n\tfunction reserve(name, func) {\n\t\tvar x = type(name, func);\n\t\tx.identifier = true;\n\t\tx.reserved = true;\n\t\treturn x;\n\t}\n\n\tfunction FutureReservedWord(name, meta) {\n\t\tvar x = type(name, function () {\n\t\t\treturn this;\n\t\t});\n\n\t\tmeta = meta || {};\n\t\tmeta.isFutureReservedWord = true;\n\n\t\tx.value = name;\n\t\tx.identifier = true;\n\t\tx.reserved = true;\n\t\tx.meta = meta;\n\n\t\treturn x;\n\t}\n\n\tfunction reservevar(s, v) {\n\t\treturn reserve(s, function () {\n\t\t\tif (typeof v === \"function\") {\n\t\t\t\tv(this);\n\t\t\t}\n\t\t\treturn this;\n\t\t});\n\t}\n\n\tfunction infix(s, f, p, w) {\n\t\tvar x = symbol(s, p);\n\t\treserveName(x);\n\t\tx.led = function (left) {\n\t\t\tif (!w) {\n\t\t\t\tnobreaknonadjacent(state.tokens.prev, state.tokens.curr);\n\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t}\n\t\t\tif (s === \"in\" && left.id === \"!\") {\n\t\t\t\twarning(\"W018\", left, \"!\");\n\t\t\t}\n\t\t\tif (typeof f === \"function\") {\n\t\t\t\treturn f(left, this);\n\t\t\t} else {\n\t\t\t\tthis.left = left;\n\t\t\t\tthis.right = expression(p);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t\treturn x;\n\t}\n\n\tfunction relation(s, f) {\n\t\tvar x = symbol(s, 100);\n\n\t\tx.led = function (left) {\n\t\t\tnobreaknonadjacent(state.tokens.prev, state.tokens.curr);\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\tvar right = expression(100);\n\n\t\t\tif (isIdentifier(left, \"NaN\") || isIdentifier(right, \"NaN\")) {\n\t\t\t\twarning(\"W019\", this);\n\t\t\t} else if (f) {\n\t\t\t\tf.apply(this, [left, right]);\n\t\t\t}\n\n\t\t\tif (!left || !right) {\n\t\t\t\tquit(\"E041\", state.tokens.curr.line);\n\t\t\t}\n\n\t\t\tif (left.id === \"!\") {\n\t\t\t\twarning(\"W018\", left, \"!\");\n\t\t\t}\n\n\t\t\tif (right.id === \"!\") {\n\t\t\t\twarning(\"W018\", right, \"!\");\n\t\t\t}\n\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\treturn this;\n\t\t};\n\t\treturn x;\n\t}\n\n\tfunction isPoorRelation(node) {\n\t\treturn node &&\n\t\t\t  ((node.type === \"(number)\" && +node.value === 0) ||\n\t\t\t   (node.type === \"(string)\" && node.value === \"\") ||\n\t\t\t   (node.type === \"null\" && !state.option.eqnull) ||\n\t\t\t\tnode.type === \"true\" ||\n\t\t\t\tnode.type === \"false\" ||\n\t\t\t\tnode.type === \"undefined\");\n\t}\n\n\tfunction assignop(s) {\n\t\tsymbol(s, 20).exps = true;\n\n\t\treturn infix(s, function (left, that) {\n\t\t\tthat.left = left;\n\n\t\t\tif (predefined[left.value] === false &&\n\t\t\t\t\tscope[left.value][\"(global)\"] === true) {\n\t\t\t\twarning(\"W020\", left);\n\t\t\t} else if (left[\"function\"]) {\n\t\t\t\twarning(\"W021\", left, left.value);\n\t\t\t}\n\n\t\t\tif (left) {\n\t\t\t\tif (state.option.esnext && funct[left.value] === \"const\") {\n\t\t\t\t\terror(\"E013\", left, left.value);\n\t\t\t\t}\n\n\t\t\t\tif (left.id === \".\" || left.id === \"[\") {\n\t\t\t\t\tif (!left.left || left.left.value === \"arguments\") {\n\t\t\t\t\t\twarning(\"E031\", that);\n\t\t\t\t\t}\n\t\t\t\t\tthat.right = expression(19);\n\t\t\t\t\treturn that;\n\t\t\t\t} else if (left.identifier && !isReserved(left)) {\n\t\t\t\t\tif (funct[left.value] === \"exception\") {\n\t\t\t\t\t\twarning(\"W022\", left);\n\t\t\t\t\t}\n\t\t\t\t\tthat.right = expression(19);\n\t\t\t\t\treturn that;\n\t\t\t\t}\n\n\t\t\t\tif (left === state.syntax[\"function\"]) {\n\t\t\t\t\twarning(\"W023\", state.tokens.curr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terror(\"E031\", that);\n\t\t}, 20);\n\t}\n\n\n\tfunction bitwise(s, f, p) {\n\t\tvar x = symbol(s, p);\n\t\treserveName(x);\n\t\tx.led = (typeof f === \"function\") ? f : function (left) {\n\t\t\tif (state.option.bitwise) {\n\t\t\t\twarning(\"W016\", this, this.id);\n\t\t\t}\n\t\t\tthis.left = left;\n\t\t\tthis.right = expression(p);\n\t\t\treturn this;\n\t\t};\n\t\treturn x;\n\t}\n\n\n\tfunction bitwiseassignop(s) {\n\t\tsymbol(s, 20).exps = true;\n\t\treturn infix(s, function (left, that) {\n\t\t\tif (state.option.bitwise) {\n\t\t\t\twarning(\"W016\", that, that.id);\n\t\t\t}\n\t\t\tnonadjacent(state.tokens.prev, state.tokens.curr);\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\tif (left) {\n\t\t\t\tif (left.id === \".\" || left.id === \"[\" ||\n\t\t\t\t\t\t(left.identifier && !isReserved(left))) {\n\t\t\t\t\texpression(19);\n\t\t\t\t\treturn that;\n\t\t\t\t}\n\t\t\t\tif (left === state.syntax[\"function\"]) {\n\t\t\t\t\twarning(\"W023\", state.tokens.curr);\n\t\t\t\t}\n\t\t\t\treturn that;\n\t\t\t}\n\t\t\terror(\"E031\", that);\n\t\t}, 20);\n\t}\n\n\n\tfunction suffix(s) {\n\t\tvar x = symbol(s, 150);\n\n\t\tx.led = function (left) {\n\t\t\tif (state.option.plusplus) {\n\t\t\t\twarning(\"W016\", this, this.id);\n\t\t\t} else if ((!left.identifier || isReserved(left)) && left.id !== \".\" && left.id !== \"[\") {\n\t\t\t\twarning(\"W017\", this);\n\t\t\t}\n\n\t\t\tthis.left = left;\n\t\t\treturn this;\n\t\t};\n\t\treturn x;\n\t}\n\n\t// fnparam means that this identifier is being defined as a function\n\t// argument (see identifier())\n\t// prop means that this identifier is that of an object property\n\n\tfunction optionalidentifier(fnparam, prop) {\n\t\tif (!state.tokens.next.identifier) {\n\t\t\treturn;\n\t\t}\n\n\t\tadvance();\n\n\t\tvar curr = state.tokens.curr;\n\t\tvar meta = curr.meta || {};\n\t\tvar val  = state.tokens.curr.value;\n\n\t\tif (!isReserved(curr)) {\n\t\t\treturn val;\n\t\t}\n\n\t\tif (prop) {\n\t\t\tif (state.option.es5 || meta.isFutureReservedWord) {\n\t\t\t\treturn val;\n\t\t\t}\n\t\t}\n\n\t\tif (fnparam && val === \"undefined\") {\n\t\t\treturn val;\n\t\t}\n\n\t\twarning(\"W024\", state.tokens.curr, state.tokens.curr.id);\n\t\treturn val;\n\t}\n\n\t// fnparam means that this identifier is being defined as a function\n\t// argument\n\t// prop means that this identifier is that of an object property\n\tfunction identifier(fnparam, prop) {\n\t\tvar i = optionalidentifier(fnparam, prop);\n\t\tif (i) {\n\t\t\treturn i;\n\t\t}\n\t\tif (state.tokens.curr.id === \"function\" && state.tokens.next.id === \"(\") {\n\t\t\twarning(\"W025\");\n\t\t} else {\n\t\t\terror(\"E030\", state.tokens.next, state.tokens.next.value);\n\t\t}\n\t}\n\n\n\tfunction reachable(s) {\n\t\tvar i = 0, t;\n\t\tif (state.tokens.next.id !== \";\" || noreach) {\n\t\t\treturn;\n\t\t}\n\t\tfor (;;) {\n\t\t\tt = peek(i);\n\t\t\tif (t.reach) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (t.id !== \"(endline)\") {\n\t\t\t\tif (t.id === \"function\") {\n\t\t\t\t\tif (!state.option.latedef) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\twarning(\"W026\", t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\twarning(\"W027\", t, t.value, s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 1;\n\t\t}\n\t}\n\n\n\tfunction statement(noindent) {\n\t\tvar i = indent, r, s = scope, t = state.tokens.next;\n\n\t\tif (t.id === \";\") {\n\t\t\tadvance(\";\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Is this a labelled statement?\n\t\tvar res = isReserved(t);\n\n\t\t// We're being more tolerant here: if someone uses\n\t\t// a FutureReservedWord as a label, we warn but proceed\n\t\t// anyway.\n\n\t\tif (res && t.meta && t.meta.isFutureReservedWord) {\n\t\t\twarning(\"W024\", t, t.id);\n\t\t\tres = false;\n\t\t}\n\n\t\tif (t.identifier && !res && peek().id === \":\") {\n\t\t\tadvance();\n\t\t\tadvance(\":\");\n\t\t\tscope = Object.create(s);\n\t\t\taddlabel(t.value, \"label\");\n\n\t\t\tif (!state.tokens.next.labelled && state.tokens.next.value !== \"{\") {\n\t\t\t\twarning(\"W028\", state.tokens.next, t.value, state.tokens.next.value);\n\t\t\t}\n\n\t\t\tif (reg.javascriptURL.test(t.value + \":\")) {\n\t\t\t\twarning(\"W029\", t, t.value);\n\t\t\t}\n\n\t\t\tstate.tokens.next.label = t.value;\n\t\t\tt = state.tokens.next;\n\t\t}\n\n\t\t// Is it a lonely block?\n\n\t\tif (t.id === \"{\") {\n\t\t\tblock(true, true);\n\t\t\treturn;\n\t\t}\n\n\t\t// Parse the statement.\n\n\t\tif (!noindent) {\n\t\t\tindentation();\n\t\t}\n\t\tr = expression(0, true);\n\n\t\t// Look for the final semicolon.\n\n\t\tif (!t.block) {\n\t\t\tif (!state.option.expr && (!r || !r.exps)) {\n\t\t\t\twarning(\"W030\", state.tokens.curr);\n\t\t\t} else if (state.option.nonew && r.id === \"(\" && r.left.id === \"new\") {\n\t\t\t\twarning(\"W031\", t);\n\t\t\t}\n\n\t\t\tif (state.tokens.next.id === \",\") {\n\t\t\t\treturn comma();\n\t\t\t}\n\n\t\t\tif (state.tokens.next.id !== \";\") {\n\t\t\t\tif (!state.option.asi) {\n\t\t\t\t\t// If this is the last statement in a block that ends on\n\t\t\t\t\t// the same line *and* option lastsemic is on, ignore the warning.\n\t\t\t\t\t// Otherwise, complain about missing semicolon.\n\t\t\t\t\tif (!state.option.lastsemic || state.tokens.next.id !== \"}\" ||\n\t\t\t\t\t\tstate.tokens.next.line !== state.tokens.curr.line) {\n\t\t\t\t\t\twarningAt(\"W033\", state.tokens.curr.line, state.tokens.curr.character);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\tadvance(\";\");\n\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t}\n\t\t}\n\n\t\t// Restore the indentation.\n\n\t\tindent = i;\n\t\tscope = s;\n\t\treturn r;\n\t}\n\n\n\tfunction statements(startLine) {\n\t\tvar a = [], p;\n\n\t\twhile (!state.tokens.next.reach && state.tokens.next.id !== \"(end)\") {\n\t\t\tif (state.tokens.next.id === \";\") {\n\t\t\t\tp = peek();\n\n\t\t\t\tif (!p || (p.id !== \"(\" && p.id !== \"[\")) {\n\t\t\t\t\twarning(\"W032\");\n\t\t\t\t}\n\n\t\t\t\tadvance(\";\");\n\t\t\t} else {\n\t\t\t\ta.push(statement(startLine === state.tokens.next.line));\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\n\t/*\n\t * read all directives\n\t * recognizes a simple form of asi, but always\n\t * warns, if it is used\n\t */\n\tfunction directives() {\n\t\tvar i, p, pn;\n\n\t\tfor (;;) {\n\t\t\tif (state.tokens.next.id === \"(string)\") {\n\t\t\t\tp = peek(0);\n\t\t\t\tif (p.id === \"(endline)\") {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tpn = peek(i);\n\t\t\t\t\t\ti = i + 1;\n\t\t\t\t\t} while (pn.id === \"(endline)\");\n\n\t\t\t\t\tif (pn.id !== \";\") {\n\t\t\t\t\t\tif (pn.id !== \"(string)\" && pn.id !== \"(number)\" &&\n\t\t\t\t\t\t\tpn.id !== \"(regexp)\" && pn.identifier !== true &&\n\t\t\t\t\t\t\tpn.id !== \"}\") {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twarning(\"W033\", state.tokens.next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = pn;\n\t\t\t\t\t}\n\t\t\t\t} else if (p.id === \"}\") {\n\t\t\t\t\t// Directive with no other statements, warn about missing semicolon\n\t\t\t\t\twarning(\"W033\", p);\n\t\t\t\t} else if (p.id !== \";\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tindentation();\n\t\t\t\tadvance();\n\t\t\t\tif (state.directive[state.tokens.curr.value]) {\n\t\t\t\t\twarning(\"W034\", state.tokens.curr, state.tokens.curr.value);\n\t\t\t\t}\n\n\t\t\t\tif (state.tokens.curr.value === \"use strict\") {\n\t\t\t\t\tif (!state.option[\"(explicitNewcap)\"])\n\t\t\t\t\t\tstate.option.newcap = true;\n\t\t\t\t\tstate.option.undef = true;\n\t\t\t\t}\n\n\t\t\t\t// there's no directive negation, so always set to true\n\t\t\t\tstate.directive[state.tokens.curr.value] = true;\n\n\t\t\t\tif (p.id === \";\") {\n\t\t\t\t\tadvance(\";\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/*\n\t * Parses a single block. A block is a sequence of statements wrapped in\n\t * braces.\n\t *\n\t * ordinary - true for everything but function bodies and try blocks.\n\t * stmt\t\t- true if block can be a single statement (e.g. in if/for/while).\n\t * isfunc\t- true if block is a function body\n\t */\n\tfunction block(ordinary, stmt, isfunc) {\n\t\tvar a,\n\t\t\tb = inblock,\n\t\t\told_indent = indent,\n\t\t\tm,\n\t\t\ts = scope,\n\t\t\tt,\n\t\t\tline,\n\t\t\td;\n\n\t\tinblock = ordinary;\n\n\t\tif (!ordinary || !state.option.funcscope)\n\t\t\tscope = Object.create(scope);\n\n\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\tt = state.tokens.next;\n\n\t\tvar metrics = funct[\"(metrics)\"];\n\t\tmetrics.nestedBlockDepth += 1;\n\t\tmetrics.verifyMaxNestedBlockDepthPerFunction();\n\n\t\tif (state.tokens.next.id === \"{\") {\n\t\t\tadvance(\"{\");\n\t\t\tline = state.tokens.curr.line;\n\t\t\tif (state.tokens.next.id !== \"}\") {\n\t\t\t\tindent += state.option.indent;\n\t\t\t\twhile (!ordinary && state.tokens.next.from > indent) {\n\t\t\t\t\tindent += state.option.indent;\n\t\t\t\t}\n\n\t\t\t\tif (isfunc) {\n\t\t\t\t\tm = {};\n\t\t\t\t\tfor (d in state.directive) {\n\t\t\t\t\t\tif (_.has(state.directive, d)) {\n\t\t\t\t\t\t\tm[d] = state.directive[d];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdirectives();\n\n\t\t\t\t\tif (state.option.strict && funct[\"(context)\"][\"(global)\"]) {\n\t\t\t\t\t\tif (!m[\"use strict\"] && !state.directive[\"use strict\"]) {\n\t\t\t\t\t\t\twarning(\"E007\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ta = statements(line);\n\n\t\t\t\tmetrics.statementCount += a.length;\n\n\t\t\t\tif (isfunc) {\n\t\t\t\t\tstate.directive = m;\n\t\t\t\t}\n\n\t\t\t\tindent -= state.option.indent;\n\t\t\t\tif (line !== state.tokens.next.line) {\n\t\t\t\t\tindentation();\n\t\t\t\t}\n\t\t\t} else if (line !== state.tokens.next.line) {\n\t\t\t\tindentation();\n\t\t\t}\n\t\t\tadvance(\"}\", t);\n\t\t\tindent = old_indent;\n\t\t} else if (!ordinary) {\n\t\t\terror(\"E021\", state.tokens.next, \"{\", state.tokens.next.value);\n\t\t} else {\n\t\t\tif (!stmt || state.option.curly) {\n\t\t\t\twarning(\"W116\", state.tokens.next, \"{\", state.tokens.next.value);\n\t\t\t}\n\n\t\t\tnoreach = true;\n\t\t\tindent += state.option.indent;\n\t\t\t// test indentation only if statement is in new line\n\t\t\ta = [statement(state.tokens.next.line === state.tokens.curr.line)];\n\t\t\tindent -= state.option.indent;\n\t\t\tnoreach = false;\n\t\t}\n\t\tfunct[\"(verb)\"] = null;\n\t\tif (!ordinary || !state.option.funcscope) scope = s;\n\t\tinblock = b;\n\t\tif (ordinary && state.option.noempty && (!a || a.length === 0)) {\n\t\t\twarning(\"W035\");\n\t\t}\n\t\tmetrics.nestedBlockDepth -= 1;\n\t\treturn a;\n\t}\n\n\n\tfunction countMember(m) {\n\t\tif (membersOnly && typeof membersOnly[m] !== \"boolean\") {\n\t\t\twarning(\"W036\", state.tokens.curr, m);\n\t\t}\n\t\tif (typeof member[m] === \"number\") {\n\t\t\tmember[m] += 1;\n\t\t} else {\n\t\t\tmember[m] = 1;\n\t\t}\n\t}\n\n\n\tfunction note_implied(tkn) {\n\t\tvar name = tkn.value, line = tkn.line, a = implied[name];\n\t\tif (typeof a === \"function\") {\n\t\t\ta = false;\n\t\t}\n\n\t\tif (!a) {\n\t\t\ta = [line];\n\t\t\timplied[name] = a;\n\t\t} else if (a[a.length - 1] !== line) {\n\t\t\ta.push(line);\n\t\t}\n\t}\n\n\n\t// Build the syntax table by declaring the syntactic elements of the language.\n\n\ttype(\"(number)\", function () {\n\t\treturn this;\n\t});\n\n\ttype(\"(string)\", function () {\n\t\treturn this;\n\t});\n\n\tstate.syntax[\"(identifier)\"] = {\n\t\ttype: \"(identifier)\",\n\t\tlbp: 0,\n\t\tidentifier: true,\n\t\tnud: function () {\n\t\t\tvar v = this.value,\n\t\t\t\ts = scope[v],\n\t\t\t\tf;\n\n\t\t\tif (typeof s === \"function\") {\n\t\t\t\t// Protection against accidental inheritance.\n\t\t\t\ts = undefined;\n\t\t\t} else if (typeof s === \"boolean\") {\n\t\t\t\tf = funct;\n\t\t\t\tfunct = functions[0];\n\t\t\t\taddlabel(v, \"var\");\n\t\t\t\ts = funct;\n\t\t\t\tfunct = f;\n\t\t\t}\n\n\t\t\t// The name is in scope and defined in the current function.\n\t\t\tif (funct === s) {\n\t\t\t\t// Change 'unused' to 'var', and reject labels.\n\t\t\t\tswitch (funct[v]) {\n\t\t\t\tcase \"unused\":\n\t\t\t\t\tfunct[v] = \"var\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unction\":\n\t\t\t\t\tfunct[v] = \"function\";\n\t\t\t\t\tthis[\"function\"] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tthis[\"function\"] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"label\":\n\t\t\t\t\twarning(\"W037\", state.tokens.curr, v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (funct[\"(global)\"]) {\n\t\t\t\t// The name is not defined in the function.  If we are in the global\n\t\t\t\t// scope, then we have an undefined variable.\n\t\t\t\t//\n\t\t\t\t// Operators typeof and delete do not raise runtime errors even if\n\t\t\t\t// the base object of a reference is null so no need to display warning\n\t\t\t\t// if we're inside of typeof or delete.\n\n\t\t\t\tif (typeof predefined[v] !== \"boolean\") {\n\t\t\t\t\t// Attempting to subscript a null reference will throw an\n\t\t\t\t\t// error, even within the typeof and delete operators\n\t\t\t\t\tif (!(anonname === \"typeof\" || anonname === \"delete\") ||\n\t\t\t\t\t\t(state.tokens.next && (state.tokens.next.value === \".\" ||\n\t\t\t\t\t\t\tstate.tokens.next.value === \"[\"))) {\n\n\t\t\t\t\t\tisundef(funct, \"W117\", state.tokens.curr, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnote_implied(state.tokens.curr);\n\t\t\t} else {\n\t\t\t\t// If the name is already defined in the current\n\t\t\t\t// function, but not as outer, then there is a scope error.\n\n\t\t\t\tswitch (funct[v]) {\n\t\t\t\tcase \"closure\":\n\t\t\t\tcase \"function\":\n\t\t\t\tcase \"var\":\n\t\t\t\tcase \"unused\":\n\t\t\t\t\twarning(\"W038\", state.tokens.curr, v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"label\":\n\t\t\t\t\twarning(\"W037\", state.tokens.curr, v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"outer\":\n\t\t\t\tcase \"global\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// If the name is defined in an outer function, make an outer entry,\n\t\t\t\t\t// and if it was unused, make it var.\n\t\t\t\t\tif (s === true) {\n\t\t\t\t\t\tfunct[v] = true;\n\t\t\t\t\t} else if (s === null) {\n\t\t\t\t\t\twarning(\"W039\", state.tokens.curr, v);\n\t\t\t\t\t\tnote_implied(state.tokens.curr);\n\t\t\t\t\t} else if (typeof s !== \"object\") {\n\t\t\t\t\t\t// Operators typeof and delete do not raise runtime errors even\n\t\t\t\t\t\t// if the base object of a reference is null so no need to\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// display warning if we're inside of typeof or delete.\n\t\t\t\t\t\t// Attempting to subscript a null reference will throw an\n\t\t\t\t\t\t// error, even within the typeof and delete operators\n\t\t\t\t\t\tif (!(anonname === \"typeof\" || anonname === \"delete\") ||\n\t\t\t\t\t\t\t(state.tokens.next &&\n\t\t\t\t\t\t\t\t(state.tokens.next.value === \".\" || state.tokens.next.value === \"[\"))) {\n\n\t\t\t\t\t\t\tisundef(funct, \"W117\", state.tokens.curr, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfunct[v] = true;\n\t\t\t\t\t\tnote_implied(state.tokens.curr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (s[v]) {\n\t\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\tcase \"unction\":\n\t\t\t\t\t\t\tthis[\"function\"] = true;\n\t\t\t\t\t\t\ts[v] = \"closure\";\n\t\t\t\t\t\t\tfunct[v] = s[\"(global)\"] ? \"global\" : \"outer\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"var\":\n\t\t\t\t\t\tcase \"unused\":\n\t\t\t\t\t\t\ts[v] = \"closure\";\n\t\t\t\t\t\t\tfunct[v] = s[\"(global)\"] ? \"global\" : \"outer\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"closure\":\n\t\t\t\t\t\t\tfunct[v] = s[\"(global)\"] ? \"global\" : \"outer\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"label\":\n\t\t\t\t\t\t\twarning(\"W037\", state.tokens.curr, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tled: function () {\n\t\t\terror(\"E033\", state.tokens.next, state.tokens.next.value);\n\t\t}\n\t};\n\n\ttype(\"(regexp)\", function () {\n\t\treturn this;\n\t});\n\n\t// ECMAScript parser\n\n\tdelim(\"(endline)\");\n\tdelim(\"(begin)\");\n\tdelim(\"(end)\").reach = true;\n\tdelim(\"(error)\").reach = true;\n\tdelim(\"}\").reach = true;\n\tdelim(\")\");\n\tdelim(\"]\");\n\tdelim(\"\\\"\").reach = true;\n\tdelim(\"'\").reach = true;\n\tdelim(\";\");\n\tdelim(\":\").reach = true;\n\tdelim(\",\");\n\tdelim(\"#\");\n\n\treserve(\"else\");\n\treserve(\"case\").reach = true;\n\treserve(\"catch\");\n\treserve(\"default\").reach = true;\n\treserve(\"finally\");\n\treservevar(\"arguments\", function (x) {\n\t\tif (state.directive[\"use strict\"] && funct[\"(global)\"]) {\n\t\t\twarning(\"E008\", x);\n\t\t}\n\t});\n\treservevar(\"eval\");\n\treservevar(\"false\");\n\treservevar(\"Infinity\");\n\treservevar(\"null\");\n\treservevar(\"this\", function (x) {\n\t\tif (state.directive[\"use strict\"] && !state.option.validthis && ((funct[\"(statement)\"] &&\n\t\t\t\tfunct[\"(name)\"].charAt(0) > \"Z\") || funct[\"(global)\"])) {\n\t\t\twarning(\"W040\", x);\n\t\t}\n\t});\n\treservevar(\"true\");\n\treservevar(\"undefined\");\n\n\tassignop(\"=\", \"assign\", 20);\n\tassignop(\"+=\", \"assignadd\", 20);\n\tassignop(\"-=\", \"assignsub\", 20);\n\tassignop(\"*=\", \"assignmult\", 20);\n\tassignop(\"/=\", \"assigndiv\", 20).nud = function () {\n\t\terror(\"E014\");\n\t};\n\tassignop(\"%=\", \"assignmod\", 20);\n\n\tbitwiseassignop(\"&=\", \"assignbitand\", 20);\n\tbitwiseassignop(\"|=\", \"assignbitor\", 20);\n\tbitwiseassignop(\"^=\", \"assignbitxor\", 20);\n\tbitwiseassignop(\"<<=\", \"assignshiftleft\", 20);\n\tbitwiseassignop(\">>=\", \"assignshiftright\", 20);\n\tbitwiseassignop(\">>>=\", \"assignshiftrightunsigned\", 20);\n\tinfix(\"?\", function (left, that) {\n\t\tthat.left = left;\n\t\tthat.right = expression(10);\n\t\tadvance(\":\");\n\t\tthat[\"else\"] = expression(10);\n\t\treturn that;\n\t}, 30);\n\n\tinfix(\"||\", \"or\", 40);\n\tinfix(\"&&\", \"and\", 50);\n\tbitwise(\"|\", \"bitor\", 70);\n\tbitwise(\"^\", \"bitxor\", 80);\n\tbitwise(\"&\", \"bitand\", 90);\n\trelation(\"==\", function (left, right) {\n\t\tvar eqnull = state.option.eqnull && (left.value === \"null\" || right.value === \"null\");\n\n\t\tif (!eqnull && state.option.eqeqeq)\n\t\t\twarning(\"W116\", this, \"===\", \"==\");\n\t\telse if (isPoorRelation(left))\n\t\t\twarning(\"W041\", this, \"===\", left.value);\n\t\telse if (isPoorRelation(right))\n\t\t\twarning(\"W041\", this, \"===\", right.value);\n\n\t\treturn this;\n\t});\n\trelation(\"===\");\n\trelation(\"!=\", function (left, right) {\n\t\tvar eqnull = state.option.eqnull &&\n\t\t\t\t(left.value === \"null\" || right.value === \"null\");\n\n\t\tif (!eqnull && state.option.eqeqeq) {\n\t\t\twarning(\"W116\", this, \"!==\", \"!=\");\n\t\t} else if (isPoorRelation(left)) {\n\t\t\twarning(\"W041\", this, \"!==\", left.value);\n\t\t} else if (isPoorRelation(right)) {\n\t\t\twarning(\"W041\", this, \"!==\", right.value);\n\t\t}\n\t\treturn this;\n\t});\n\trelation(\"!==\");\n\trelation(\"<\");\n\trelation(\">\");\n\trelation(\"<=\");\n\trelation(\">=\");\n\tbitwise(\"<<\", \"shiftleft\", 120);\n\tbitwise(\">>\", \"shiftright\", 120);\n\tbitwise(\">>>\", \"shiftrightunsigned\", 120);\n\tinfix(\"in\", \"in\", 120);\n\tinfix(\"instanceof\", \"instanceof\", 120);\n\tinfix(\"+\", function (left, that) {\n\t\tvar right = expression(130);\n\t\tif (left && right && left.id === \"(string)\" && right.id === \"(string)\") {\n\t\t\tleft.value += right.value;\n\t\t\tleft.character = right.character;\n\t\t\tif (!state.option.scripturl && reg.javascriptURL.test(left.value)) {\n\t\t\t\twarning(\"W050\", left);\n\t\t\t}\n\t\t\treturn left;\n\t\t}\n\t\tthat.left = left;\n\t\tthat.right = right;\n\t\treturn that;\n\t}, 130);\n\tprefix(\"+\", \"num\");\n\tprefix(\"+++\", function () {\n\t\twarning(\"W007\");\n\t\tthis.right = expression(150);\n\t\tthis.arity = \"unary\";\n\t\treturn this;\n\t});\n\tinfix(\"+++\", function (left) {\n\t\twarning(\"W007\");\n\t\tthis.left = left;\n\t\tthis.right = expression(130);\n\t\treturn this;\n\t}, 130);\n\tinfix(\"-\", \"sub\", 130);\n\tprefix(\"-\", \"neg\");\n\tprefix(\"---\", function () {\n\t\twarning(\"W006\");\n\t\tthis.right = expression(150);\n\t\tthis.arity = \"unary\";\n\t\treturn this;\n\t});\n\tinfix(\"---\", function (left) {\n\t\twarning(\"W006\");\n\t\tthis.left = left;\n\t\tthis.right = expression(130);\n\t\treturn this;\n\t}, 130);\n\tinfix(\"*\", \"mult\", 140);\n\tinfix(\"/\", \"div\", 140);\n\tinfix(\"%\", \"mod\", 140);\n\n\tsuffix(\"++\", \"postinc\");\n\tprefix(\"++\", \"preinc\");\n\tstate.syntax[\"++\"].exps = true;\n\n\tsuffix(\"--\", \"postdec\");\n\tprefix(\"--\", \"predec\");\n\tstate.syntax[\"--\"].exps = true;\n\tprefix(\"delete\", function () {\n\t\tvar p = expression(0);\n\t\tif (!p || (p.id !== \".\" && p.id !== \"[\")) {\n\t\t\twarning(\"W051\");\n\t\t}\n\t\tthis.first = p;\n\t\treturn this;\n\t}).exps = true;\n\n\tprefix(\"~\", function () {\n\t\tif (state.option.bitwise) {\n\t\t\twarning(\"W052\", this, \"~\");\n\t\t}\n\t\texpression(150);\n\t\treturn this;\n\t});\n\n\tprefix(\"!\", function () {\n\t\tthis.right = expression(150);\n\t\tthis.arity = \"unary\";\n\n\t\tif (!this.right) { // '!' followed by nothing? Give up.\n\t\t\tquit(\"E041\", this.line || 0);\n\t\t}\n\n\t\tif (bang[this.right.id] === true) {\n\t\t\twarning(\"W018\", this, \"!\");\n\t\t}\n\t\treturn this;\n\t});\n\n\tprefix(\"typeof\", \"typeof\");\n\tprefix(\"new\", function () {\n\t\tvar c = expression(155), i;\n\t\tif (c && c.id !== \"function\") {\n\t\t\tif (c.identifier) {\n\t\t\t\tc[\"new\"] = true;\n\t\t\t\tswitch (c.value) {\n\t\t\t\tcase \"Number\":\n\t\t\t\tcase \"String\":\n\t\t\t\tcase \"Boolean\":\n\t\t\t\tcase \"Math\":\n\t\t\t\tcase \"JSON\":\n\t\t\t\t\twarning(\"W053\", state.tokens.prev, c.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Function\":\n\t\t\t\t\tif (!state.option.evil) {\n\t\t\t\t\t\twarning(\"W054\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"Date\":\n\t\t\t\tcase \"RegExp\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (c.id !== \"function\") {\n\t\t\t\t\t\ti = c.value.substr(0, 1);\n\t\t\t\t\t\tif (state.option.newcap && (i < \"A\" || i > \"Z\") && !_.has(global, c.value)) {\n\t\t\t\t\t\t\twarning(\"W055\", state.tokens.curr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c.id !== \".\" && c.id !== \"[\" && c.id !== \"(\") {\n\t\t\t\t\twarning(\"W056\", state.tokens.curr);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!state.option.supernew)\n\t\t\t\twarning(\"W057\", this);\n\t\t}\n\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\tif (state.tokens.next.id !== \"(\" && !state.option.supernew) {\n\t\t\twarning(\"W058\", state.tokens.curr, state.tokens.curr.value);\n\t\t}\n\t\tthis.first = c;\n\t\treturn this;\n\t});\n\tstate.syntax[\"new\"].exps = true;\n\n\tprefix(\"void\").exps = true;\n\n\tinfix(\".\", function (left, that) {\n\t\tadjacent(state.tokens.prev, state.tokens.curr);\n\t\tnobreak();\n\t\tvar m = identifier(false, true);\n\n\t\tif (typeof m === \"string\") {\n\t\t\tcountMember(m);\n\t\t}\n\n\t\tthat.left = left;\n\t\tthat.right = m;\n\n\t\tif (m && m === \"hasOwnProperty\" && state.tokens.next.value === \"=\") {\n\t\t\twarning(\"W001\");\n\t\t}\n\n\t\tif (left && left.value === \"arguments\" && (m === \"callee\" || m === \"caller\")) {\n\t\t\tif (state.option.noarg)\n\t\t\t\twarning(\"W059\", left, m);\n\t\t\telse if (state.directive[\"use strict\"])\n\t\t\t\terror(\"E008\");\n\t\t} else if (!state.option.evil && left && left.value === \"document\" &&\n\t\t\t\t(m === \"write\" || m === \"writeln\")) {\n\t\t\twarning(\"W060\", left);\n\t\t}\n\n\t\tif (!state.option.evil && (m === \"eval\" || m === \"execScript\")) {\n\t\t\twarning(\"W061\");\n\t\t}\n\n\t\treturn that;\n\t}, 160, true);\n\n\tinfix(\"(\", function (left, that) {\n\t\tif (state.tokens.prev.id !== \"}\" && state.tokens.prev.id !== \")\") {\n\t\t\tnobreak(state.tokens.prev, state.tokens.curr);\n\t\t}\n\n\t\tnospace();\n\t\tif (state.option.immed && !left.immed && left.id === \"function\") {\n\t\t\twarning(\"W062\");\n\t\t}\n\n\t\tvar n = 0;\n\t\tvar p = [];\n\n\t\tif (left) {\n\t\t\tif (left.type === \"(identifier)\") {\n\t\t\t\tif (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n\t\t\t\t\tif (\"Number String Boolean Date Object\".indexOf(left.value) === -1) {\n\t\t\t\t\t\tif (left.value === \"Math\") {\n\t\t\t\t\t\t\twarning(\"W063\", left);\n\t\t\t\t\t\t} else if (state.option.newcap) {\n\t\t\t\t\t\t\twarning(\"W064\", left);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (state.tokens.next.id !== \")\") {\n\t\t\tfor (;;) {\n\t\t\t\tp[p.length] = expression(10);\n\t\t\t\tn += 1;\n\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomma();\n\t\t\t}\n\t\t}\n\n\t\tadvance(\")\");\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\n\t\tif (typeof left === \"object\") {\n\t\t\tif (left.value === \"parseInt\" && n === 1) {\n\t\t\t\twarning(\"W065\", state.tokens.curr);\n\t\t\t}\n\t\t\tif (!state.option.evil) {\n\t\t\t\tif (left.value === \"eval\" || left.value === \"Function\" ||\n\t\t\t\t\t\tleft.value === \"execScript\") {\n\t\t\t\t\twarning(\"W061\", left);\n\n\t\t\t\t\tif (p[0] && [0].id === \"(string)\") {\n\t\t\t\t\t\taddInternalSrc(left, p[0].value);\n\t\t\t\t\t}\n\t\t\t\t} else if (p[0] && p[0].id === \"(string)\" &&\n\t\t\t\t\t   (left.value === \"setTimeout\" ||\n\t\t\t\t\t\tleft.value === \"setInterval\")) {\n\t\t\t\t\twarning(\"W066\", left);\n\t\t\t\t\taddInternalSrc(left, p[0].value);\n\n\t\t\t\t// window.setTimeout/setInterval\n\t\t\t\t} else if (p[0] && p[0].id === \"(string)\" &&\n\t\t\t\t\t   left.value === \".\" &&\n\t\t\t\t\t   left.left.value === \"window\" &&\n\t\t\t\t\t   (left.right === \"setTimeout\" ||\n\t\t\t\t\t\tleft.right === \"setInterval\")) {\n\t\t\t\t\twarning(\"W066\", left);\n\t\t\t\t\taddInternalSrc(left, p[0].value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!left.identifier && left.id !== \".\" && left.id !== \"[\" &&\n\t\t\t\t\tleft.id !== \"(\" && left.id !== \"&&\" && left.id !== \"||\" &&\n\t\t\t\t\tleft.id !== \"?\") {\n\t\t\t\twarning(\"W067\", left);\n\t\t\t}\n\t\t}\n\n\t\tthat.left = left;\n\t\treturn that;\n\t}, 155, true).exps = true;\n\n\tprefix(\"(\", function () {\n\t\tnospace();\n\n\t\tif (state.tokens.next.id === \"function\") {\n\t\t\tstate.tokens.next.immed = true;\n\t\t}\n\n\t\tvar exprs = [];\n\n\t\tif (state.tokens.next.id !== \")\") {\n\t\t\tfor (;;) {\n\t\t\t\texprs.push(expression(0));\n\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomma();\n\t\t\t}\n\t\t}\n\n\t\tadvance(\")\", this);\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\tif (state.option.immed && exprs[0].id === \"function\") {\n\t\t\tif (state.tokens.next.id !== \"(\" &&\n\t\t\t  (state.tokens.next.id !== \".\" || (peek().value !== \"call\" && peek().value !== \"apply\"))) {\n\t\t\t\twarning(\"W068\", this);\n\t\t\t}\n\t\t}\n\n\t\treturn exprs[0];\n\t});\n\n\tinfix(\"[\", function (left, that) {\n\t\tnobreak(state.tokens.prev, state.tokens.curr);\n\t\tnospace();\n\t\tvar e = expression(0), s;\n\t\tif (e && e.type === \"(string)\") {\n\t\t\tif (!state.option.evil && (e.value === \"eval\" || e.value === \"execScript\")) {\n\t\t\t\twarning(\"W061\", that);\n\t\t\t}\n\n\t\t\tcountMember(e.value);\n\t\t\tif (!state.option.sub && reg.identifier.test(e.value)) {\n\t\t\t\ts = state.syntax[e.value];\n\t\t\t\tif (!s || !isReserved(s)) {\n\t\t\t\t\twarning(\"W069\", state.tokens.prev, e.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tadvance(\"]\", that);\n\n\t\tif (e && e.value === \"hasOwnProperty\" && state.tokens.next.value === \"=\") {\n\t\t\twarning(\"W001\");\n\t\t}\n\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\tthat.left = left;\n\t\tthat.right = e;\n\t\treturn that;\n\t}, 160, true);\n\n\tprefix(\"[\", function () {\n\t\tvar b = state.tokens.curr.line !== state.tokens.next.line;\n\t\tthis.first = [];\n\t\tif (b) {\n\t\t\tindent += state.option.indent;\n\t\t\tif (state.tokens.next.from === indent + state.option.indent) {\n\t\t\t\tindent += state.option.indent;\n\t\t\t}\n\t\t}\n\t\twhile (state.tokens.next.id !== \"(end)\") {\n\t\t\twhile (state.tokens.next.id === \",\") {\n\t\t\t\tif (!state.option.es5)\n\t\t\t\t\twarning(\"W070\");\n\t\t\t\tadvance(\",\");\n\t\t\t}\n\t\t\tif (state.tokens.next.id === \"]\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (b && state.tokens.curr.line !== state.tokens.next.line) {\n\t\t\t\tindentation();\n\t\t\t}\n\t\t\tthis.first.push(expression(10));\n\t\t\tif (state.tokens.next.id === \",\") {\n\t\t\t\tcomma({ allowTrailing: true });\n\t\t\t\tif (state.tokens.next.id === \"]\" && !state.option.es5) {\n\t\t\t\t\twarning(\"W070\", state.tokens.curr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (b) {\n\t\t\tindent -= state.option.indent;\n\t\t\tindentation();\n\t\t}\n\t\tadvance(\"]\", this);\n\t\treturn this;\n\t}, 160);\n\n\n\tfunction property_name() {\n\t\tvar id = optionalidentifier(false, true);\n\n\t\tif (!id) {\n\t\t\tif (state.tokens.next.id === \"(string)\") {\n\t\t\t\tid = state.tokens.next.value;\n\t\t\t\tadvance();\n\t\t\t} else if (state.tokens.next.id === \"(number)\") {\n\t\t\t\tid = state.tokens.next.value.toString();\n\t\t\t\tadvance();\n\t\t\t}\n\t\t}\n\n\t\tif (id === \"hasOwnProperty\") {\n\t\t\twarning(\"W001\");\n\t\t}\n\n\t\treturn id;\n\t}\n\n\n\tfunction functionparams() {\n\t\tvar next   = state.tokens.next;\n\t\tvar params = [];\n\t\tvar ident;\n\n\t\tadvance(\"(\");\n\t\tnospace();\n\n\t\tif (state.tokens.next.id === \")\") {\n\t\t\tadvance(\")\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tident = identifier(true);\n\t\t\tparams.push(ident);\n\t\t\taddlabel(ident, \"unused\", state.tokens.curr);\n\t\t\tif (state.tokens.next.id === \",\") {\n\t\t\t\tcomma();\n\t\t\t} else {\n\t\t\t\tadvance(\")\", next);\n\t\t\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\t\t\treturn params;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction doFunction(name, statement) {\n\t\tvar f;\n\t\tvar oldOption = state.option;\n\t\tvar oldScope  = scope;\n\n\t\tstate.option = Object.create(state.option);\n\t\tscope  = Object.create(scope);\n\n\t\tfunct = {\n\t\t\t\"(name)\"     : name || \"\\\"\" + anonname + \"\\\"\",\n\t\t\t\"(line)\"     : state.tokens.next.line,\n\t\t\t\"(character)\": state.tokens.next.character,\n\t\t\t\"(context)\"  : funct,\n\t\t\t\"(breakage)\" : 0,\n\t\t\t\"(loopage)\"  : 0,\n\t\t\t\"(metrics)\"  : createMetrics(state.tokens.next),\n\t\t\t\"(scope)\"    : scope,\n\t\t\t\"(statement)\": statement,\n\t\t\t\"(tokens)\"   : {}\n\t\t};\n\n\t\tf = funct;\n\t\tstate.tokens.curr.funct = funct;\n\n\t\tfunctions.push(funct);\n\n\t\tif (name) {\n\t\t\taddlabel(name, \"function\");\n\t\t}\n\n\t\tfunct[\"(params)\"] = functionparams();\n\t\tfunct[\"(metrics)\"].verifyMaxParametersPerFunction(funct[\"(params)\"]);\n\n\t\tblock(false, false, true);\n\n\t\tfunct[\"(metrics)\"].verifyMaxStatementsPerFunction();\n\t\tfunct[\"(metrics)\"].verifyMaxComplexityPerFunction();\n\t\tfunct[\"(unusedOption)\"] = state.option.unused;\n\n\t\tscope = oldScope;\n\t\tstate.option = oldOption;\n\t\tfunct[\"(last)\"] = state.tokens.curr.line;\n\t\tfunct[\"(lastcharacter)\"] = state.tokens.curr.character;\n\t\tfunct = funct[\"(context)\"];\n\n\t\treturn f;\n\t}\n\n\tfunction createMetrics(functionStartToken) {\n\t\treturn {\n\t\t\tstatementCount: 0,\n\t\t\tnestedBlockDepth: -1,\n\t\t\tComplexityCount: 1,\n\t\t\tverifyMaxStatementsPerFunction: function () {\n\t\t\t\tif (state.option.maxstatements &&\n\t\t\t\t\tthis.statementCount > state.option.maxstatements) {\n\t\t\t\t\twarning(\"W071\", functionStartToken, this.statementCount);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tverifyMaxParametersPerFunction: function (params) {\n\t\t\t\tparams = params || [];\n\n\t\t\t\tif (state.option.maxparams && params.length > state.option.maxparams) {\n\t\t\t\t\twarning(\"W072\", functionStartToken, params.length);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tverifyMaxNestedBlockDepthPerFunction: function () {\n\t\t\t\tif (state.option.maxdepth &&\n\t\t\t\t\tthis.nestedBlockDepth > 0 &&\n\t\t\t\t\tthis.nestedBlockDepth === state.option.maxdepth + 1) {\n\t\t\t\t\twarning(\"W073\", null, this.nestedBlockDepth);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tverifyMaxComplexityPerFunction: function () {\n\t\t\t\tvar max = state.option.maxcomplexity;\n\t\t\t\tvar cc = this.ComplexityCount;\n\t\t\t\tif (max && cc > max) {\n\t\t\t\t\twarning(\"W074\", functionStartToken, cc);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction increaseComplexityCount() {\n\t\tfunct[\"(metrics)\"].ComplexityCount += 1;\n\t}\n\n\t// Parse assignments that were found instead of conditionals.\n\t// For example: if (a = 1) { ... }\n\n\tfunction parseCondAssignment() {\n\t\tswitch (state.tokens.next.id) {\n\t\tcase \"=\":\n\t\tcase \"+=\":\n\t\tcase \"-=\":\n\t\tcase \"*=\":\n\t\tcase \"%=\":\n\t\tcase \"&=\":\n\t\tcase \"|=\":\n\t\tcase \"^=\":\n\t\tcase \"/=\":\n\t\t\tif (!state.option.boss) {\n\t\t\t\twarning(\"W084\");\n\t\t\t}\n\n\t\t\tadvance(state.tokens.next.id);\n\t\t\texpression(20);\n\t\t}\n\t}\n\n\n\t(function (x) {\n\t\tx.nud = function () {\n\t\t\tvar b, f, i, p, t;\n\t\t\tvar props = {}; // All properties, including accessors\n\n\t\t\tfunction saveProperty(name, tkn) {\n\t\t\t\tif (props[name] && _.has(props, name))\n\t\t\t\t\twarning(\"W075\", state.tokens.next, i);\n\t\t\t\telse\n\t\t\t\t\tprops[name] = {};\n\n\t\t\t\tprops[name].basic = true;\n\t\t\t\tprops[name].basictkn = tkn;\n\t\t\t}\n\n\t\t\tfunction saveSetter(name, tkn) {\n\t\t\t\tif (props[name] && _.has(props, name)) {\n\t\t\t\t\tif (props[name].basic || props[name].setter)\n\t\t\t\t\t\twarning(\"W075\", state.tokens.next, i);\n\t\t\t\t} else {\n\t\t\t\t\tprops[name] = {};\n\t\t\t\t}\n\n\t\t\t\tprops[name].setter = true;\n\t\t\t\tprops[name].setterToken = tkn;\n\t\t\t}\n\n\t\t\tfunction saveGetter(name) {\n\t\t\t\tif (props[name] && _.has(props, name)) {\n\t\t\t\t\tif (props[name].basic || props[name].getter)\n\t\t\t\t\t\twarning(\"W075\", state.tokens.next, i);\n\t\t\t\t} else {\n\t\t\t\t\tprops[name] = {};\n\t\t\t\t}\n\n\t\t\t\tprops[name].getter = true;\n\t\t\t\tprops[name].getterToken = state.tokens.curr;\n\t\t\t}\n\n\t\t\tb = state.tokens.curr.line !== state.tokens.next.line;\n\t\t\tif (b) {\n\t\t\t\tindent += state.option.indent;\n\t\t\t\tif (state.tokens.next.from === indent + state.option.indent) {\n\t\t\t\t\tindent += state.option.indent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (;;) {\n\t\t\t\tif (state.tokens.next.id === \"}\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (b) {\n\t\t\t\t\tindentation();\n\t\t\t\t}\n\n\t\t\t\tif (state.tokens.next.value === \"get\" && peek().id !== \":\") {\n\t\t\t\t\tadvance(\"get\");\n\n\t\t\t\t\tif (!state.option.es5) {\n\t\t\t\t\t\terror(\"E034\");\n\t\t\t\t\t}\n\n\t\t\t\t\ti = property_name();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\terror(\"E035\");\n\t\t\t\t\t}\n\n\t\t\t\t\tsaveGetter(i);\n\t\t\t\t\tt = state.tokens.next;\n\t\t\t\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\t\tf = doFunction();\n\t\t\t\t\tp = f[\"(params)\"];\n\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\twarning(\"W076\", t, p[0], i);\n\t\t\t\t\t}\n\n\t\t\t\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\t} else if (state.tokens.next.value === \"set\" && peek().id !== \":\") {\n\t\t\t\t\tadvance(\"set\");\n\n\t\t\t\t\tif (!state.option.es5) {\n\t\t\t\t\t\terror(\"E034\");\n\t\t\t\t\t}\n\n\t\t\t\t\ti = property_name();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\terror(\"E035\");\n\t\t\t\t\t}\n\n\t\t\t\t\tsaveSetter(i, state.tokens.next);\n\t\t\t\t\tt = state.tokens.next;\n\t\t\t\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\t\tf = doFunction();\n\t\t\t\t\tp = f[\"(params)\"];\n\n\t\t\t\t\tif (!p || p.length !== 1) {\n\t\t\t\t\t\twarning(\"W077\", t, i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti = property_name();\n\t\t\t\t\tsaveProperty(i, state.tokens.next);\n\n\t\t\t\t\tif (typeof i !== \"string\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tadvance(\":\");\n\t\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\t\texpression(10);\n\t\t\t\t}\n\n\t\t\t\tcountMember(i);\n\t\t\t\tif (state.tokens.next.id === \",\") {\n\t\t\t\t\tcomma({ allowTrailing: true });\n\t\t\t\t\tif (state.tokens.next.id === \",\") {\n\t\t\t\t\t\twarning(\"W070\", state.tokens.curr);\n\t\t\t\t\t} else if (state.tokens.next.id === \"}\" && !state.option.es5) {\n\t\t\t\t\t\twarning(\"W070\", state.tokens.curr);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b) {\n\t\t\t\tindent -= state.option.indent;\n\t\t\t\tindentation();\n\t\t\t}\n\t\t\tadvance(\"}\", this);\n\n\t\t\t// Check for lonely setters if in the ES5 mode.\n\t\t\tif (state.option.es5) {\n\t\t\t\tfor (var name in props) {\n\t\t\t\t\tif (_.has(props, name) && props[name].setter && !props[name].getter) {\n\t\t\t\t\t\twarning(\"W078\", props[name].setterToken);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\t\tx.fud = function () {\n\t\t\terror(\"E036\", state.tokens.curr);\n\t\t};\n\t}(delim(\"{\")));\n\n\t// This Function is called when esnext option is set to true\n\t// it adds the `const` statement to JSHINT\n\n\tuseESNextSyntax = function () {\n\t\tvar conststatement = stmt(\"const\", function (prefix) {\n\t\t\tvar id, name, value;\n\n\t\t\tthis.first = [];\n\t\t\tfor (;;) {\n\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\tid = identifier();\n\t\t\t\tif (funct[id] === \"const\") {\n\t\t\t\t\twarning(\"E011\", null, id);\n\t\t\t\t}\n\t\t\t\tif (funct[\"(global)\"] && predefined[id] === false) {\n\t\t\t\t\twarning(\"W079\", state.tokens.curr, id);\n\t\t\t\t}\n\t\t\t\taddlabel(id, \"const\");\n\t\t\t\tif (prefix) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tname = state.tokens.curr;\n\t\t\t\tthis.first.push(state.tokens.curr);\n\n\t\t\t\tif (state.tokens.next.id !== \"=\") {\n\t\t\t\t\twarning(\"E012\", state.tokens.curr, id);\n\t\t\t\t}\n\n\t\t\t\tif (state.tokens.next.id === \"=\") {\n\t\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\t\tadvance(\"=\");\n\t\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\t\tif (state.tokens.next.id === \"undefined\") {\n\t\t\t\t\t\twarning(\"W080\", state.tokens.curr, id);\n\t\t\t\t\t}\n\t\t\t\t\tif (peek(0).id === \"=\" && state.tokens.next.identifier) {\n\t\t\t\t\t\terror(\"E037\", state.tokens.next, state.tokens.next.value);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = expression(0);\n\t\t\t\t\tname.first = value;\n\t\t\t\t}\n\n\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcomma();\n\t\t\t}\n\t\t\treturn this;\n\t\t});\n\t\tconststatement.exps = true;\n\t};\n\n\tvar varstatement = stmt(\"var\", function (prefix) {\n\t\t// JavaScript does not have block scope. It only has function scope. So,\n\t\t// declaring a variable in a block can have unexpected consequences.\n\t\tvar id, name, value;\n\n\t\tif (funct[\"(onevar)\"] && state.option.onevar) {\n\t\t\twarning(\"W081\");\n\t\t} else if (!funct[\"(global)\"]) {\n\t\t\tfunct[\"(onevar)\"] = true;\n\t\t}\n\n\t\tthis.first = [];\n\n\t\tfor (;;) {\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\tid = identifier();\n\n\t\t\tif (state.option.esnext && funct[id] === \"const\") {\n\t\t\t\twarning(\"E011\", null, id);\n\t\t\t}\n\n\t\t\tif (funct[\"(global)\"] && predefined[id] === false) {\n\t\t\t\twarning(\"W079\", state.tokens.curr, id);\n\t\t\t}\n\n\t\t\taddlabel(id, \"unused\", state.tokens.curr);\n\n\t\t\tif (prefix) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tname = state.tokens.curr;\n\t\t\tthis.first.push(state.tokens.curr);\n\n\t\t\tif (state.tokens.next.id === \"=\") {\n\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\tadvance(\"=\");\n\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\tif (state.tokens.next.id === \"undefined\") {\n\t\t\t\t\twarning(\"W080\", state.tokens.curr, id);\n\t\t\t\t}\n\t\t\t\tif (peek(0).id === \"=\" && state.tokens.next.identifier) {\n\t\t\t\t\terror(\"E038\", state.tokens.next, state.tokens.next.value);\n\t\t\t\t}\n\t\t\t\tvalue = expression(0);\n\t\t\t\tname.first = value;\n\t\t\t}\n\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcomma();\n\t\t}\n\t\treturn this;\n\t});\n\tvarstatement.exps = true;\n\n\tblockstmt(\"function\", function () {\n\t\tif (inblock) {\n\t\t\twarning(\"W082\", state.tokens.curr);\n\n\t\t}\n\t\tvar i = identifier();\n\t\tif (state.option.esnext && funct[i] === \"const\") {\n\t\t\twarning(\"E011\", null, i);\n\t\t}\n\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\taddlabel(i, \"unction\", state.tokens.curr);\n\n\t\tdoFunction(i, { statement: true });\n\t\tif (state.tokens.next.id === \"(\" && state.tokens.next.line === state.tokens.curr.line) {\n\t\t\terror(\"E039\");\n\t\t}\n\t\treturn this;\n\t});\n\n\tprefix(\"function\", function () {\n\t\tvar i = optionalidentifier();\n\t\tif (i || state.option.gcl) {\n\t\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\t} else {\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t}\n\t\tdoFunction(i);\n\t\tif (!state.option.loopfunc && funct[\"(loopage)\"]) {\n\t\t\twarning(\"W083\");\n\t\t}\n\t\treturn this;\n\t});\n\n\tblockstmt(\"if\", function () {\n\t\tvar t = state.tokens.next;\n\t\tincreaseComplexityCount();\n\t\tadvance(\"(\");\n\t\tnonadjacent(this, t);\n\t\tnospace();\n\t\texpression(20);\n\t\tparseCondAssignment();\n\t\tadvance(\")\", t);\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\tblock(true, true);\n\t\tif (state.tokens.next.id === \"else\") {\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\tadvance(\"else\");\n\t\t\tif (state.tokens.next.id === \"if\" || state.tokens.next.id === \"switch\") {\n\t\t\t\tstatement(true);\n\t\t\t} else {\n\t\t\t\tblock(true, true);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t});\n\n\tblockstmt(\"try\", function () {\n\t\tvar b;\n\n\t\tfunction doCatch() {\n\t\t\tvar oldScope = scope;\n\t\t\tvar e;\n\n\t\t\tadvance(\"catch\");\n\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\tadvance(\"(\");\n\n\t\t\tscope = Object.create(oldScope);\n\n\t\t\te = state.tokens.next.value;\n\t\t\tif (state.tokens.next.type !== \"(identifier)\") {\n\t\t\t\te = null;\n\t\t\t\twarning(\"E030\", state.tokens.next, e);\n\t\t\t}\n\n\t\t\tadvance();\n\t\t\tadvance(\")\");\n\n\t\t\tfunct = {\n\t\t\t\t\"(name)\"     : \"(catch)\",\n\t\t\t\t\"(line)\"     : state.tokens.next.line,\n\t\t\t\t\"(character)\": state.tokens.next.character,\n\t\t\t\t\"(context)\"  : funct,\n\t\t\t\t\"(breakage)\" : funct[\"(breakage)\"],\n\t\t\t\t\"(loopage)\"  : funct[\"(loopage)\"],\n\t\t\t\t\"(scope)\"    : scope,\n\t\t\t\t\"(statement)\": false,\n\t\t\t\t\"(metrics)\"  : createMetrics(state.tokens.next),\n\t\t\t\t\"(catch)\"    : true,\n\t\t\t\t\"(tokens)\"   : {}\n\t\t\t};\n\n\t\t\tif (e) {\n\t\t\t\taddlabel(e, \"exception\");\n\t\t\t}\n\n\t\t\tstate.tokens.curr.funct = funct;\n\t\t\tfunctions.push(funct);\n\n\t\t\tblock(false);\n\n\t\t\tscope = oldScope;\n\n\t\t\tfunct[\"(last)\"] = state.tokens.curr.line;\n\t\t\tfunct[\"(lastcharacter)\"] = state.tokens.curr.character;\n\t\t\tfunct = funct[\"(context)\"];\n\t\t}\n\n\t\tblock(false);\n\n\t\tif (state.tokens.next.id === \"catch\") {\n\t\t\tincreaseComplexityCount();\n\t\t\tdoCatch();\n\t\t\tb = true;\n\t\t}\n\n\t\tif (state.tokens.next.id === \"finally\") {\n\t\t\tadvance(\"finally\");\n\t\t\tblock(false);\n\t\t\treturn;\n\t\t} else if (!b) {\n\t\t\terror(\"E021\", state.tokens.next, \"catch\", state.tokens.next.value);\n\t\t}\n\n\t\treturn this;\n\t});\n\n\tblockstmt(\"while\", function () {\n\t\tvar t = state.tokens.next;\n\t\tfunct[\"(breakage)\"] += 1;\n\t\tfunct[\"(loopage)\"] += 1;\n\t\tincreaseComplexityCount();\n\t\tadvance(\"(\");\n\t\tnonadjacent(this, t);\n\t\tnospace();\n\t\texpression(20);\n\t\tparseCondAssignment();\n\t\tadvance(\")\", t);\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\tblock(true, true);\n\t\tfunct[\"(breakage)\"] -= 1;\n\t\tfunct[\"(loopage)\"] -= 1;\n\t\treturn this;\n\t}).labelled = true;\n\n\tblockstmt(\"with\", function () {\n\t\tvar t = state.tokens.next;\n\t\tif (state.directive[\"use strict\"]) {\n\t\t\terror(\"E010\", state.tokens.curr);\n\t\t} else if (!state.option.withstmt) {\n\t\t\twarning(\"W085\", state.tokens.curr);\n\t\t}\n\n\t\tadvance(\"(\");\n\t\tnonadjacent(this, t);\n\t\tnospace();\n\t\texpression(0);\n\t\tadvance(\")\", t);\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\tblock(true, true);\n\n\t\treturn this;\n\t});\n\n\tblockstmt(\"switch\", function () {\n\t\tvar t = state.tokens.next,\n\t\t\tg = false;\n\t\tfunct[\"(breakage)\"] += 1;\n\t\tadvance(\"(\");\n\t\tnonadjacent(this, t);\n\t\tnospace();\n\t\tthis.condition = expression(20);\n\t\tadvance(\")\", t);\n\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\tt = state.tokens.next;\n\t\tadvance(\"{\");\n\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\tindent += state.option.indent;\n\t\tthis.cases = [];\n\n\t\tfor (;;) {\n\t\t\tswitch (state.tokens.next.id) {\n\t\t\tcase \"case\":\n\t\t\t\tswitch (funct[\"(verb)\"]) {\n\t\t\t\tcase \"break\":\n\t\t\t\tcase \"case\":\n\t\t\t\tcase \"continue\":\n\t\t\t\tcase \"return\":\n\t\t\t\tcase \"switch\":\n\t\t\t\tcase \"throw\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// You can tell JSHint that you don't use break intentionally by\n\t\t\t\t\t// adding a comment /* falls through */ on a line just before\n\t\t\t\t\t// the next `case`.\n\t\t\t\t\tif (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {\n\t\t\t\t\t\twarning(\"W086\", state.tokens.curr, \"case\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindentation(-state.option.indent);\n\t\t\t\tadvance(\"case\");\n\t\t\t\tthis.cases.push(expression(20));\n\t\t\t\tincreaseComplexityCount();\n\t\t\t\tg = true;\n\t\t\t\tadvance(\":\");\n\t\t\t\tfunct[\"(verb)\"] = \"case\";\n\t\t\t\tbreak;\n\t\t\tcase \"default\":\n\t\t\t\tswitch (funct[\"(verb)\"]) {\n\t\t\t\tcase \"break\":\n\t\t\t\tcase \"continue\":\n\t\t\t\tcase \"return\":\n\t\t\t\tcase \"throw\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Do not display a warning if 'default' is the first statement or if\n\t\t\t\t\t// there is a special /* falls through */ comment.\n\t\t\t\t\tif (this.cases.length) {\n\t\t\t\t\t\tif (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {\n\t\t\t\t\t\t\twarning(\"W086\", state.tokens.curr, \"default\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindentation(-state.option.indent);\n\t\t\t\tadvance(\"default\");\n\t\t\t\tg = true;\n\t\t\t\tadvance(\":\");\n\t\t\t\tbreak;\n\t\t\tcase \"}\":\n\t\t\t\tindent -= state.option.indent;\n\t\t\t\tindentation();\n\t\t\t\tadvance(\"}\", t);\n\t\t\t\tfunct[\"(breakage)\"] -= 1;\n\t\t\t\tfunct[\"(verb)\"] = undefined;\n\t\t\t\treturn;\n\t\t\tcase \"(end)\":\n\t\t\t\terror(\"E023\", state.tokens.next, \"}\");\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tif (g) {\n\t\t\t\t\tswitch (state.tokens.curr.id) {\n\t\t\t\t\tcase \",\":\n\t\t\t\t\t\terror(\"E040\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase \":\":\n\t\t\t\t\t\tg = false;\n\t\t\t\t\t\tstatements();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\terror(\"E025\", state.tokens.curr);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (state.tokens.curr.id === \":\") {\n\t\t\t\t\t\tadvance(\":\");\n\t\t\t\t\t\terror(\"E024\", state.tokens.curr, \":\");\n\t\t\t\t\t\tstatements();\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(\"E021\", state.tokens.next, \"case\", state.tokens.next.value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}).labelled = true;\n\n\tstmt(\"debugger\", function () {\n\t\tif (!state.option.debug) {\n\t\t\twarning(\"W087\");\n\t\t}\n\t\treturn this;\n\t}).exps = true;\n\n\t(function () {\n\t\tvar x = stmt(\"do\", function () {\n\t\t\tfunct[\"(breakage)\"] += 1;\n\t\t\tfunct[\"(loopage)\"] += 1;\n\t\t\tincreaseComplexityCount();\n\n\t\t\tthis.first = block(true);\n\t\t\tadvance(\"while\");\n\t\t\tvar t = state.tokens.next;\n\t\t\tnonadjacent(state.tokens.curr, t);\n\t\t\tadvance(\"(\");\n\t\t\tnospace();\n\t\t\texpression(20);\n\t\t\tparseCondAssignment();\n\t\t\tadvance(\")\", t);\n\t\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\t\tfunct[\"(breakage)\"] -= 1;\n\t\t\tfunct[\"(loopage)\"] -= 1;\n\t\t\treturn this;\n\t\t});\n\t\tx.labelled = true;\n\t\tx.exps = true;\n\t}());\n\n\tblockstmt(\"for\", function () {\n\t\tvar s, t = state.tokens.next;\n\t\tfunct[\"(breakage)\"] += 1;\n\t\tfunct[\"(loopage)\"] += 1;\n\t\tincreaseComplexityCount();\n\t\tadvance(\"(\");\n\t\tnonadjacent(this, t);\n\t\tnospace();\n\t\tif (peek(state.tokens.next.id === \"var\" ? 1 : 0).id === \"in\") {\n\t\t\tif (state.tokens.next.id === \"var\") {\n\t\t\t\tadvance(\"var\");\n\t\t\t\tvarstatement.fud.call(varstatement, true);\n\t\t\t} else {\n\t\t\t\tswitch (funct[state.tokens.next.value]) {\n\t\t\t\tcase \"unused\":\n\t\t\t\t\tfunct[state.tokens.next.value] = \"var\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"var\":\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twarning(\"W088\", state.tokens.next, state.tokens.next.value);\n\t\t\t\t}\n\t\t\t\tadvance();\n\t\t\t}\n\t\t\tadvance(\"in\");\n\t\t\texpression(20);\n\t\t\tadvance(\")\", t);\n\t\t\ts = block(true, true);\n\t\t\tif (state.option.forin && s && (s.length > 1 || typeof s[0] !== \"object\" ||\n\t\t\t\t\ts[0].value !== \"if\")) {\n\t\t\t\twarning(\"W089\", this);\n\t\t\t}\n\t\t\tfunct[\"(breakage)\"] -= 1;\n\t\t\tfunct[\"(loopage)\"] -= 1;\n\t\t\treturn this;\n\t\t} else {\n\t\t\tif (state.tokens.next.id !== \";\") {\n\t\t\t\tif (state.tokens.next.id === \"var\") {\n\t\t\t\t\tadvance(\"var\");\n\t\t\t\t\tvarstatement.fud.call(varstatement);\n\t\t\t\t} else {\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\texpression(0, \"for\");\n\t\t\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcomma();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnolinebreak(state.tokens.curr);\n\t\t\tadvance(\";\");\n\t\t\tif (state.tokens.next.id !== \";\") {\n\t\t\t\texpression(20);\n\t\t\t\tparseCondAssignment();\n\t\t\t}\n\t\t\tnolinebreak(state.tokens.curr);\n\t\t\tadvance(\";\");\n\t\t\tif (state.tokens.next.id === \";\") {\n\t\t\t\terror(\"E021\", state.tokens.next, \")\", \";\");\n\t\t\t}\n\t\t\tif (state.tokens.next.id !== \")\") {\n\t\t\t\tfor (;;) {\n\t\t\t\t\texpression(0, \"for\");\n\t\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcomma();\n\t\t\t\t}\n\t\t\t}\n\t\t\tadvance(\")\", t);\n\t\t\tnospace(state.tokens.prev, state.tokens.curr);\n\t\t\tblock(true, true);\n\t\t\tfunct[\"(breakage)\"] -= 1;\n\t\t\tfunct[\"(loopage)\"] -= 1;\n\t\t\treturn this;\n\t\t}\n\t}).labelled = true;\n\n\n\tstmt(\"break\", function () {\n\t\tvar v = state.tokens.next.value;\n\n\t\tif (funct[\"(breakage)\"] === 0)\n\t\t\twarning(\"W052\", state.tokens.next, this.value);\n\n\t\tif (!state.option.asi)\n\t\t\tnolinebreak(this);\n\n\t\tif (state.tokens.next.id !== \";\") {\n\t\t\tif (state.tokens.curr.line === state.tokens.next.line) {\n\t\t\t\tif (funct[v] !== \"label\") {\n\t\t\t\t\twarning(\"W090\", state.tokens.next, v);\n\t\t\t\t} else if (scope[v] !== funct) {\n\t\t\t\t\twarning(\"W091\", state.tokens.next, v);\n\t\t\t\t}\n\t\t\t\tthis.first = state.tokens.next;\n\t\t\t\tadvance();\n\t\t\t}\n\t\t}\n\t\treachable(\"break\");\n\t\treturn this;\n\t}).exps = true;\n\n\n\tstmt(\"continue\", function () {\n\t\tvar v = state.tokens.next.value;\n\n\t\tif (funct[\"(breakage)\"] === 0)\n\t\t\twarning(\"W052\", state.tokens.next, this.value);\n\n\t\tif (!state.option.asi)\n\t\t\tnolinebreak(this);\n\n\t\tif (state.tokens.next.id !== \";\") {\n\t\t\tif (state.tokens.curr.line === state.tokens.next.line) {\n\t\t\t\tif (funct[v] !== \"label\") {\n\t\t\t\t\twarning(\"W090\", state.tokens.next, v);\n\t\t\t\t} else if (scope[v] !== funct) {\n\t\t\t\t\twarning(\"W091\", state.tokens.next, v);\n\t\t\t\t}\n\t\t\t\tthis.first = state.tokens.next;\n\t\t\t\tadvance();\n\t\t\t}\n\t\t} else if (!funct[\"(loopage)\"]) {\n\t\t\twarning(\"W052\", state.tokens.next, this.value);\n\t\t}\n\t\treachable(\"continue\");\n\t\treturn this;\n\t}).exps = true;\n\n\n\tstmt(\"return\", function () {\n\t\tif (this.line === state.tokens.next.line) {\n\t\t\tif (state.tokens.next.id === \"(regexp)\")\n\t\t\t\twarning(\"W092\");\n\n\t\t\tif (state.tokens.next.id !== \";\" && !state.tokens.next.reach) {\n\t\t\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\t\t\tthis.first = expression(0);\n\n\t\t\t\tif (this.first.type === \"(punctuator)\" && this.first.value === \"=\" && !state.option.boss) {\n\t\t\t\t\twarningAt(\"W093\", this.first.line, this.first.character);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!state.option.asi) {\n\t\t\tnolinebreak(this); // always warn (Line breaking error)\n\t\t}\n\t\treachable(\"return\");\n\t\treturn this;\n\t}).exps = true;\n\n\n\tstmt(\"throw\", function () {\n\t\tnolinebreak(this);\n\t\tnonadjacent(state.tokens.curr, state.tokens.next);\n\t\tthis.first = expression(20);\n\t\treachable(\"throw\");\n\t\treturn this;\n\t}).exps = true;\n\n\t// Future Reserved Words\n\n\tFutureReservedWord(\"abstract\");\n\tFutureReservedWord(\"boolean\");\n\tFutureReservedWord(\"byte\");\n\tFutureReservedWord(\"char\");\n\tFutureReservedWord(\"class\", { es5: true });\n\tFutureReservedWord(\"double\");\n\tFutureReservedWord(\"enum\", { es5: true });\n\tFutureReservedWord(\"export\", { es5: true });\n\tFutureReservedWord(\"extends\", { es5: true });\n\tFutureReservedWord(\"final\");\n\tFutureReservedWord(\"float\");\n\tFutureReservedWord(\"goto\");\n\tFutureReservedWord(\"implements\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"import\", { es5: true });\n\tFutureReservedWord(\"int\");\n\tFutureReservedWord(\"interface\");\n\tFutureReservedWord(\"let\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"long\");\n\tFutureReservedWord(\"native\");\n\tFutureReservedWord(\"package\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"private\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"protected\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"public\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"short\");\n\tFutureReservedWord(\"static\", { es5: true, strictOnly: true });\n\tFutureReservedWord(\"super\", { es5: true });\n\tFutureReservedWord(\"synchronized\");\n\tFutureReservedWord(\"throws\");\n\tFutureReservedWord(\"transient\");\n\tFutureReservedWord(\"volatile\");\n\tFutureReservedWord(\"yield\", { es5: true, strictOnly: true });\n\n\t// Parse JSON\n\n\tfunction jsonValue() {\n\n\t\tfunction jsonObject() {\n\t\t\tvar o = {}, t = state.tokens.next;\n\t\t\tadvance(\"{\");\n\t\t\tif (state.tokens.next.id !== \"}\") {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (state.tokens.next.id === \"(end)\") {\n\t\t\t\t\t\terror(\"E026\", state.tokens.next, t.line);\n\t\t\t\t\t} else if (state.tokens.next.id === \"}\") {\n\t\t\t\t\t\twarning(\"W094\", state.tokens.curr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (state.tokens.next.id === \",\") {\n\t\t\t\t\t\terror(\"E028\", state.tokens.next);\n\t\t\t\t\t} else if (state.tokens.next.id !== \"(string)\") {\n\t\t\t\t\t\twarning(\"W095\", state.tokens.next, state.tokens.next.value);\n\t\t\t\t\t}\n\t\t\t\t\tif (o[state.tokens.next.value] === true) {\n\t\t\t\t\t\twarning(\"W075\", state.tokens.next, state.tokens.next.value);\n\t\t\t\t\t} else if ((state.tokens.next.value === \"__proto__\" &&\n\t\t\t\t\t\t!state.option.proto) || (state.tokens.next.value === \"__iterator__\" &&\n\t\t\t\t\t\t!state.option.iterator)) {\n\t\t\t\t\t\twarning(\"W096\", state.tokens.next, state.tokens.next.value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\to[state.tokens.next.value] = true;\n\t\t\t\t\t}\n\t\t\t\t\tadvance();\n\t\t\t\t\tadvance(\":\");\n\t\t\t\t\tjsonValue();\n\t\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tadvance(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tadvance(\"}\");\n\t\t}\n\n\t\tfunction jsonArray() {\n\t\t\tvar t = state.tokens.next;\n\t\t\tadvance(\"[\");\n\t\t\tif (state.tokens.next.id !== \"]\") {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (state.tokens.next.id === \"(end)\") {\n\t\t\t\t\t\terror(\"E027\", state.tokens.next, t.line);\n\t\t\t\t\t} else if (state.tokens.next.id === \"]\") {\n\t\t\t\t\t\twarning(\"W094\", state.tokens.curr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (state.tokens.next.id === \",\") {\n\t\t\t\t\t\terror(\"E028\", state.tokens.next);\n\t\t\t\t\t}\n\t\t\t\t\tjsonValue();\n\t\t\t\t\tif (state.tokens.next.id !== \",\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tadvance(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tadvance(\"]\");\n\t\t}\n\n\t\tswitch (state.tokens.next.id) {\n\t\tcase \"{\":\n\t\t\tjsonObject();\n\t\t\tbreak;\n\t\tcase \"[\":\n\t\t\tjsonArray();\n\t\t\tbreak;\n\t\tcase \"true\":\n\t\tcase \"false\":\n\t\tcase \"null\":\n\t\tcase \"(number)\":\n\t\tcase \"(string)\":\n\t\t\tadvance();\n\t\t\tbreak;\n\t\tcase \"-\":\n\t\t\tadvance(\"-\");\n\t\t\tif (state.tokens.curr.character !== state.tokens.next.from) {\n\t\t\t\twarning(\"W011\", state.tokens.curr);\n\t\t\t}\n\t\t\tadjacent(state.tokens.curr, state.tokens.next);\n\t\t\tadvance(\"(number)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"E003\", state.tokens.next);\n\t\t}\n\t}\n\n\n\t// The actual JSHINT function itself.\n\tvar itself = function (s, o, g) {\n\t\tvar a, i, k, x;\n\t\tvar optionKeys;\n\t\tvar newOptionObj = {};\n\n\t\tstate.reset();\n\n\t\tif (o && o.scope) {\n\t\t\tJSHINT.scope = o.scope;\n\t\t} else {\n\t\t\tJSHINT.errors = [];\n\t\t\tJSHINT.undefs = [];\n\t\t\tJSHINT.internals = [];\n\t\t\tJSHINT.blacklist = {};\n\t\t\tJSHINT.scope = \"(main)\";\n\t\t}\n\n\t\tpredefined = Object.create(null);\n\t\tcombine(predefined, vars.ecmaIdentifiers);\n\t\tcombine(predefined, vars.reservedVars);\n\n\t\tcombine(predefined, g || {});\n\n\t\tdeclared = Object.create(null);\n\t\texported = Object.create(null);\n\t\tignored = Object.create(null);\n\n\t\tif (o) {\n\t\t\ta = o.predef;\n\t\t\tif (a) {\n\t\t\t\tif (!Array.isArray(a) && typeof a === \"object\") {\n\t\t\t\t\ta = Object.keys(a);\n\t\t\t\t}\n\n\t\t\t\ta.forEach(function (item) {\n\t\t\t\t\tvar slice, prop;\n\n\t\t\t\t\tif (item[0] === \"-\") {\n\t\t\t\t\t\tslice = item.slice(1);\n\t\t\t\t\t\tJSHINT.blacklist[slice] = slice;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprop = Object.getOwnPropertyDescriptor(o.predef, item);\n\t\t\t\t\t\tpredefined[item] = prop ? prop.value : false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\toptionKeys = Object.keys(o);\n\t\t\tfor (x = 0; x < optionKeys.length; x++) {\n\t\t\t\tif (/^-W\\d{3}$/g.test(optionKeys[x])) {\n\t\t\t\t\tignored[optionKeys[x].slice(1)] = true;\n\t\t\t\t} else {\n\t\t\t\t\tnewOptionObj[optionKeys[x]] = o[optionKeys[x]];\n\n\t\t\t\t\tif (optionKeys[x] === \"newcap\" && o[optionKeys[x]] === false)\n\t\t\t\t\t\tnewOptionObj[\"(explicitNewcap)\"] = true;\n\n\t\t\t\t\tif (optionKeys[x] === \"indent\")\n\t\t\t\t\t\tnewOptionObj[\"(explicitIndent)\"] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstate.option = newOptionObj;\n\n\t\tstate.option.indent = state.option.indent || 4;\n\t\tstate.option.maxerr = state.option.maxerr || 50;\n\n\t\tindent = 1;\n\t\tglobal = Object.create(predefined);\n\t\tscope = global;\n\t\tfunct = {\n\t\t\t\"(global)\":   true,\n\t\t\t\"(name)\":\t  \"(global)\",\n\t\t\t\"(scope)\":\t  scope,\n\t\t\t\"(breakage)\": 0,\n\t\t\t\"(loopage)\":  0,\n\t\t\t\"(tokens)\":   {},\n\t\t\t\"(metrics)\":   createMetrics(state.tokens.next)\n\t\t};\n\t\tfunctions = [funct];\n\t\turls = [];\n\t\tstack = null;\n\t\tmember = {};\n\t\tmembersOnly = null;\n\t\timplied = {};\n\t\tinblock = false;\n\t\tlookahead = [];\n\t\twarnings = 0;\n\t\tunuseds = [];\n\n\t\tif (!isString(s) && !Array.isArray(s)) {\n\t\t\terrorAt(\"E004\", 0);\n\t\t\treturn false;\n\t\t}\n\n\t\tvar api = {\n\t\t\tget isJSON() {\n\t\t\t\treturn state.jsonMode;\n\t\t\t},\n\n\t\t\tgetOption: function (name) {\n\t\t\t\treturn state.option[name] || null;\n\t\t\t},\n\n\t\t\tgetCache: function (name) {\n\t\t\t\treturn state.cache[name];\n\t\t\t},\n\n\t\t\tsetCache: function (name, value) {\n\t\t\t\tstate.cache[name] = value;\n\t\t\t},\n\n\t\t\twarn: function (code, data) {\n\t\t\t\twarningAt.apply(null, [ code, data.line, data.char ].concat(data.data));\n\t\t\t},\n\n\t\t\ton: function (names, listener) {\n\t\t\t\tnames.split(\" \").forEach(function (name) {\n\t\t\t\t\temitter.on(name, listener);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t};\n\n\t\temitter.removeAllListeners();\n\t\t(extraModules || []).forEach(function (func) {\n\t\t\tfunc(api);\n\t\t});\n\n\t\tstate.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[\"(begin)\"];\n\n\t\tlex = new Lexer(s);\n\n\t\tlex.on(\"warning\", function (ev) {\n\t\t\twarningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));\n\t\t});\n\n\t\tlex.on(\"error\", function (ev) {\n\t\t\terrorAt.apply(null, [ ev.code, ev.line, ev.character ].concat(ev.data));\n\t\t});\n\n\t\tlex.on(\"fatal\", function (ev) {\n\t\t\tquit(\"E041\", ev.line, ev.from);\n\t\t});\n\n\t\tlex.on(\"Identifier\", function (ev) {\n\t\t\temitter.emit(\"Identifier\", ev);\n\t\t});\n\n\t\tlex.on(\"String\", function (ev) {\n\t\t\temitter.emit(\"String\", ev);\n\t\t});\n\n\t\tlex.on(\"Number\", function (ev) {\n\t\t\temitter.emit(\"Number\", ev);\n\t\t});\n\n\t\tlex.start();\n\n\t\t// Check options\n\t\tfor (var name in o) {\n\t\t\tif (_.has(o, name)) {\n\t\t\t\tcheckOption(name, state.tokens.curr);\n\t\t\t}\n\t\t}\n\n\t\tassume();\n\n\t\t// combine the passed globals after we've assumed all our options\n\t\tcombine(predefined, g || {});\n\n\t\t//reset values\n\t\tcomma.first = true;\n\n\t\ttry {\n\t\t\tadvance();\n\t\t\tswitch (state.tokens.next.id) {\n\t\t\tcase \"{\":\n\t\t\tcase \"[\":\n\t\t\t\tstate.option.laxbreak = true;\n\t\t\t\tstate.jsonMode = true;\n\t\t\t\tjsonValue();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdirectives();\n\n\t\t\t\tif (state.directive[\"use strict\"]) {\n\t\t\t\t\tif (!state.option.globalstrict && !state.option.node) {\n\t\t\t\t\t\twarning(\"W097\", state.tokens.prev);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstatements();\n\t\t\t}\n\t\t\tadvance((state.tokens.next && state.tokens.next.value !== \".\")\t? \"(end)\" : undefined);\n\n\t\t\tvar markDefined = function (name, context) {\n\t\t\t\tdo {\n\t\t\t\t\tif (typeof context[name] === \"string\") {\n\t\t\t\t\t\t// JSHINT marks unused variables as 'unused' and\n\t\t\t\t\t\t// unused function declaration as 'unction'. This\n\t\t\t\t\t\t// code changes such instances back 'var' and\n\t\t\t\t\t\t// 'closure' so that the code in JSHINT.data()\n\t\t\t\t\t\t// doesn't think they're unused.\n\n\t\t\t\t\t\tif (context[name] === \"unused\")\n\t\t\t\t\t\t\tcontext[name] = \"var\";\n\t\t\t\t\t\telse if (context[name] === \"unction\")\n\t\t\t\t\t\t\tcontext[name] = \"closure\";\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext = context[\"(context)\"];\n\t\t\t\t} while (context);\n\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\tvar clearImplied = function (name, line) {\n\t\t\t\tif (!implied[name])\n\t\t\t\t\treturn;\n\n\t\t\t\tvar newImplied = [];\n\t\t\t\tfor (var i = 0; i < implied[name].length; i += 1) {\n\t\t\t\t\tif (implied[name][i] !== line)\n\t\t\t\t\t\tnewImplied.push(implied[name][i]);\n\t\t\t\t}\n\n\t\t\t\tif (newImplied.length === 0)\n\t\t\t\t\tdelete implied[name];\n\t\t\t\telse\n\t\t\t\t\timplied[name] = newImplied;\n\t\t\t};\n\n\t\t\tvar warnUnused = function (name, tkn, type, unused_opt) {\n\t\t\t\tvar line = tkn.line;\n\t\t\t\tvar chr  = tkn.character;\n\n\t\t\t\tif (unused_opt === undefined) {\n\t\t\t\t\tunused_opt = state.option.unused;\n\t\t\t\t}\n\n\t\t\t\tif (unused_opt === true) {\n\t\t\t\t\tunused_opt = \"last-param\";\n\t\t\t\t}\n\n\t\t\t\tvar warnable_types = {\n\t\t\t\t\t\"vars\": [\"var\"],\n\t\t\t\t\t\"last-param\": [\"var\", \"last-param\"],\n\t\t\t\t\t\"strict\": [\"var\", \"param\", \"last-param\"]\n\t\t\t\t};\n\n\t\t\t\tif (unused_opt) {\n\t\t\t\t\tif (warnable_types[unused_opt] && warnable_types[unused_opt].indexOf(type) !== -1) {\n\t\t\t\t\t\twarningAt(\"W098\", line, chr, name);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tunuseds.push({\n\t\t\t\t\tname: name,\n\t\t\t\t\tline: line,\n\t\t\t\t\tcharacter: chr\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tvar checkUnused = function (func, key) {\n\t\t\t\tvar type = func[key];\n\t\t\t\tvar tkn = func[\"(tokens)\"][key];\n\n\t\t\t\tif (key.charAt(0) === \"(\")\n\t\t\t\t\treturn;\n\n\t\t\t\tif (type !== \"unused\" && type !== \"unction\")\n\t\t\t\t\treturn;\n\n\t\t\t\t// Params are checked separately from other variables.\n\t\t\t\tif (func[\"(params)\"] && func[\"(params)\"].indexOf(key) !== -1)\n\t\t\t\t\treturn;\n\n\t\t\t\t// Variable is in global scope and defined as exported.\n\t\t\t\tif (func[\"(global)\"] && _.has(exported, key)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twarnUnused(key, tkn, \"var\");\n\t\t\t};\n\n\t\t\t// Check queued 'x is not defined' instances to see if they're still undefined.\n\t\t\tfor (i = 0; i < JSHINT.undefs.length; i += 1) {\n\t\t\t\tk = JSHINT.undefs[i].slice(0);\n\n\t\t\t\tif (markDefined(k[2].value, k[0])) {\n\t\t\t\t\tclearImplied(k[2].value, k[2].line);\n\t\t\t\t} else if (state.option.undef) {\n\t\t\t\t\twarning.apply(warning, k.slice(1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunctions.forEach(function (func) {\n\t\t\t\tif (func[\"(unusedOption)\"] === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in func) {\n\t\t\t\t\tif (_.has(func, key)) {\n\t\t\t\t\t\tcheckUnused(func, key);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!func[\"(params)\"])\n\t\t\t\t\treturn;\n\n\t\t\t\tvar params = func[\"(params)\"].slice();\n\t\t\t\tvar param  = params.pop();\n\t\t\t\tvar type, unused_type;\n\n\t\t\t\twhile (param) {\n\t\t\t\t\ttype = func[param];\n\t\t\t\t\tunused_type = (params.length === func[\"(params)\"].length - 1 ? \"last-param\" : \"param\");\n\n\t\t\t\t\t// 'undefined' is a special case for (function (window, undefined) { ... })();\n\t\t\t\t\t// patterns.\n\n\t\t\t\t\tif (param === \"undefined\")\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tif (type === \"unused\" || type === \"unction\") {\n\t\t\t\t\t\twarnUnused(param, func[\"(tokens)\"][param], unused_type, func[\"(unusedOption)\"]);\n\t\t\t\t\t}\n\n\t\t\t\t\tparam = params.pop();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (var key in declared) {\n\t\t\t\tif (_.has(declared, key) && !_.has(global, key)) {\n\t\t\t\t\twarnUnused(key, declared[key], \"var\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tif (err && err.name === \"JSHintError\") {\n\t\t\t\tvar nt = state.tokens.next || {};\n\t\t\t\tJSHINT.errors.push({\n\t\t\t\t\tscope     : \"(main)\",\n\t\t\t\t\traw       : err.raw,\n\t\t\t\t\treason    : err.message,\n\t\t\t\t\tline      : err.line || nt.line,\n\t\t\t\t\tcharacter : err.character || nt.from\n\t\t\t\t}, null);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\n\t\t// Loop over the listed \"internals\", and check them as well.\n\n\t\tif (JSHINT.scope === \"(main)\") {\n\t\t\to = o || {};\n\n\t\t\tfor (i = 0; i < JSHINT.internals.length; i += 1) {\n\t\t\t\tk = JSHINT.internals[i];\n\t\t\t\to.scope = k.elem;\n\t\t\t\titself(k.value, o, g);\n\t\t\t}\n\t\t}\n\n\t\treturn JSHINT.errors.length === 0;\n\t};\n\n\t// Modules.\n\titself.addModule = function (func) {\n\t\textraModules.push(func);\n\t};\n\n\titself.addModule(style.register);\n\n\t// Data summary.\n\titself.data = function () {\n\t\tvar data = {\n\t\t\tfunctions: [],\n\t\t\toptions: state.option\n\t\t};\n\t\tvar implieds = [];\n\t\tvar members = [];\n\t\tvar fu, f, i, j, n, globals;\n\n\t\tif (itself.errors.length) {\n\t\t\tdata.errors = itself.errors;\n\t\t}\n\n\t\tif (state.jsonMode) {\n\t\t\tdata.json = true;\n\t\t}\n\n\t\tfor (n in implied) {\n\t\t\tif (_.has(implied, n)) {\n\t\t\t\timplieds.push({\n\t\t\t\t\tname: n,\n\t\t\t\t\tline: implied[n]\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (implieds.length > 0) {\n\t\t\tdata.implieds = implieds;\n\t\t}\n\n\t\tif (urls.length > 0) {\n\t\t\tdata.urls = urls;\n\t\t}\n\n\t\tglobals = Object.keys(scope);\n\t\tif (globals.length > 0) {\n\t\t\tdata.globals = globals;\n\t\t}\n\n\t\tfor (i = 1; i < functions.length; i += 1) {\n\t\t\tf = functions[i];\n\t\t\tfu = {};\n\n\t\t\tfor (j = 0; j < functionicity.length; j += 1) {\n\t\t\t\tfu[functionicity[j]] = [];\n\t\t\t}\n\n\t\t\tfor (j = 0; j < functionicity.length; j += 1) {\n\t\t\t\tif (fu[functionicity[j]].length === 0) {\n\t\t\t\t\tdelete fu[functionicity[j]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfu.name = f[\"(name)\"];\n\t\t\tfu.param = f[\"(params)\"];\n\t\t\tfu.line = f[\"(line)\"];\n\t\t\tfu.character = f[\"(character)\"];\n\t\t\tfu.last = f[\"(last)\"];\n\t\t\tfu.lastcharacter = f[\"(lastcharacter)\"];\n\t\t\tdata.functions.push(fu);\n\t\t}\n\n\t\tif (unuseds.length > 0) {\n\t\t\tdata.unused = unuseds;\n\t\t}\n\n\t\tmembers = [];\n\t\tfor (n in member) {\n\t\t\tif (typeof member[n] === \"number\") {\n\t\t\t\tdata.member = member;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t};\n\n\titself.jshint = itself;\n\n\treturn itself;\n}());\n\n// Make JSHINT a Node module, if possible.\nif (typeof exports === \"object\" && exports) {\n\texports.JSHINT = JSHINT;\n}\n\n//@ sourceURL=/src/stable/jshint.js"
));
require("/src/stable/jshint.js");

JSHINT = require('/src/stable/jshint.js').JSHINT;})();


/* **********************************************
     Begin plugins.js
********************************************** */

// place any jQuery/helper plugins in here, instead of separate, slower script files.

/*!
* Bootstrap.js by @fat & @mdo
* Copyright 2012 Twitter, Inc.
* http://www.apache.org/licenses/LICENSE-2.0.txt
*/
!function(e){"use strict";e(function(){e.support.transition=function(){var e=function(){var e=document.createElement("bootstrap"),t={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},n;for(n in t)if(e.style[n]!==undefined)return t[n]}();return e&&{end:e}}()})}(window.jQuery),!function(e){"use strict";var t='[data-dismiss="alert"]',n=function(n){e(n).on("click",t,this.close)};n.prototype.close=function(t){function s(){i.trigger("closed").remove()}var n=e(this),r=n.attr("data-target"),i;r||(r=n.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,"")),i=e(r),t&&t.preventDefault(),i.length||(i=n.hasClass("alert")?n:n.parent()),i.trigger(t=e.Event("close"));if(t.isDefaultPrevented())return;i.removeClass("in"),e.support.transition&&i.hasClass("fade")?i.on(e.support.transition.end,s):s()};var r=e.fn.alert;e.fn.alert=function(t){return this.each(function(){var r=e(this),i=r.data("alert");i||r.data("alert",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.alert.Constructor=n,e.fn.alert.noConflict=function(){return e.fn.alert=r,this},e(document).on("click.alert.data-api",t,n.prototype.close)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.button.defaults,n)};t.prototype.setState=function(e){var t="disabled",n=this.$element,r=n.data(),i=n.is("input")?"val":"html";e+="Text",r.resetText||n.data("resetText",n[i]()),n[i](r[e]||this.options[e]),setTimeout(function(){e=="loadingText"?n.addClass(t).attr(t,t):n.removeClass(t).removeAttr(t)},0)},t.prototype.toggle=function(){var e=this.$element.closest('[data-toggle="buttons-radio"]');e&&e.find(".active").removeClass("active"),this.$element.toggleClass("active")};var n=e.fn.button;e.fn.button=function(n){return this.each(function(){var r=e(this),i=r.data("button"),s=typeof n=="object"&&n;i||r.data("button",i=new t(this,s)),n=="toggle"?i.toggle():n&&i.setState(n)})},e.fn.button.defaults={loadingText:"loading..."},e.fn.button.Constructor=t,e.fn.button.noConflict=function(){return e.fn.button=n,this},e(document).on("click.button.data-api","[data-toggle^=button]",function(t){var n=e(t.target);n.hasClass("btn")||(n=n.closest(".btn")),n.button("toggle")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=n,this.options.pause=="hover"&&this.$element.on("mouseenter",e.proxy(this.pause,this)).on("mouseleave",e.proxy(this.cycle,this))};t.prototype={cycle:function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(e.proxy(this.next,this),this.options.interval)),this},getActiveIndex:function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},to:function(t){var n=this.getActiveIndex(),r=this;if(t>this.$items.length-1||t<0)return;return this.sliding?this.$element.one("slid",function(){r.to(t)}):n==t?this.pause().cycle():this.slide(t>n?"next":"prev",e(this.$items[t]))},pause:function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&e.support.transition.end&&(this.$element.trigger(e.support.transition.end),this.cycle(!0)),clearInterval(this.interval),this.interval=null,this},next:function(){if(this.sliding)return;return this.slide("next")},prev:function(){if(this.sliding)return;return this.slide("prev")},slide:function(t,n){var r=this.$element.find(".item.active"),i=n||r[t](),s=this.interval,o=t=="next"?"left":"right",u=t=="next"?"first":"last",a=this,f;this.sliding=!0,s&&this.pause(),i=i.length?i:this.$element.find(".item")[u](),f=e.Event("slide",{relatedTarget:i[0],direction:o});if(i.hasClass("active"))return;this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid",function(){var t=e(a.$indicators.children()[a.getActiveIndex()]);t&&t.addClass("active")}));if(e.support.transition&&this.$element.hasClass("slide")){this.$element.trigger(f);if(f.isDefaultPrevented())return;i.addClass(t),i[0].offsetWidth,r.addClass(o),i.addClass(o),this.$element.one(e.support.transition.end,function(){i.removeClass([t,o].join(" ")).addClass("active"),r.removeClass(["active",o].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger("slid")},0)})}else{this.$element.trigger(f);if(f.isDefaultPrevented())return;r.removeClass("active"),i.addClass("active"),this.sliding=!1,this.$element.trigger("slid")}return s&&this.cycle(),this}};var n=e.fn.carousel;e.fn.carousel=function(n){return this.each(function(){var r=e(this),i=r.data("carousel"),s=e.extend({},e.fn.carousel.defaults,typeof n=="object"&&n),o=typeof n=="string"?n:s.slide;i||r.data("carousel",i=new t(this,s)),typeof n=="number"?i.to(n):o?i[o]():s.interval&&i.pause().cycle()})},e.fn.carousel.defaults={interval:5e3,pause:"hover"},e.fn.carousel.Constructor=t,e.fn.carousel.noConflict=function(){return e.fn.carousel=n,this},e(document).on("click.carousel.data-api","[data-slide], [data-slide-to]",function(t){var n=e(this),r,i=e(n.attr("data-target")||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,"")),s=e.extend({},i.data(),n.data()),o;i.carousel(s),(o=n.attr("data-slide-to"))&&i.data("carousel").pause().to(o).cycle(),t.preventDefault()})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.collapse.defaults,n),this.options.parent&&(this.$parent=e(this.options.parent)),this.options.toggle&&this.toggle()};t.prototype={constructor:t,dimension:function(){var e=this.$element.hasClass("width");return e?"width":"height"},show:function(){var t,n,r,i;if(this.transitioning||this.$element.hasClass("in"))return;t=this.dimension(),n=e.camelCase(["scroll",t].join("-")),r=this.$parent&&this.$parent.find("> .accordion-group > .in");if(r&&r.length){i=r.data("collapse");if(i&&i.transitioning)return;r.collapse("hide"),i||r.data("collapse",null)}this.$element[t](0),this.transition("addClass",e.Event("show"),"shown"),e.support.transition&&this.$element[t](this.$element[0][n])},hide:function(){var t;if(this.transitioning||!this.$element.hasClass("in"))return;t=this.dimension(),this.reset(this.$element[t]()),this.transition("removeClass",e.Event("hide"),"hidden"),this.$element[t](0)},reset:function(e){var t=this.dimension();return this.$element.removeClass("collapse")[t](e||"auto")[0].offsetWidth,this.$element[e!==null?"addClass":"removeClass"]("collapse"),this},transition:function(t,n,r){var i=this,s=function(){n.type=="show"&&i.reset(),i.transitioning=0,i.$element.trigger(r)};this.$element.trigger(n);if(n.isDefaultPrevented())return;this.transitioning=1,this.$element[t]("in"),e.support.transition&&this.$element.hasClass("collapse")?this.$element.one(e.support.transition.end,s):s()},toggle:function(){this[this.$element.hasClass("in")?"hide":"show"]()}};var n=e.fn.collapse;e.fn.collapse=function(n){return this.each(function(){var r=e(this),i=r.data("collapse"),s=e.extend({},e.fn.collapse.defaults,r.data(),typeof n=="object"&&n);i||r.data("collapse",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.collapse.defaults={toggle:!0},e.fn.collapse.Constructor=t,e.fn.collapse.noConflict=function(){return e.fn.collapse=n,this},e(document).on("click.collapse.data-api","[data-toggle=collapse]",function(t){var n=e(this),r,i=n.attr("data-target")||t.preventDefault()||(r=n.attr("href"))&&r.replace(/.*(?=#[^\s]+$)/,""),s=e(i).data("collapse")?"toggle":n.data();n[e(i).hasClass("in")?"addClass":"removeClass"]("collapsed"),e(i).collapse(s)})}(window.jQuery),!function(e){"use strict";function r(){e(t).each(function(){i(e(this)).removeClass("open")})}function i(t){var n=t.attr("data-target"),r;n||(n=t.attr("href"),n=n&&/#/.test(n)&&n.replace(/.*(?=#[^\s]*$)/,"")),r=n&&e(n);if(!r||!r.length)r=t.parent();return r}var t="[data-toggle=dropdown]",n=function(t){var n=e(t).on("click.dropdown.data-api",this.toggle);e("html").on("click.dropdown.data-api",function(){n.parent().removeClass("open")})};n.prototype={constructor:n,toggle:function(t){var n=e(this),s,o;if(n.is(".disabled, :disabled"))return;return s=i(n),o=s.hasClass("open"),r(),o||s.toggleClass("open"),n.focus(),!1},keydown:function(n){var r,s,o,u,a,f;if(!/(38|40|27)/.test(n.keyCode))return;r=e(this),n.preventDefault(),n.stopPropagation();if(r.is(".disabled, :disabled"))return;u=i(r),a=u.hasClass("open");if(!a||a&&n.keyCode==27)return n.which==27&&u.find(t).focus(),r.click();s=e("[role=menu] li:not(.divider):visible a",u);if(!s.length)return;f=s.index(s.filter(":focus")),n.keyCode==38&&f>0&&f--,n.keyCode==40&&f<s.length-1&&f++,~f||(f=0),s.eq(f).focus()}};var s=e.fn.dropdown;e.fn.dropdown=function(t){return this.each(function(){var r=e(this),i=r.data("dropdown");i||r.data("dropdown",i=new n(this)),typeof t=="string"&&i[t].call(r)})},e.fn.dropdown.Constructor=n,e.fn.dropdown.noConflict=function(){return e.fn.dropdown=s,this},e(document).on("click.dropdown.data-api",r).on("click.dropdown.data-api",".dropdown form",function(e){e.stopPropagation()}).on("click.dropdown-menu",function(e){e.stopPropagation()}).on("click.dropdown.data-api",t,n.prototype.toggle).on("keydown.dropdown.data-api",t+", [role=menu]",n.prototype.keydown)}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=n,this.$element=e(t).delegate('[data-dismiss="modal"]',"click.dismiss.modal",e.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};t.prototype={constructor:t,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var t=this,n=e.Event("show");this.$element.trigger(n);if(this.isShown||n.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var n=e.support.transition&&t.$element.hasClass("fade");t.$element.parent().length||t.$element.appendTo(document.body),t.$element.show(),n&&t.$element[0].offsetWidth,t.$element.addClass("in").attr("aria-hidden",!1),t.enforceFocus(),n?t.$element.one(e.support.transition.end,function(){t.$element.focus().trigger("shown")}):t.$element.focus().trigger("shown")})},hide:function(t){t&&t.preventDefault();var n=this;t=e.Event("hide"),this.$element.trigger(t);if(!this.isShown||t.isDefaultPrevented())return;this.isShown=!1,this.escape(),e(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),e.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var t=this;e(document).on("focusin.modal",function(e){t.$element[0]!==e.target&&!t.$element.has(e.target).length&&t.$element.focus()})},escape:function(){var e=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(t){t.which==27&&e.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var t=this,n=setTimeout(function(){t.$element.off(e.support.transition.end),t.hideModal()},500);this.$element.one(e.support.transition.end,function(){clearTimeout(n),t.hideModal()})},hideModal:function(){var e=this;this.$element.hide(),this.backdrop(function(){e.removeBackdrop(),e.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(t){var n=this,r=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var i=e.support.transition&&r;this.$backdrop=e('<div class="modal-backdrop '+r+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?e.proxy(this.$element[0].focus,this.$element[0]):e.proxy(this.hide,this)),i&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!t)return;i?this.$backdrop.one(e.support.transition.end,t):t()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),e.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(e.support.transition.end,t):t()):t&&t()}};var n=e.fn.modal;e.fn.modal=function(n){return this.each(function(){var r=e(this),i=r.data("modal"),s=e.extend({},e.fn.modal.defaults,r.data(),typeof n=="object"&&n);i||r.data("modal",i=new t(this,s)),typeof n=="string"?i[n]():s.show&&i.show()})},e.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},e.fn.modal.Constructor=t,e.fn.modal.noConflict=function(){return e.fn.modal=n,this},e(document).on("click.modal.data-api",'[data-toggle="modal"]',function(t){var n=e(this),r=n.attr("href"),i=e(n.attr("data-target")||r&&r.replace(/.*(?=#[^\s]+$)/,"")),s=i.data("modal")?"toggle":e.extend({remote:!/#/.test(r)&&r},i.data(),n.data());t.preventDefault(),i.modal(s).one("hide",function(){n.focus()})})}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("tooltip",e,t)};t.prototype={constructor:t,init:function(t,n,r){var i,s,o,u,a;this.type=t,this.$element=e(n),this.options=this.getOptions(r),this.enabled=!0,o=this.options.trigger.split(" ");for(a=o.length;a--;)u=o[a],u=="click"?this.$element.on("click."+this.type,this.options.selector,e.proxy(this.toggle,this)):u!="manual"&&(i=u=="hover"?"mouseenter":"focus",s=u=="hover"?"mouseleave":"blur",this.$element.on(i+"."+this.type,this.options.selector,e.proxy(this.enter,this)),this.$element.on(s+"."+this.type,this.options.selector,e.proxy(this.leave,this)));this.options.selector?this._options=e.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(t){return t=e.extend({},e.fn[this.type].defaults,this.$element.data(),t),t.delay&&typeof t.delay=="number"&&(t.delay={show:t.delay,hide:t.delay}),t},enter:function(t){var n=e.fn[this.type].defaults,r={},i;this._options&&e.each(this._options,function(e,t){n[e]!=t&&(r[e]=t)},this),i=e(t.currentTarget)[this.type](r).data(this.type);if(!i.options.delay||!i.options.delay.show)return i.show();clearTimeout(this.timeout),i.hoverState="in",this.timeout=setTimeout(function(){i.hoverState=="in"&&i.show()},i.options.delay.show)},leave:function(t){var n=e(t.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!n.options.delay||!n.options.delay.hide)return n.hide();n.hoverState="out",this.timeout=setTimeout(function(){n.hoverState=="out"&&n.hide()},n.options.delay.hide)},show:function(){var t,n,r,i,s,o,u=e.Event("show");if(this.hasContent()&&this.enabled){this.$element.trigger(u);if(u.isDefaultPrevented())return;t=this.tip(),this.setContent(),this.options.animation&&t.addClass("fade"),s=typeof this.options.placement=="function"?this.options.placement.call(this,t[0],this.$element[0]):this.options.placement,t.detach().css({top:0,left:0,display:"block"}),this.options.container?t.appendTo(this.options.container):t.insertAfter(this.$element),n=this.getPosition(),r=t[0].offsetWidth,i=t[0].offsetHeight;switch(s){case"bottom":o={top:n.top+n.height,left:n.left+n.width/2-r/2};break;case"top":o={top:n.top-i,left:n.left+n.width/2-r/2};break;case"left":o={top:n.top+n.height/2-i/2,left:n.left-r};break;case"right":o={top:n.top+n.height/2-i/2,left:n.left+n.width}}this.applyPlacement(o,s),this.$element.trigger("shown")}},applyPlacement:function(e,t){var n=this.tip(),r=n[0].offsetWidth,i=n[0].offsetHeight,s,o,u,a;n.offset(e).addClass(t).addClass("in"),s=n[0].offsetWidth,o=n[0].offsetHeight,t=="top"&&o!=i&&(e.top=e.top+i-o,a=!0),t=="bottom"||t=="top"?(u=0,e.left<0&&(u=e.left*-2,e.left=0,n.offset(e),s=n[0].offsetWidth,o=n[0].offsetHeight),this.replaceArrow(u-r+s,s,"left")):this.replaceArrow(o-i,o,"top"),a&&n.offset(e)},replaceArrow:function(e,t,n){this.arrow().css(n,e?50*(1-e/t)+"%":"")},setContent:function(){var e=this.tip(),t=this.getTitle();e.find(".tooltip-inner")[this.options.html?"html":"text"](t),e.removeClass("fade in top bottom left right")},hide:function(){function i(){var t=setTimeout(function(){n.off(e.support.transition.end).detach()},500);n.one(e.support.transition.end,function(){clearTimeout(t),n.detach()})}var t=this,n=this.tip(),r=e.Event("hide");this.$element.trigger(r);if(r.isDefaultPrevented())return;return n.removeClass("in"),e.support.transition&&this.$tip.hasClass("fade")?i():n.detach(),this.$element.trigger("hidden"),this},fixTitle:function(){var e=this.$element;(e.attr("title")||typeof e.attr("data-original-title")!="string")&&e.attr("data-original-title",e.attr("title")||"").attr("title","")},hasContent:function(){return this.getTitle()},getPosition:function(){var t=this.$element[0];return e.extend({},typeof t.getBoundingClientRect=="function"?t.getBoundingClientRect():{width:t.offsetWidth,height:t.offsetHeight},this.$element.offset())},getTitle:function(){var e,t=this.$element,n=this.options;return e=t.attr("data-original-title")||(typeof n.title=="function"?n.title.call(t[0]):n.title),e},tip:function(){return this.$tip=this.$tip||e(this.options.template)},arrow:function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(t){var n=t?e(t.currentTarget)[this.type](this._options).data(this.type):this;n.tip().hasClass("in")?n.hide():n.show()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}};var n=e.fn.tooltip;e.fn.tooltip=function(n){return this.each(function(){var r=e(this),i=r.data("tooltip"),s=typeof n=="object"&&n;i||r.data("tooltip",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.tooltip.Constructor=t,e.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},e.fn.tooltip.noConflict=function(){return e.fn.tooltip=n,this}}(window.jQuery),!function(e){"use strict";var t=function(e,t){this.init("popover",e,t)};t.prototype=e.extend({},e.fn.tooltip.Constructor.prototype,{constructor:t,setContent:function(){var e=this.tip(),t=this.getTitle(),n=this.getContent();e.find(".popover-title")[this.options.html?"html":"text"](t),e.find(".popover-content")[this.options.html?"html":"text"](n),e.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var e,t=this.$element,n=this.options;return e=(typeof n.content=="function"?n.content.call(t[0]):n.content)||t.attr("data-content"),e},tip:function(){return this.$tip||(this.$tip=e(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}});var n=e.fn.popover;e.fn.popover=function(n){return this.each(function(){var r=e(this),i=r.data("popover"),s=typeof n=="object"&&n;i||r.data("popover",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.popover.Constructor=t,e.fn.popover.defaults=e.extend({},e.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),e.fn.popover.noConflict=function(){return e.fn.popover=n,this}}(window.jQuery),!function(e){"use strict";function t(t,n){var r=e.proxy(this.process,this),i=e(t).is("body")?e(window):e(t),s;this.options=e.extend({},e.fn.scrollspy.defaults,n),this.$scrollElement=i.on("scroll.scroll-spy.data-api",r),this.selector=(this.options.target||(s=e(t).attr("href"))&&s.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.$body=e("body"),this.refresh(),this.process()}t.prototype={constructor:t,refresh:function(){var t=this,n;this.offsets=e([]),this.targets=e([]),n=this.$body.find(this.selector).map(function(){var n=e(this),r=n.data("target")||n.attr("href"),i=/^#\w/.test(r)&&e(r);return i&&i.length&&[[i.position().top+(!e.isWindow(t.$scrollElement.get(0))&&t.$scrollElement.scrollTop()),r]]||null}).sort(function(e,t){return e[0]-t[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},process:function(){var e=this.$scrollElement.scrollTop()+this.options.offset,t=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,n=t-this.$scrollElement.height(),r=this.offsets,i=this.targets,s=this.activeTarget,o;if(e>=n)return s!=(o=i.last()[0])&&this.activate(o);for(o=r.length;o--;)s!=i[o]&&e>=r[o]&&(!r[o+1]||e<=r[o+1])&&this.activate(i[o])},activate:function(t){var n,r;this.activeTarget=t,e(this.selector).parent(".active").removeClass("active"),r=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',n=e(r).parent("li").addClass("active"),n.parent(".dropdown-menu").length&&(n=n.closest("li.dropdown").addClass("active")),n.trigger("activate")}};var n=e.fn.scrollspy;e.fn.scrollspy=function(n){return this.each(function(){var r=e(this),i=r.data("scrollspy"),s=typeof n=="object"&&n;i||r.data("scrollspy",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.scrollspy.Constructor=t,e.fn.scrollspy.defaults={offset:10},e.fn.scrollspy.noConflict=function(){return e.fn.scrollspy=n,this},e(window).on("load",function(){e('[data-spy="scroll"]').each(function(){var t=e(this);t.scrollspy(t.data())})})}(window.jQuery),!function(e){"use strict";var t=function(t){this.element=e(t)};t.prototype={constructor:t,show:function(){var t=this.element,n=t.closest("ul:not(.dropdown-menu)"),r=t.attr("data-target"),i,s,o;r||(r=t.attr("href"),r=r&&r.replace(/.*(?=#[^\s]*$)/,""));if(t.parent("li").hasClass("active"))return;i=n.find(".active:last a")[0],o=e.Event("show",{relatedTarget:i}),t.trigger(o);if(o.isDefaultPrevented())return;s=e(r),this.activate(t.parent("li"),n),this.activate(s,s.parent(),function(){t.trigger({type:"shown",relatedTarget:i})})},activate:function(t,n,r){function o(){i.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),t.addClass("active"),s?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu")&&t.closest("li.dropdown").addClass("active"),r&&r()}var i=n.find("> .active"),s=r&&e.support.transition&&i.hasClass("fade");s?i.one(e.support.transition.end,o):o(),i.removeClass("in")}};var n=e.fn.tab;e.fn.tab=function(n){return this.each(function(){var r=e(this),i=r.data("tab");i||r.data("tab",i=new t(this)),typeof n=="string"&&i[n]()})},e.fn.tab.Constructor=t,e.fn.tab.noConflict=function(){return e.fn.tab=n,this},e(document).on("click.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(t){t.preventDefault(),e(this).tab("show")})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.$element=e(t),this.options=e.extend({},e.fn.typeahead.defaults,n),this.matcher=this.options.matcher||this.matcher,this.sorter=this.options.sorter||this.sorter,this.highlighter=this.options.highlighter||this.highlighter,this.updater=this.options.updater||this.updater,this.source=this.options.source,this.$menu=e(this.options.menu),this.shown=!1,this.listen()};t.prototype={constructor:t,select:function(){var e=this.$menu.find(".active").attr("data-value");return this.$element.val(this.updater(e)).change(),this.hide()},updater:function(e){return e},show:function(){var t=e.extend({},this.$element.position(),{height:this.$element[0].offsetHeight});return this.$menu.insertAfter(this.$element).css({top:t.top+t.height,left:t.left}).show(),this.shown=!0,this},hide:function(){return this.$menu.hide(),this.shown=!1,this},lookup:function(t){var n;return this.query=this.$element.val(),!this.query||this.query.length<this.options.minLength?this.shown?this.hide():this:(n=e.isFunction(this.source)?this.source(this.query,e.proxy(this.process,this)):this.source,n?this.process(n):this)},process:function(t){var n=this;return t=e.grep(t,function(e){return n.matcher(e)}),t=this.sorter(t),t.length?this.render(t.slice(0,this.options.items)).show():this.shown?this.hide():this},matcher:function(e){return~e.toLowerCase().indexOf(this.query.toLowerCase())},sorter:function(e){var t=[],n=[],r=[],i;while(i=e.shift())i.toLowerCase().indexOf(this.query.toLowerCase())?~i.indexOf(this.query)?n.push(i):r.push(i):t.push(i);return t.concat(n,r)},highlighter:function(e){var t=this.query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&");return e.replace(new RegExp("("+t+")","ig"),function(e,t){return"<strong>"+t+"</strong>"})},render:function(t){var n=this;return t=e(t).map(function(t,r){return t=e(n.options.item).attr("data-value",r),t.find("a").html(n.highlighter(r)),t[0]}),t.first().addClass("active"),this.$menu.html(t),this},next:function(t){var n=this.$menu.find(".active").removeClass("active"),r=n.next();r.length||(r=e(this.$menu.find("li")[0])),r.addClass("active")},prev:function(e){var t=this.$menu.find(".active").removeClass("active"),n=t.prev();n.length||(n=this.$menu.find("li").last()),n.addClass("active")},listen:function(){this.$element.on("focus",e.proxy(this.focus,this)).on("blur",e.proxy(this.blur,this)).on("keypress",e.proxy(this.keypress,this)).on("keyup",e.proxy(this.keyup,this)),this.eventSupported("keydown")&&this.$element.on("keydown",e.proxy(this.keydown,this)),this.$menu.on("click",e.proxy(this.click,this)).on("mouseenter","li",e.proxy(this.mouseenter,this)).on("mouseleave","li",e.proxy(this.mouseleave,this))},eventSupported:function(e){var t=e in this.$element;return t||(this.$element.setAttribute(e,"return;"),t=typeof this.$element[e]=="function"),t},move:function(e){if(!this.shown)return;switch(e.keyCode){case 9:case 13:case 27:e.preventDefault();break;case 38:e.preventDefault(),this.prev();break;case 40:e.preventDefault(),this.next()}e.stopPropagation()},keydown:function(t){this.suppressKeyPressRepeat=~e.inArray(t.keyCode,[40,38,9,13,27]),this.move(t)},keypress:function(e){if(this.suppressKeyPressRepeat)return;this.move(e)},keyup:function(e){switch(e.keyCode){case 40:case 38:case 16:case 17:case 18:break;case 9:case 13:if(!this.shown)return;this.select();break;case 27:if(!this.shown)return;this.hide();break;default:this.lookup()}e.stopPropagation(),e.preventDefault()},focus:function(e){this.focused=!0},blur:function(e){this.focused=!1,!this.mousedover&&this.shown&&this.hide()},click:function(e){e.stopPropagation(),e.preventDefault(),this.select(),this.$element.focus()},mouseenter:function(t){this.mousedover=!0,this.$menu.find(".active").removeClass("active"),e(t.currentTarget).addClass("active")},mouseleave:function(e){this.mousedover=!1,!this.focused&&this.shown&&this.hide()}};var n=e.fn.typeahead;e.fn.typeahead=function(n){return this.each(function(){var r=e(this),i=r.data("typeahead"),s=typeof n=="object"&&n;i||r.data("typeahead",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.typeahead.defaults={source:[],items:8,menu:'<ul class="typeahead dropdown-menu"></ul>',item:'<li><a href="#"></a></li>',minLength:1},e.fn.typeahead.Constructor=t,e.fn.typeahead.noConflict=function(){return e.fn.typeahead=n,this},e(document).on("focus.typeahead.data-api",'[data-provide="typeahead"]',function(t){var n=e(this);if(n.data("typeahead"))return;n.typeahead(n.data())})}(window.jQuery),!function(e){"use strict";var t=function(t,n){this.options=e.extend({},e.fn.affix.defaults,n),this.$window=e(window).on("scroll.affix.data-api",e.proxy(this.checkPosition,this)).on("click.affix.data-api",e.proxy(function(){setTimeout(e.proxy(this.checkPosition,this),1)},this)),this.$element=e(t),this.checkPosition()};t.prototype.checkPosition=function(){if(!this.$element.is(":visible"))return;var t=e(document).height(),n=this.$window.scrollTop(),r=this.$element.offset(),i=this.options.offset,s=i.bottom,o=i.top,u="affix affix-top affix-bottom",a;typeof i!="object"&&(s=o=i),typeof o=="function"&&(o=i.top()),typeof s=="function"&&(s=i.bottom()),a=this.unpin!=null&&n+this.unpin<=r.top?!1:s!=null&&r.top+this.$element.height()>=t-s?"bottom":o!=null&&n<=o?"top":!1;if(this.affixed===a)return;this.affixed=a,this.unpin=a=="bottom"?r.top-n:null,this.$element.removeClass(u).addClass("affix"+(a?"-"+a:""))};var n=e.fn.affix;e.fn.affix=function(n){return this.each(function(){var r=e(this),i=r.data("affix"),s=typeof n=="object"&&n;i||r.data("affix",i=new t(this,s)),typeof n=="string"&&i[n]()})},e.fn.affix.Constructor=t,e.fn.affix.defaults={offset:0},e.fn.affix.noConflict=function(){return e.fn.affix=n,this},e(window).on("load",function(){e('[data-spy="affix"]').each(function(){var t=e(this),n=t.data();n.offset=n.offset||{},n.offsetBottom&&(n.offset.bottom=n.offsetBottom),n.offsetTop&&(n.offset.top=n.offsetTop),t.affix(n)})})}(window.jQuery);




/* **********************************************
     Begin beautifier.js
********************************************** */

/**
* Language Options
*/
var lbOptionsRadio = $('#lb_options input[type="radio"]');
lbOptionsRadio.on('change', function(){
	var showId = $(this).val();
	$('.cb-options-section, .jb-options-section, .hb-options-section').addClass('hide');
	$('.'+showId).removeClass('hide');
});


/* **********************************************
     Begin html-beautifier.js
********************************************** */

var hbInput = $('#hb_input'),
		hbOutput = $('#hb_output'),
		hbOptionsRadio = $('#hb_options input[type="radio"]'),
		hbOptions = {
			indent_size: 1,
			indent_char: '\t',
			brace_style: "collapse",
			indent_scripts: "normal"
		}
;

/**
* Beautify HTML
*/
function beautifyHtml(){
	// for /assets/js/vendor/htmlbeautify.js
	beautifiedHtml = style_html(hbInput.val(), hbOptions);
	hbOutput.val(beautifiedHtml);
}

/**
* Beautify HTML Options for /assets/js/vendor/htmlbeautify.js
*/

// Indent Char for /assets/js/vendor/htmlbeautify.js
$('.hb-indent-char').on('change', function(){
	var that = $(this);

	switch(that.val()) {
		case 'fourspaces':
			hbOptions.indent_char = '    ';
			break;
		case 'twospaces':
			hbOptions.indent_char = '  ';
			break;
		default:
			hbOptions.indent_char = '\t';
			break;
	}
	beautifyHtml();
});

// Braces for /assets/js/vendor/htmlbeautify.js
$('.hb-braces').on('change', function(){
	hbOptions.brace_style = $(this).val();
	beautifyHtml();
});

// Indent Scripts for /assets/js/vendor/htmlbeautify.js
$('.hb-indent-scripts').on('change', function(){
	hbOptions.indent_scripts = $(this).val();
	beautifyHtml();
});

/**
* Beautify HTML Keyup
*/
hbInput.on('keyup', function(){
	beautifyHtml();
});

/**
* Beautify HTML Load
*/
// if ( hbOutput.length > 0 ) {
// 	beautifyHtml();
// }

/* **********************************************
     Begin css-beautifier.js
********************************************** */

var cbInput = $('#cb_input'),
		cbOutput = $('#cb_output'),
		cbOptions = {
			indent: '\t',
			openbrace: 'separate-line',
			autosemicolon: true,
			csslint: true
		},
		cbOptionsElem = $('#cb_options'),
		cbIndentElem = $('.cb-spacing'),
		cbBracesElem = $('.cb-braces'),
		cbAutoSemicolon = $('.cb-auto-semicolon'),
		cbCssLint = $('#cb_csslint'),
		cbCssLintErrors = $('#cb_csslint_errors'),
		cbCssLintErrorsTextArea = cbCssLintErrors.find('textarea')
;
/**
* CSS Lint
*/
function lintBeautifiedCss(beautifiedCss) {
	if ( !cbOptions.csslint || beautifiedCss.length === 0 ) {
		cbCssLintErrorsTextArea.val('');
		return false;
	}

	var lintedCss = CSSLint.verify( beautifiedCss );
	if ( lintedCss.messages.length > 0) {
		var errorMessage = '';
		$.each(lintedCss.messages, function(){
			var obj = $(this),
					that = obj[0],
					type = that.type.toString().trim().toUpperCase() + ' ',
					column = 'col ' + that.col.toString().trim() + ' ',
					line = 'line ' + that.line.toString().trim() + ' ',
					evidence =  that.evidence.toString().trim() + ' ',
					message = that.message
			;
			errorMessage = errorMessage + type + column + line + evidence + message + "\n";
		});
		cbCssLintErrorsTextArea.val( errorMessage );
	} else {
		cbCssLintErrorsTextArea.val('Your Awesome!!!! There are no issues with your CSS!');
	}
}

/**
* CSS Beautifier
*/
function beautifyCss() {
	var beautifiedCss = cssbeautify( cbInput.val(), cbOptions );
	lintBeautifiedCss(beautifiedCss);
	cbOutput.val( beautifiedCss );
}


/**
* CSS Beautifier Options
*/
// indent is a string used for the indentation of the declaration
cbIndentElem.on('change', function(){
	switch( $(this).val() ) {
		case 'tab':
			cbOptions.indent = '\t';
			break;
		case 'fourspaces':
			cbOptions.indent = '    ';
			break;
		case 'twospaces':
			cbOptions.indent = '  ';
			break;
	}
	beautifyCss();
});

// openbrace defines the placement of open curly brace, either end-of-line
cbBracesElem.on('change', function(){
	cbOptions.openbrace = $(this).val();
	beautifyCss();
});

// autosemicolon always inserts a semicolon after the last ruleset
cbAutoSemicolon.on('change', function(){
	cbOptions.autosemicolon = $(this).is(':checked');
	beautifyCss();
});

// CSS Lint
cbCssLint.on('change', function(){
	cbOptions.csslint = $(this).is(':checked');
	if ( cbOptions.csslint ) {
		cbCssLintErrors.removeClass('hide');
	} else {
		cbCssLintErrors.addClass('hide');
	}
	beautifyCss();
});

/**
* CSS Beautifier Keyup
*/
cbInput.on('keyup', function(){
	beautifyCss();
});


/**
* Beautify CSS Load
*/
// if ( cbOutput.length > 0 ) {
// 	beautifyCss();
// }


/* **********************************************
     Begin js-beautifier.js
********************************************** */

/*
brace_style = "collapse" | "expand" | "end-expand" | "expand-strict";
indent_size = int;
indent_char = '\t' | ' ';
preserve_newlines = true | false;
break_chained_methods = false | true;
max_preserve_newlines = int;
jslint_happy = false | true; // jslint-stricter mode
keep_array_indentation = false | true;
space_before_conditional = true | false;
unescape_strings = false | true;
wrap_line_length = int;
*/
var jbInput = $('#jb_input'),
		jbOutput = $('#jb_output'),
		jbOptionsCheckBox = $('#jb_options input[type="checkbox"]'),
		jbOptionsIndentRadio = $('.jb-indent-char'),
		jbOptionsBracesRadio = $('.jb-braces'),
		jbOptionsNumber = $('#jb_options input[type="number"]'),
		jbOptions = {
			brace_style: "collapse",
			indent_size: 1,
			indent_char: '\t',
			preserve_newlines: true,
			break_chained_methods: false,
			max_preserve_newlines: 0,
			jslint_happy: false,
			keep_array_indentation: false,
			space_before_conditional: true,
			unescape_strings: false,
			wrap_line_length: 0,
			jshint: true
		},
		jbJsHint = $('#jb_jshint'),
		jbJsHintErrors = $('#jb_jshint_errors'),
		jbJsHintErrorsTextArea = $('#jb_jshint_errors').find('textarea')
;

/**
* JSHint
*/
function executeJShint(beautifedJs) {
	if (!jbOptions.jshint || beautifedJs.length === 0) {
		jbJsHintErrorsTextArea.val('');
		return beautifedJs;
	}
	// character: 35
	// evidence: "		console.log(JSHINT.errors)"
	// line: 10
	// reason: "Missing semicolon."
	var jshintSuccess = JSHINT(beautifedJs);
	if ( jshintSuccess ) {
		jbJsHintErrorsTextArea.val('Your Awesome!!!! There are no issues with your JS!');
	} else {
		var errorMsg = '';
		$.each(JSHINT.errors, function() {
			var obj = $(this),
					that = obj[0],
					error = that.id.toString().trim().toUpperCase() + ' ',
					character = 'col ' + that.character.toString().trim() + ' ',
					line = 'line ' + that.line.toString().trim() + ' ',
					evidence = that.evidence.toString().trim() + ' ',
					message = that.reason.toString().trim() + ' '
			;

			errorMsg = errorMsg + error + character + line + evidence + message + "\n";
		});
		jbJsHintErrorsTextArea.val(errorMsg);
	}
}

/**
* Beautify JS
*/
function beautifyJs() {
	var beautifiedJs = js_beautify(jbInput.val(), jbOptions);
	executeJShint(beautifiedJs);
	jbOutput.val(beautifiedJs);
}

/**
* JS Beautifier Options
*/

// Checkboxes
jbOptionsCheckBox.on('change',function(){
	var that = $(this),
			isChecked = that.is(':checked')
	;
	switch( that.attr('name') ) {
		case 'jb_preserve_newlines':
			jbOptions.preserve_newlines = isChecked;
			break;
		case 'jb_break_chained_methods':
			jbOptions.break_chained_methods = isChecked;
			break;
		case 'jb_jslint_happy':
			jbOptions.jslint_happy = isChecked;
			break;
		case 'jb_keep_array_indentation':
			jbOptions.keep_array_indentation = isChecked;
			break;
		case 'jb_space_before_conditional':
			jbOptions.space_before_conditional = isChecked;
			break;
		case 'jb_unescape_strings':
			jbOptions.unescape_strings = isChecked;
			break;
		case 'jb_linting':
			jbOptions.jshint = isChecked;
			if ( jbOptions.jshint ) {
				jbJsHintErrors.removeClass('hide');
			} else {
				jbJsHintErrors.addClass('hide');
			}
			break;
	}
	jbOptions.selectedOption = that.is(':checked');
	beautifyJs();
});

// Indent Radio
jbOptionsIndentRadio.on('change',function(){
	var that = $(this);

	switch( that.val() ) {
		case 'tab':
			jbOptions.indent_char = '\t';
			break;
		case 'fourspaces':
			jbOptions.indent_char = '    ';
			break;
		case 'twospaces':
			jbOptions.indent_char = '  ';
			break;
		default:
			jbOptions.indent_char = '\t';
			break;
	}
	beautifyJs();
});

// Braces Radio
jbOptionsBracesRadio.on('change',function(){
	var that = $(this);

	switch( that.val() ) {
		case 'collapse':
			jbOptions.brace_style = 'collapse';
			break;
		case 'expand':
			jbOptions.brace_style = 'expand';
			break;
		case 'end-expand':
			jbOptions.brace_style = 'end-expand';
			break;
		case 'expand-strict':
			jbOptions.brace_style = 'expand-strict';
			break;
		default:
			jbOptions.brace_style = 'collapse';
			break;
	}
	beautifyJs();
});

// Number Inputs
jbOptionsNumber.on('change',function(){
	var that = $(this);
	if ( that.attr('name') === 'jb_max_preserve_newlines') {
		jbOptions.max_preserve_newlines = that.val();
	}

	if ( that.attr('name') === 'jb_wrap_line_length') {
		jbOptions.wrap_line_length = that.val();
	}
	beautifyJs();
});

/**
* Beautify JS Keyup
*/
jbInput.on('keyup', function(){
	beautifyJs();
});


/**
* Beautify JS Load
*/
// if ( jbOutput.length > 0 ) {
// 	beautifyJs();
// }

/* **********************************************
     Begin minifier.js
********************************************** */

/**
* Language Options
*/
var lmOptionsRadio = $('#lm_options input[type="radio"]');
lmOptionsRadio.on('change', function(){
	var showId = $(this).val();
	$('.cm-options-section, .jm-options-section, .hm-options-section').addClass('hide');
	$('.'+showId).removeClass('hide');
});


/* **********************************************
     Begin css-minifier.js
********************************************** */

/**
* Minify CSS
*/
var cmInput = $('#cm_input'),
		cmOutput = $('#cm_output'),
		cmOptions = {
			csslint: true
		},
		cmCssLint = $('#cm_csslint'),
		cmCssLintErrors = $('#cm_csslint_errors'),
		cmCssLintErrorsTextArea = cmCssLintErrors.find('textarea')
;

/**
* CSS Lint
*/
function lintMinifiedCss(minifiedCss) {
	if ( !cmOptions.csslint || minifiedCss.length === 0 ) {
		cmCssLintErrorsTextArea.val('');
		return false;
	}

	var lintedCss = CSSLint.verify( minifiedCss );
	if ( lintedCss.messages.length > 0) {
		var errorMessage = '';
		$.each(lintedCss.messages, function(){
			var obj = $(this),
					that = obj[0],
					type = that.type.toString().trim().toUpperCase() + ' ',
					column = 'col ' + that.col.toString().trim() + ' ',
					line = 'line ' + that.line.toString().trim() + ' ',
					evidence =  that.evidence.toString().trim() + ' ',
					message = that.message.toString().trim()
			;
			errorMessage = errorMessage + type + column + line + evidence + message + "\n";
		});
		cmCssLintErrorsTextArea.val( errorMessage );
	} else {
		cmCssLintErrorsTextArea.val('Your Awesome!!!! There are no issues with your CSS!');
	}
}

/**
* Minify CSS
*/
function minifyCss() {
	lintMinifiedCss(cmInput.val());
	var minifiedCss = YAHOO.compressor.cssmin(cmInput.val());
	cmOutput.val( minifiedCss );
}

/**
* CSS Minifier Options
*/

// CSS Lint
cmCssLint.on('change', function(){
	cmOptions.csslint = $(this).is(':checked');
	if ( cmOptions.csslint ) {
		cmCssLintErrors.removeClass('hide');
	} else {
		cmCssLintErrors.addClass('hide');
	}
	minifyCss();
});

/**
* Minify CSS Keyup
*/
cmInput.on('keyup', function(){
	minifyCss();
});

/**
* Minify CSS Load
*/
// if ( cmOutput.length > 0 ) {
// 	minifyCss();
// }

/* **********************************************
     Begin js-minifier.js
********************************************** */



/* **********************************************
     Begin html-minifier.js
********************************************** */

var hmInput = $('#hm_input'),
		hmOutput = $('#hm_output'),
		hmStripCommentsCheckbox = $('#hb_strip_comments'),
		ajaxUrl = ajaxObject.ajaxUrl,
		hmOptions = {
			action: 'html_compressor',
			nocomments: 1,
			html: ''
		}
;

/**
* Minify HTML
*/
function minifyHtml() {
	hmOptions.html = hmInput.val();
	$.getJSON( ajaxUrl, hmOptions, function(response){
		hmOutput.val( response.minified );
	});
}


/**
* Minify HTML Checkbox
*/
hmStripCommentsCheckbox.on('change', function(){
	if ( $(this).is(':checked') ) {
		hmOptions.nocomments = 1;
	} else {
		hmOptions.nocomments = 0;
	}
	minifyHtml();
});


/**
* Minify HTML Keyup
*/
hmInput.on('keyup', function(){
	minifyHtml();
});

/**
* Minify HTML Load
*/
// if ( hmOutput.length > 0 ) {
// 	minifyHtml();
// }

/* **********************************************
     Begin scripts.js
********************************************** */

/*
* Header Loader Animation
*/
function headerLoaderAnimation() {
	var headerLoader = $('.header-loader-animation');
	if ( headerLoader.outerWidth() > 0 ) {
		headerLoader.animate({'width': '0%'}, 5000);
	} else {
		headerLoader.animate({'width': '100%'}, 5000);
	}
}
headerLoaderAnimation();

if (!!$('.sticky').offset()) { // make sure ".sticky" element exists

	var	stickyElem = $('.sticky'),
		stickyTop = stickyElem.offset().top;

	$(window).scroll(function(){
		// Make sure window is big enough
		if ( $(this).outerHeight() > (stickyElem.outerHeight() + 10) ) {
			var windowTop = $(window).scrollTop();
			if (stickyTop < windowTop){
				stickyElem.css({ position: 'fixed', top: -55 }).removeClass('offset1').addClass('offset9');
			}
			else {
				stickyElem.css('position','static').removeClass('offset9').addClass('offset1');
			}
		} else {
			stickyElem.css('position','static').removeClass('offset9').addClass('offset1');
		}
	});

}


/* **********************************************
     Begin main.js
********************************************** */

/* Author:
Dan Holloran @dholloran
*/
// @codekit-prepend "vendor/cssbeautify.js"
// @codekit-prepend "vendor/jsbeautify.js"
// @codekit-prepend "vendor/htmlbeautify.js"
// @codekit-prepend "vendor/cssmin.js"
// @codekit-prepend "vendor/csslint.js"
// @codekit-prepend "vendor/jshint-1.1.0.js"
// @codekit-prepend "plugins.js"
jQuery(function($){
	$(window).ready(function(){
		/**
		* Options Advanced Link
		*/
		$('.options-advanced-link').on('click', function(e){
			var that = $(this),
					optionsAdvancedElem = $(that.attr('href'));
					if ( optionsAdvancedElem.hasClass('hide') ) {
						optionsAdvancedElem.removeClass('hide');
						that.text('Hide Advanced Options');
					} else {
						optionsAdvancedElem.addClass('hide');
						that.text('Show Advanced Options');
					}
			e.preventDefault();
		});
		// @codekit-prepend "beautfier/beautifier.js"
		// @codekit-prepend "beautfier/html-beautifier.js"
		// @codekit-prepend "beautfier/css-beautifier.js"
		// @codekit-prepend "beautfier/js-beautifier.js"
		// @codekit-prepend "minifier/minifier.js"
		// @codekit-prepend "minifier/css-minifier.js"
		// @codekit-prepend "minifier/js-minifier.js"
		// @codekit-prepend "minifier/html-minifier.js"
		// @codekit-prepend "scripts.js"
	}); // $(window).ready(
}(jQuery));


